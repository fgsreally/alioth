{
  "resolvedId": "D:/MyProject/5/alioth/examples/dev/node_modules/.vite/deps/yjs.js?v=4de675e4",
  "transforms": [
    {
      "name": "vite:optimized-deps",
      "result": "import \"./chunk-UXIASGQL.js\";\n\n// ../../node_modules/.pnpm/lib0@0.2.80/node_modules/lib0/map.js\nvar create = () => /* @__PURE__ */ new Map();\nvar copy = (m) => {\n  const r = create();\n  m.forEach((v, k) => {\n    r.set(k, v);\n  });\n  return r;\n};\nvar setIfUndefined = (map3, key, createT) => {\n  let set = map3.get(key);\n  if (set === void 0) {\n    map3.set(key, set = createT());\n  }\n  return set;\n};\nvar map = (m, f) => {\n  const res = [];\n  for (const [key, value] of m) {\n    res.push(f(value, key));\n  }\n  return res;\n};\nvar any = (m, f) => {\n  for (const [key, value] of m) {\n    if (f(value, key)) {\n      return true;\n    }\n  }\n  return false;\n};\n\n// ../../node_modules/.pnpm/lib0@0.2.80/node_modules/lib0/set.js\nvar create2 = () => /* @__PURE__ */ new Set();\n\n// ../../node_modules/.pnpm/lib0@0.2.80/node_modules/lib0/array.js\nvar last = (arr) => arr[arr.length - 1];\nvar appendTo = (dest, src) => {\n  for (let i = 0; i < src.length; i++) {\n    dest.push(src[i]);\n  }\n};\nvar from2 = Array.from;\nvar some = (arr, f) => {\n  for (let i = 0; i < arr.length; i++) {\n    if (f(arr[i], i, arr)) {\n      return true;\n    }\n  }\n  return false;\n};\nvar unfold = (len, f) => {\n  const array = new Array(len);\n  for (let i = 0; i < len; i++) {\n    array[i] = f(i, array);\n  }\n  return array;\n};\nvar isArray = Array.isArray;\n\n// ../../node_modules/.pnpm/lib0@0.2.80/node_modules/lib0/observable.js\nvar Observable = class {\n  constructor() {\n    this._observers = create();\n  }\n  /**\n   * @param {N} name\n   * @param {function} f\n   */\n  on(name, f) {\n    setIfUndefined(this._observers, name, create2).add(f);\n  }\n  /**\n   * @param {N} name\n   * @param {function} f\n   */\n  once(name, f) {\n    const _f = (...args2) => {\n      this.off(name, _f);\n      f(...args2);\n    };\n    this.on(name, _f);\n  }\n  /**\n   * @param {N} name\n   * @param {function} f\n   */\n  off(name, f) {\n    const observers = this._observers.get(name);\n    if (observers !== void 0) {\n      observers.delete(f);\n      if (observers.size === 0) {\n        this._observers.delete(name);\n      }\n    }\n  }\n  /**\n   * Emit a named event. All registered event listeners that listen to the\n   * specified name will receive the event.\n   *\n   * @todo This should catch exceptions\n   *\n   * @param {N} name The event name.\n   * @param {Array<any>} args The arguments that are applied to the event listener.\n   */\n  emit(name, args2) {\n    return from2((this._observers.get(name) || create()).values()).forEach((f) => f(...args2));\n  }\n  destroy() {\n    this._observers = create();\n  }\n};\n\n// ../../node_modules/.pnpm/lib0@0.2.80/node_modules/lib0/math.js\nvar floor = Math.floor;\nvar abs = Math.abs;\nvar min = (a, b) => a < b ? a : b;\nvar max = (a, b) => a > b ? a : b;\nvar isNaN = Number.isNaN;\nvar isNegativeZero = (n) => n !== 0 ? n < 0 : 1 / n < 0;\n\n// ../../node_modules/.pnpm/lib0@0.2.80/node_modules/lib0/string.js\nvar fromCharCode = String.fromCharCode;\nvar fromCodePoint = String.fromCodePoint;\nvar MAX_UTF16_CHARACTER = fromCharCode(65535);\nvar toLowerCase = (s) => s.toLowerCase();\nvar trimLeftRegex = /^\\s*/g;\nvar trimLeft = (s) => s.replace(trimLeftRegex, \"\");\nvar fromCamelCaseRegex = /([A-Z])/g;\nvar fromCamelCase = (s, separator) => trimLeft(s.replace(fromCamelCaseRegex, (match) => `${separator}${toLowerCase(match)}`));\nvar _encodeUtf8Polyfill = (str) => {\n  const encodedString = unescape(encodeURIComponent(str));\n  const len = encodedString.length;\n  const buf = new Uint8Array(len);\n  for (let i = 0; i < len; i++) {\n    buf[i] = /** @type {number} */\n    encodedString.codePointAt(i);\n  }\n  return buf;\n};\nvar utf8TextEncoder = (\n  /** @type {TextEncoder} */\n  typeof TextEncoder !== \"undefined\" ? new TextEncoder() : null\n);\nvar _encodeUtf8Native = (str) => utf8TextEncoder.encode(str);\nvar encodeUtf8 = utf8TextEncoder ? _encodeUtf8Native : _encodeUtf8Polyfill;\nvar utf8TextDecoder = typeof TextDecoder === \"undefined\" ? null : new TextDecoder(\"utf-8\", { fatal: true, ignoreBOM: true });\nif (utf8TextDecoder && utf8TextDecoder.decode(new Uint8Array()).length === 1) {\n  utf8TextDecoder = null;\n}\nvar repeat = (source, n) => unfold(n, () => source).join(\"\");\n\n// ../../node_modules/.pnpm/lib0@0.2.80/node_modules/lib0/conditions.js\nvar undefinedToNull = (v) => v === void 0 ? null : v;\n\n// ../../node_modules/.pnpm/lib0@0.2.80/node_modules/lib0/storage.js\nvar VarStoragePolyfill = class {\n  constructor() {\n    this.map = /* @__PURE__ */ new Map();\n  }\n  /**\n   * @param {string} key\n   * @param {any} newValue\n   */\n  setItem(key, newValue) {\n    this.map.set(key, newValue);\n  }\n  /**\n   * @param {string} key\n   */\n  getItem(key) {\n    return this.map.get(key);\n  }\n};\nvar _localStorage = new VarStoragePolyfill();\nvar usePolyfill = true;\ntry {\n  if (typeof localStorage !== \"undefined\") {\n    _localStorage = localStorage;\n    usePolyfill = false;\n  }\n} catch (e) {\n}\nvar varStorage = _localStorage;\n\n// ../../node_modules/.pnpm/lib0@0.2.80/node_modules/lib0/object.js\nvar assign = Object.assign;\nvar keys = Object.keys;\nvar forEach = (obj, f) => {\n  for (const key in obj) {\n    f(obj[key], key);\n  }\n};\nvar length = (obj) => keys(obj).length;\nvar isEmpty = (obj) => {\n  for (const _k in obj) {\n    return false;\n  }\n  return true;\n};\nvar every = (obj, f) => {\n  for (const key in obj) {\n    if (!f(obj[key], key)) {\n      return false;\n    }\n  }\n  return true;\n};\nvar hasProperty = (obj, key) => Object.prototype.hasOwnProperty.call(obj, key);\nvar equalFlat = (a, b) => a === b || length(a) === length(b) && every(a, (val, key) => (val !== void 0 || hasProperty(b, key)) && b[key] === val);\n\n// ../../node_modules/.pnpm/lib0@0.2.80/node_modules/lib0/function.js\nvar callAll = (fs, args2, i = 0) => {\n  try {\n    for (; i < fs.length; i++) {\n      fs[i](...args2);\n    }\n  } finally {\n    if (i < fs.length) {\n      callAll(fs, args2, i + 1);\n    }\n  }\n};\nvar id = (a) => a;\nvar isOneOf = (value, options) => options.includes(value);\n\n// ../../node_modules/.pnpm/lib0@0.2.80/node_modules/lib0/environment.js\nvar isNode = typeof process !== \"undefined\" && process.release && /node|io\\.js/.test(process.release.name);\nvar isMac = typeof navigator !== \"undefined\" ? /Mac/.test(navigator.platform) : false;\nvar params;\nvar args = [];\nvar computeParams = () => {\n  if (params === void 0) {\n    if (isNode) {\n      params = create();\n      const pargs = process.argv;\n      let currParamName = null;\n      for (let i = 0; i < pargs.length; i++) {\n        const parg = pargs[i];\n        if (parg[0] === \"-\") {\n          if (currParamName !== null) {\n            params.set(currParamName, \"\");\n          }\n          currParamName = parg;\n        } else {\n          if (currParamName !== null) {\n            params.set(currParamName, parg);\n            currParamName = null;\n          } else {\n            args.push(parg);\n          }\n        }\n      }\n      if (currParamName !== null) {\n        params.set(currParamName, \"\");\n      }\n    } else if (typeof location === \"object\") {\n      params = create();\n      (location.search || \"?\").slice(1).split(\"&\").forEach((kv) => {\n        if (kv.length !== 0) {\n          const [key, value] = kv.split(\"=\");\n          params.set(`--${fromCamelCase(key, \"-\")}`, value);\n          params.set(`-${fromCamelCase(key, \"-\")}`, value);\n        }\n      });\n    } else {\n      params = create();\n    }\n  }\n  return params;\n};\nvar hasParam = (name) => computeParams().has(name);\nvar getVariable = (name) => isNode ? undefinedToNull(process.env[name.toUpperCase()]) : undefinedToNull(varStorage.getItem(name));\nvar hasConf = (name) => hasParam(\"--\" + name) || getVariable(name) !== null;\nvar production = hasConf(\"production\");\nvar forceColor = isNode && isOneOf(process.env.FORCE_COLOR, [\"true\", \"1\", \"2\"]);\nvar supportsColor = !hasParam(\"no-colors\") && (!isNode || process.stdout.isTTY || forceColor) && (!isNode || hasParam(\"color\") || forceColor || getVariable(\"COLORTERM\") !== null || (getVariable(\"TERM\") || \"\").includes(\"color\"));\n\n// ../../node_modules/.pnpm/lib0@0.2.80/node_modules/lib0/binary.js\nvar BIT1 = 1;\nvar BIT2 = 2;\nvar BIT3 = 4;\nvar BIT4 = 8;\nvar BIT6 = 32;\nvar BIT7 = 64;\nvar BIT8 = 128;\nvar BIT18 = 1 << 17;\nvar BIT19 = 1 << 18;\nvar BIT20 = 1 << 19;\nvar BIT21 = 1 << 20;\nvar BIT22 = 1 << 21;\nvar BIT23 = 1 << 22;\nvar BIT24 = 1 << 23;\nvar BIT25 = 1 << 24;\nvar BIT26 = 1 << 25;\nvar BIT27 = 1 << 26;\nvar BIT28 = 1 << 27;\nvar BIT29 = 1 << 28;\nvar BIT30 = 1 << 29;\nvar BIT31 = 1 << 30;\nvar BIT32 = 1 << 31;\nvar BITS5 = 31;\nvar BITS6 = 63;\nvar BITS7 = 127;\nvar BITS17 = BIT18 - 1;\nvar BITS18 = BIT19 - 1;\nvar BITS19 = BIT20 - 1;\nvar BITS20 = BIT21 - 1;\nvar BITS21 = BIT22 - 1;\nvar BITS22 = BIT23 - 1;\nvar BITS23 = BIT24 - 1;\nvar BITS24 = BIT25 - 1;\nvar BITS25 = BIT26 - 1;\nvar BITS26 = BIT27 - 1;\nvar BITS27 = BIT28 - 1;\nvar BITS28 = BIT29 - 1;\nvar BITS29 = BIT30 - 1;\nvar BITS30 = BIT31 - 1;\nvar BITS31 = 2147483647;\n\n// ../../node_modules/.pnpm/lib0@0.2.80/node_modules/lib0/number.js\nvar MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER;\nvar MIN_SAFE_INTEGER = Number.MIN_SAFE_INTEGER;\nvar LOWEST_INT32 = 1 << 31;\nvar isInteger = Number.isInteger || ((num) => typeof num === \"number\" && isFinite(num) && floor(num) === num);\nvar isNaN2 = Number.isNaN;\nvar parseInt = Number.parseInt;\n\n// ../../node_modules/.pnpm/lib0@0.2.80/node_modules/lib0/error.js\nvar create3 = (s) => new Error(s);\nvar methodUnimplemented = () => {\n  throw create3(\"Method unimplemented\");\n};\nvar unexpectedCase = () => {\n  throw create3(\"Unexpected case\");\n};\n\n// ../../node_modules/.pnpm/lib0@0.2.80/node_modules/lib0/decoding.js\nvar errorUnexpectedEndOfArray = create3(\"Unexpected end of array\");\nvar errorIntegerOutOfRange = create3(\"Integer out of Range\");\nvar Decoder = class {\n  /**\n   * @param {Uint8Array} uint8Array Binary data to decode\n   */\n  constructor(uint8Array) {\n    this.arr = uint8Array;\n    this.pos = 0;\n  }\n};\nvar createDecoder = (uint8Array) => new Decoder(uint8Array);\nvar hasContent = (decoder) => decoder.pos !== decoder.arr.length;\nvar readUint8Array = (decoder, len) => {\n  const view = createUint8ArrayViewFromArrayBuffer(decoder.arr.buffer, decoder.pos + decoder.arr.byteOffset, len);\n  decoder.pos += len;\n  return view;\n};\nvar readVarUint8Array = (decoder) => readUint8Array(decoder, readVarUint(decoder));\nvar readUint8 = (decoder) => decoder.arr[decoder.pos++];\nvar readVarUint = (decoder) => {\n  let num = 0;\n  let mult = 1;\n  const len = decoder.arr.length;\n  while (decoder.pos < len) {\n    const r = decoder.arr[decoder.pos++];\n    num = num + (r & BITS7) * mult;\n    mult *= 128;\n    if (r < BIT8) {\n      return num;\n    }\n    if (num > MAX_SAFE_INTEGER) {\n      throw errorIntegerOutOfRange;\n    }\n  }\n  throw errorUnexpectedEndOfArray;\n};\nvar readVarInt = (decoder) => {\n  let r = decoder.arr[decoder.pos++];\n  let num = r & BITS6;\n  let mult = 64;\n  const sign = (r & BIT7) > 0 ? -1 : 1;\n  if ((r & BIT8) === 0) {\n    return sign * num;\n  }\n  const len = decoder.arr.length;\n  while (decoder.pos < len) {\n    r = decoder.arr[decoder.pos++];\n    num = num + (r & BITS7) * mult;\n    mult *= 128;\n    if (r < BIT8) {\n      return sign * num;\n    }\n    if (num > MAX_SAFE_INTEGER) {\n      throw errorIntegerOutOfRange;\n    }\n  }\n  throw errorUnexpectedEndOfArray;\n};\nvar _readVarStringPolyfill = (decoder) => {\n  let remainingLen = readVarUint(decoder);\n  if (remainingLen === 0) {\n    return \"\";\n  } else {\n    let encodedString = String.fromCodePoint(readUint8(decoder));\n    if (--remainingLen < 100) {\n      while (remainingLen--) {\n        encodedString += String.fromCodePoint(readUint8(decoder));\n      }\n    } else {\n      while (remainingLen > 0) {\n        const nextLen = remainingLen < 1e4 ? remainingLen : 1e4;\n        const bytes = decoder.arr.subarray(decoder.pos, decoder.pos + nextLen);\n        decoder.pos += nextLen;\n        encodedString += String.fromCodePoint.apply(\n          null,\n          /** @type {any} */\n          bytes\n        );\n        remainingLen -= nextLen;\n      }\n    }\n    return decodeURIComponent(escape(encodedString));\n  }\n};\nvar _readVarStringNative = (decoder) => (\n  /** @type any */\n  utf8TextDecoder.decode(readVarUint8Array(decoder))\n);\nvar readVarString = utf8TextDecoder ? _readVarStringNative : _readVarStringPolyfill;\nvar readFromDataView = (decoder, len) => {\n  const dv = new DataView(decoder.arr.buffer, decoder.arr.byteOffset + decoder.pos, len);\n  decoder.pos += len;\n  return dv;\n};\nvar readFloat32 = (decoder) => readFromDataView(decoder, 4).getFloat32(0, false);\nvar readFloat64 = (decoder) => readFromDataView(decoder, 8).getFloat64(0, false);\nvar readBigInt64 = (decoder) => (\n  /** @type {any} */\n  readFromDataView(decoder, 8).getBigInt64(0, false)\n);\nvar readAnyLookupTable = [\n  (decoder) => void 0,\n  // CASE 127: undefined\n  (decoder) => null,\n  // CASE 126: null\n  readVarInt,\n  // CASE 125: integer\n  readFloat32,\n  // CASE 124: float32\n  readFloat64,\n  // CASE 123: float64\n  readBigInt64,\n  // CASE 122: bigint\n  (decoder) => false,\n  // CASE 121: boolean (false)\n  (decoder) => true,\n  // CASE 120: boolean (true)\n  readVarString,\n  // CASE 119: string\n  (decoder) => {\n    const len = readVarUint(decoder);\n    const obj = {};\n    for (let i = 0; i < len; i++) {\n      const key = readVarString(decoder);\n      obj[key] = readAny(decoder);\n    }\n    return obj;\n  },\n  (decoder) => {\n    const len = readVarUint(decoder);\n    const arr = [];\n    for (let i = 0; i < len; i++) {\n      arr.push(readAny(decoder));\n    }\n    return arr;\n  },\n  readVarUint8Array\n  // CASE 116: Uint8Array\n];\nvar readAny = (decoder) => readAnyLookupTable[127 - readUint8(decoder)](decoder);\nvar RleDecoder = class extends Decoder {\n  /**\n   * @param {Uint8Array} uint8Array\n   * @param {function(Decoder):T} reader\n   */\n  constructor(uint8Array, reader) {\n    super(uint8Array);\n    this.reader = reader;\n    this.s = null;\n    this.count = 0;\n  }\n  read() {\n    if (this.count === 0) {\n      this.s = this.reader(this);\n      if (hasContent(this)) {\n        this.count = readVarUint(this) + 1;\n      } else {\n        this.count = -1;\n      }\n    }\n    this.count--;\n    return (\n      /** @type {T} */\n      this.s\n    );\n  }\n};\nvar UintOptRleDecoder = class extends Decoder {\n  /**\n   * @param {Uint8Array} uint8Array\n   */\n  constructor(uint8Array) {\n    super(uint8Array);\n    this.s = 0;\n    this.count = 0;\n  }\n  read() {\n    if (this.count === 0) {\n      this.s = readVarInt(this);\n      const isNegative = isNegativeZero(this.s);\n      this.count = 1;\n      if (isNegative) {\n        this.s = -this.s;\n        this.count = readVarUint(this) + 2;\n      }\n    }\n    this.count--;\n    return (\n      /** @type {number} */\n      this.s\n    );\n  }\n};\nvar IntDiffOptRleDecoder = class extends Decoder {\n  /**\n   * @param {Uint8Array} uint8Array\n   */\n  constructor(uint8Array) {\n    super(uint8Array);\n    this.s = 0;\n    this.count = 0;\n    this.diff = 0;\n  }\n  /**\n   * @return {number}\n   */\n  read() {\n    if (this.count === 0) {\n      const diff = readVarInt(this);\n      const hasCount = diff & 1;\n      this.diff = floor(diff / 2);\n      this.count = 1;\n      if (hasCount) {\n        this.count = readVarUint(this) + 2;\n      }\n    }\n    this.s += this.diff;\n    this.count--;\n    return this.s;\n  }\n};\nvar StringDecoder = class {\n  /**\n   * @param {Uint8Array} uint8Array\n   */\n  constructor(uint8Array) {\n    this.decoder = new UintOptRleDecoder(uint8Array);\n    this.str = readVarString(this.decoder);\n    this.spos = 0;\n  }\n  /**\n   * @return {string}\n   */\n  read() {\n    const end = this.spos + this.decoder.read();\n    const res = this.str.slice(this.spos, end);\n    this.spos = end;\n    return res;\n  }\n};\n\n// ../../node_modules/.pnpm/lib0@0.2.80/node_modules/lib0/buffer.js\nvar createUint8ArrayFromLen = (len) => new Uint8Array(len);\nvar createUint8ArrayViewFromArrayBuffer = (buffer, byteOffset, length3) => new Uint8Array(buffer, byteOffset, length3);\nvar copyUint8Array = (uint8Array) => {\n  const newBuf = createUint8ArrayFromLen(uint8Array.byteLength);\n  newBuf.set(uint8Array);\n  return newBuf;\n};\n\n// ../../node_modules/.pnpm/lib0@0.2.80/node_modules/lib0/encoding.js\nvar Encoder = class {\n  constructor() {\n    this.cpos = 0;\n    this.cbuf = new Uint8Array(100);\n    this.bufs = [];\n  }\n};\nvar createEncoder = () => new Encoder();\nvar length2 = (encoder) => {\n  let len = encoder.cpos;\n  for (let i = 0; i < encoder.bufs.length; i++) {\n    len += encoder.bufs[i].length;\n  }\n  return len;\n};\nvar toUint8Array = (encoder) => {\n  const uint8arr = new Uint8Array(length2(encoder));\n  let curPos = 0;\n  for (let i = 0; i < encoder.bufs.length; i++) {\n    const d = encoder.bufs[i];\n    uint8arr.set(d, curPos);\n    curPos += d.length;\n  }\n  uint8arr.set(createUint8ArrayViewFromArrayBuffer(encoder.cbuf.buffer, 0, encoder.cpos), curPos);\n  return uint8arr;\n};\nvar verifyLen = (encoder, len) => {\n  const bufferLen = encoder.cbuf.length;\n  if (bufferLen - encoder.cpos < len) {\n    encoder.bufs.push(createUint8ArrayViewFromArrayBuffer(encoder.cbuf.buffer, 0, encoder.cpos));\n    encoder.cbuf = new Uint8Array(max(bufferLen, len) * 2);\n    encoder.cpos = 0;\n  }\n};\nvar write = (encoder, num) => {\n  const bufferLen = encoder.cbuf.length;\n  if (encoder.cpos === bufferLen) {\n    encoder.bufs.push(encoder.cbuf);\n    encoder.cbuf = new Uint8Array(bufferLen * 2);\n    encoder.cpos = 0;\n  }\n  encoder.cbuf[encoder.cpos++] = num;\n};\nvar writeUint8 = write;\nvar writeVarUint = (encoder, num) => {\n  while (num > BITS7) {\n    write(encoder, BIT8 | BITS7 & num);\n    num = floor(num / 128);\n  }\n  write(encoder, BITS7 & num);\n};\nvar writeVarInt = (encoder, num) => {\n  const isNegative = isNegativeZero(num);\n  if (isNegative) {\n    num = -num;\n  }\n  write(encoder, (num > BITS6 ? BIT8 : 0) | (isNegative ? BIT7 : 0) | BITS6 & num);\n  num = floor(num / 64);\n  while (num > 0) {\n    write(encoder, (num > BITS7 ? BIT8 : 0) | BITS7 & num);\n    num = floor(num / 128);\n  }\n};\nvar _strBuffer = new Uint8Array(3e4);\nvar _maxStrBSize = _strBuffer.length / 3;\nvar _writeVarStringNative = (encoder, str) => {\n  if (str.length < _maxStrBSize) {\n    const written = utf8TextEncoder.encodeInto(str, _strBuffer).written || 0;\n    writeVarUint(encoder, written);\n    for (let i = 0; i < written; i++) {\n      write(encoder, _strBuffer[i]);\n    }\n  } else {\n    writeVarUint8Array(encoder, encodeUtf8(str));\n  }\n};\nvar _writeVarStringPolyfill = (encoder, str) => {\n  const encodedString = unescape(encodeURIComponent(str));\n  const len = encodedString.length;\n  writeVarUint(encoder, len);\n  for (let i = 0; i < len; i++) {\n    write(\n      encoder,\n      /** @type {number} */\n      encodedString.codePointAt(i)\n    );\n  }\n};\nvar writeVarString = utf8TextEncoder && /** @type {any} */\nutf8TextEncoder.encodeInto ? _writeVarStringNative : _writeVarStringPolyfill;\nvar writeBinaryEncoder = (encoder, append2) => writeUint8Array(encoder, toUint8Array(append2));\nvar writeUint8Array = (encoder, uint8Array) => {\n  const bufferLen = encoder.cbuf.length;\n  const cpos = encoder.cpos;\n  const leftCopyLen = min(bufferLen - cpos, uint8Array.length);\n  const rightCopyLen = uint8Array.length - leftCopyLen;\n  encoder.cbuf.set(uint8Array.subarray(0, leftCopyLen), cpos);\n  encoder.cpos += leftCopyLen;\n  if (rightCopyLen > 0) {\n    encoder.bufs.push(encoder.cbuf);\n    encoder.cbuf = new Uint8Array(max(bufferLen * 2, rightCopyLen));\n    encoder.cbuf.set(uint8Array.subarray(leftCopyLen));\n    encoder.cpos = rightCopyLen;\n  }\n};\nvar writeVarUint8Array = (encoder, uint8Array) => {\n  writeVarUint(encoder, uint8Array.byteLength);\n  writeUint8Array(encoder, uint8Array);\n};\nvar writeOnDataView = (encoder, len) => {\n  verifyLen(encoder, len);\n  const dview = new DataView(encoder.cbuf.buffer, encoder.cpos, len);\n  encoder.cpos += len;\n  return dview;\n};\nvar writeFloat32 = (encoder, num) => writeOnDataView(encoder, 4).setFloat32(0, num, false);\nvar writeFloat64 = (encoder, num) => writeOnDataView(encoder, 8).setFloat64(0, num, false);\nvar writeBigInt64 = (encoder, num) => (\n  /** @type {any} */\n  writeOnDataView(encoder, 8).setBigInt64(0, num, false)\n);\nvar floatTestBed = new DataView(new ArrayBuffer(4));\nvar isFloat32 = (num) => {\n  floatTestBed.setFloat32(0, num);\n  return floatTestBed.getFloat32(0) === num;\n};\nvar writeAny = (encoder, data) => {\n  switch (typeof data) {\n    case \"string\":\n      write(encoder, 119);\n      writeVarString(encoder, data);\n      break;\n    case \"number\":\n      if (isInteger(data) && abs(data) <= BITS31) {\n        write(encoder, 125);\n        writeVarInt(encoder, data);\n      } else if (isFloat32(data)) {\n        write(encoder, 124);\n        writeFloat32(encoder, data);\n      } else {\n        write(encoder, 123);\n        writeFloat64(encoder, data);\n      }\n      break;\n    case \"bigint\":\n      write(encoder, 122);\n      writeBigInt64(encoder, data);\n      break;\n    case \"object\":\n      if (data === null) {\n        write(encoder, 126);\n      } else if (isArray(data)) {\n        write(encoder, 117);\n        writeVarUint(encoder, data.length);\n        for (let i = 0; i < data.length; i++) {\n          writeAny(encoder, data[i]);\n        }\n      } else if (data instanceof Uint8Array) {\n        write(encoder, 116);\n        writeVarUint8Array(encoder, data);\n      } else {\n        write(encoder, 118);\n        const keys2 = Object.keys(data);\n        writeVarUint(encoder, keys2.length);\n        for (let i = 0; i < keys2.length; i++) {\n          const key = keys2[i];\n          writeVarString(encoder, key);\n          writeAny(encoder, data[key]);\n        }\n      }\n      break;\n    case \"boolean\":\n      write(encoder, data ? 120 : 121);\n      break;\n    default:\n      write(encoder, 127);\n  }\n};\nvar RleEncoder = class extends Encoder {\n  /**\n   * @param {function(Encoder, T):void} writer\n   */\n  constructor(writer) {\n    super();\n    this.w = writer;\n    this.s = null;\n    this.count = 0;\n  }\n  /**\n   * @param {T} v\n   */\n  write(v) {\n    if (this.s === v) {\n      this.count++;\n    } else {\n      if (this.count > 0) {\n        writeVarUint(this, this.count - 1);\n      }\n      this.count = 1;\n      this.w(this, v);\n      this.s = v;\n    }\n  }\n};\nvar flushUintOptRleEncoder = (encoder) => {\n  if (encoder.count > 0) {\n    writeVarInt(encoder.encoder, encoder.count === 1 ? encoder.s : -encoder.s);\n    if (encoder.count > 1) {\n      writeVarUint(encoder.encoder, encoder.count - 2);\n    }\n  }\n};\nvar UintOptRleEncoder = class {\n  constructor() {\n    this.encoder = new Encoder();\n    this.s = 0;\n    this.count = 0;\n  }\n  /**\n   * @param {number} v\n   */\n  write(v) {\n    if (this.s === v) {\n      this.count++;\n    } else {\n      flushUintOptRleEncoder(this);\n      this.count = 1;\n      this.s = v;\n    }\n  }\n  toUint8Array() {\n    flushUintOptRleEncoder(this);\n    return toUint8Array(this.encoder);\n  }\n};\nvar flushIntDiffOptRleEncoder = (encoder) => {\n  if (encoder.count > 0) {\n    const encodedDiff = encoder.diff * 2 + (encoder.count === 1 ? 0 : 1);\n    writeVarInt(encoder.encoder, encodedDiff);\n    if (encoder.count > 1) {\n      writeVarUint(encoder.encoder, encoder.count - 2);\n    }\n  }\n};\nvar IntDiffOptRleEncoder = class {\n  constructor() {\n    this.encoder = new Encoder();\n    this.s = 0;\n    this.count = 0;\n    this.diff = 0;\n  }\n  /**\n   * @param {number} v\n   */\n  write(v) {\n    if (this.diff === v - this.s) {\n      this.s = v;\n      this.count++;\n    } else {\n      flushIntDiffOptRleEncoder(this);\n      this.count = 1;\n      this.diff = v - this.s;\n      this.s = v;\n    }\n  }\n  toUint8Array() {\n    flushIntDiffOptRleEncoder(this);\n    return toUint8Array(this.encoder);\n  }\n};\nvar StringEncoder = class {\n  constructor() {\n    this.sarr = [];\n    this.s = \"\";\n    this.lensE = new UintOptRleEncoder();\n  }\n  /**\n   * @param {string} string\n   */\n  write(string) {\n    this.s += string;\n    if (this.s.length > 19) {\n      this.sarr.push(this.s);\n      this.s = \"\";\n    }\n    this.lensE.write(string.length);\n  }\n  toUint8Array() {\n    const encoder = new Encoder();\n    this.sarr.push(this.s);\n    this.s = \"\";\n    writeVarString(encoder, this.sarr.join(\"\"));\n    writeUint8Array(encoder, this.lensE.toUint8Array());\n    return toUint8Array(encoder);\n  }\n};\n\n// ../../node_modules/.pnpm/lib0@0.2.80/node_modules/lib0/webcrypto.js\nvar subtle = crypto.subtle;\nvar getRandomValues = crypto.getRandomValues.bind(crypto);\n\n// ../../node_modules/.pnpm/lib0@0.2.80/node_modules/lib0/random.js\nvar uint32 = () => getRandomValues(new Uint32Array(1))[0];\nvar uuidv4Template = [1e7] + -1e3 + -4e3 + -8e3 + -1e11;\nvar uuidv4 = () => uuidv4Template.replace(\n  /[018]/g,\n  /** @param {number} c */\n  (c) => (c ^ uint32() & 15 >> c / 4).toString(16)\n);\n\n// ../../node_modules/.pnpm/lib0@0.2.80/node_modules/lib0/time.js\nvar getUnixTime = Date.now;\n\n// ../../node_modules/.pnpm/lib0@0.2.80/node_modules/lib0/promise.js\nvar create4 = (f) => (\n  /** @type {Promise<T>} */\n  new Promise(f)\n);\nvar all = Promise.all.bind(Promise);\n\n// ../../node_modules/.pnpm/lib0@0.2.80/node_modules/lib0/pair.js\nvar Pair = class {\n  /**\n   * @param {L} left\n   * @param {R} right\n   */\n  constructor(left, right) {\n    this.left = left;\n    this.right = right;\n  }\n};\nvar create5 = (left, right) => new Pair(left, right);\n\n// ../../node_modules/.pnpm/lib0@0.2.80/node_modules/lib0/dom.js\nvar doc = (\n  /** @type {Document} */\n  typeof document !== \"undefined\" ? document : {}\n);\nvar domParser = (\n  /** @type {DOMParser} */\n  typeof DOMParser !== \"undefined\" ? new DOMParser() : null\n);\nvar mapToStyleString = (m) => map(m, (value, key) => `${key}:${value};`).join(\"\");\nvar ELEMENT_NODE = doc.ELEMENT_NODE;\nvar TEXT_NODE = doc.TEXT_NODE;\nvar CDATA_SECTION_NODE = doc.CDATA_SECTION_NODE;\nvar COMMENT_NODE = doc.COMMENT_NODE;\nvar DOCUMENT_NODE = doc.DOCUMENT_NODE;\nvar DOCUMENT_TYPE_NODE = doc.DOCUMENT_TYPE_NODE;\nvar DOCUMENT_FRAGMENT_NODE = doc.DOCUMENT_FRAGMENT_NODE;\n\n// ../../node_modules/.pnpm/lib0@0.2.80/node_modules/lib0/eventloop.js\nvar createTimeoutClass = (clearFunction) => class TT {\n  /**\n   * @param {number} timeoutId\n   */\n  constructor(timeoutId) {\n    this._ = timeoutId;\n  }\n  destroy() {\n    clearFunction(this._);\n  }\n};\nvar Timeout = createTimeoutClass(clearTimeout);\nvar Interval = createTimeoutClass(clearInterval);\nvar Animation = createTimeoutClass((arg) => typeof requestAnimationFrame !== \"undefined\" && cancelAnimationFrame(arg));\nvar Idle = createTimeoutClass((arg) => typeof cancelIdleCallback !== \"undefined\" && cancelIdleCallback(arg));\n\n// ../../node_modules/.pnpm/lib0@0.2.80/node_modules/lib0/symbol.js\nvar create6 = Symbol;\n\n// ../../node_modules/.pnpm/lib0@0.2.80/node_modules/lib0/logging.common.js\nvar BOLD = create6();\nvar UNBOLD = create6();\nvar BLUE = create6();\nvar GREY = create6();\nvar GREEN = create6();\nvar RED = create6();\nvar PURPLE = create6();\nvar ORANGE = create6();\nvar UNCOLOR = create6();\nvar computeNoColorLoggingArgs = (args2) => {\n  const strBuilder = [];\n  const logArgs = [];\n  let i = 0;\n  for (; i < args2.length; i++) {\n    const arg = args2[i];\n    if (arg.constructor === String || arg.constructor === Number) {\n      strBuilder.push(arg);\n    } else if (arg.constructor === Object) {\n      logArgs.push(JSON.stringify(arg));\n    }\n  }\n  return logArgs;\n};\nvar lastLoggingTime = getUnixTime();\n\n// ../../node_modules/.pnpm/lib0@0.2.80/node_modules/lib0/logging.js\nvar _browserStyleMap = {\n  [BOLD]: create5(\"font-weight\", \"bold\"),\n  [UNBOLD]: create5(\"font-weight\", \"normal\"),\n  [BLUE]: create5(\"color\", \"blue\"),\n  [GREEN]: create5(\"color\", \"green\"),\n  [GREY]: create5(\"color\", \"grey\"),\n  [RED]: create5(\"color\", \"red\"),\n  [PURPLE]: create5(\"color\", \"purple\"),\n  [ORANGE]: create5(\"color\", \"orange\"),\n  // not well supported in chrome when debugging node with inspector - TODO: deprecate\n  [UNCOLOR]: create5(\"color\", \"black\")\n};\nvar computeBrowserLoggingArgs = (args2) => {\n  const strBuilder = [];\n  const styles = [];\n  const currentStyle = create();\n  let logArgs = [];\n  let i = 0;\n  for (; i < args2.length; i++) {\n    const arg = args2[i];\n    const style = _browserStyleMap[arg];\n    if (style !== void 0) {\n      currentStyle.set(style.left, style.right);\n    } else {\n      if (arg.constructor === String || arg.constructor === Number) {\n        const style2 = mapToStyleString(currentStyle);\n        if (i > 0 || style2.length > 0) {\n          strBuilder.push(\"%c\" + arg);\n          styles.push(style2);\n        } else {\n          strBuilder.push(arg);\n        }\n      } else {\n        break;\n      }\n    }\n  }\n  if (i > 0) {\n    logArgs = styles;\n    logArgs.unshift(strBuilder.join(\"\"));\n  }\n  for (; i < args2.length; i++) {\n    const arg = args2[i];\n    if (!(arg instanceof Symbol)) {\n      logArgs.push(arg);\n    }\n  }\n  return logArgs;\n};\nvar computeLoggingArgs = supportsColor ? computeBrowserLoggingArgs : computeNoColorLoggingArgs;\nvar print = (...args2) => {\n  console.log(...computeLoggingArgs(args2));\n  vconsoles.forEach((vc) => vc.print(args2));\n};\nvar vconsoles = create2();\n\n// ../../node_modules/.pnpm/lib0@0.2.80/node_modules/lib0/iterator.js\nvar createIterator = (next) => ({\n  /**\n   * @return {IterableIterator<T>}\n   */\n  [Symbol.iterator]() {\n    return this;\n  },\n  // @ts-ignore\n  next\n});\nvar iteratorFilter = (iterator, filter) => createIterator(() => {\n  let res;\n  do {\n    res = iterator.next();\n  } while (!res.done && !filter(res.value));\n  return res;\n});\nvar iteratorMap = (iterator, fmap) => createIterator(() => {\n  const { done, value } = iterator.next();\n  return { done, value: done ? void 0 : fmap(value) };\n});\n\n// ../../node_modules/.pnpm/yjs@13.6.7/node_modules/yjs/dist/yjs.mjs\nvar AbstractConnector = class extends Observable {\n  /**\n   * @param {Doc} ydoc\n   * @param {any} awareness\n   */\n  constructor(ydoc, awareness) {\n    super();\n    this.doc = ydoc;\n    this.awareness = awareness;\n  }\n};\nvar DeleteItem = class {\n  /**\n   * @param {number} clock\n   * @param {number} len\n   */\n  constructor(clock, len) {\n    this.clock = clock;\n    this.len = len;\n  }\n};\nvar DeleteSet = class {\n  constructor() {\n    this.clients = /* @__PURE__ */ new Map();\n  }\n};\nvar iterateDeletedStructs = (transaction, ds, f) => ds.clients.forEach((deletes, clientid) => {\n  const structs = (\n    /** @type {Array<GC|Item>} */\n    transaction.doc.store.clients.get(clientid)\n  );\n  for (let i = 0; i < deletes.length; i++) {\n    const del = deletes[i];\n    iterateStructs(transaction, structs, del.clock, del.len, f);\n  }\n});\nvar findIndexDS = (dis, clock) => {\n  let left = 0;\n  let right = dis.length - 1;\n  while (left <= right) {\n    const midindex = floor((left + right) / 2);\n    const mid = dis[midindex];\n    const midclock = mid.clock;\n    if (midclock <= clock) {\n      if (clock < midclock + mid.len) {\n        return midindex;\n      }\n      left = midindex + 1;\n    } else {\n      right = midindex - 1;\n    }\n  }\n  return null;\n};\nvar isDeleted = (ds, id2) => {\n  const dis = ds.clients.get(id2.client);\n  return dis !== void 0 && findIndexDS(dis, id2.clock) !== null;\n};\nvar sortAndMergeDeleteSet = (ds) => {\n  ds.clients.forEach((dels) => {\n    dels.sort((a, b) => a.clock - b.clock);\n    let i, j;\n    for (i = 1, j = 1; i < dels.length; i++) {\n      const left = dels[j - 1];\n      const right = dels[i];\n      if (left.clock + left.len >= right.clock) {\n        left.len = max(left.len, right.clock + right.len - left.clock);\n      } else {\n        if (j < i) {\n          dels[j] = right;\n        }\n        j++;\n      }\n    }\n    dels.length = j;\n  });\n};\nvar mergeDeleteSets = (dss) => {\n  const merged = new DeleteSet();\n  for (let dssI = 0; dssI < dss.length; dssI++) {\n    dss[dssI].clients.forEach((delsLeft, client) => {\n      if (!merged.clients.has(client)) {\n        const dels = delsLeft.slice();\n        for (let i = dssI + 1; i < dss.length; i++) {\n          appendTo(dels, dss[i].clients.get(client) || []);\n        }\n        merged.clients.set(client, dels);\n      }\n    });\n  }\n  sortAndMergeDeleteSet(merged);\n  return merged;\n};\nvar addToDeleteSet = (ds, client, clock, length3) => {\n  setIfUndefined(ds.clients, client, () => (\n    /** @type {Array<DeleteItem>} */\n    []\n  )).push(new DeleteItem(clock, length3));\n};\nvar createDeleteSet = () => new DeleteSet();\nvar createDeleteSetFromStructStore = (ss) => {\n  const ds = createDeleteSet();\n  ss.clients.forEach((structs, client) => {\n    const dsitems = [];\n    for (let i = 0; i < structs.length; i++) {\n      const struct = structs[i];\n      if (struct.deleted) {\n        const clock = struct.id.clock;\n        let len = struct.length;\n        if (i + 1 < structs.length) {\n          for (let next = structs[i + 1]; i + 1 < structs.length && next.deleted; next = structs[++i + 1]) {\n            len += next.length;\n          }\n        }\n        dsitems.push(new DeleteItem(clock, len));\n      }\n    }\n    if (dsitems.length > 0) {\n      ds.clients.set(client, dsitems);\n    }\n  });\n  return ds;\n};\nvar writeDeleteSet = (encoder, ds) => {\n  writeVarUint(encoder.restEncoder, ds.clients.size);\n  from2(ds.clients.entries()).sort((a, b) => b[0] - a[0]).forEach(([client, dsitems]) => {\n    encoder.resetDsCurVal();\n    writeVarUint(encoder.restEncoder, client);\n    const len = dsitems.length;\n    writeVarUint(encoder.restEncoder, len);\n    for (let i = 0; i < len; i++) {\n      const item = dsitems[i];\n      encoder.writeDsClock(item.clock);\n      encoder.writeDsLen(item.len);\n    }\n  });\n};\nvar readDeleteSet = (decoder) => {\n  const ds = new DeleteSet();\n  const numClients = readVarUint(decoder.restDecoder);\n  for (let i = 0; i < numClients; i++) {\n    decoder.resetDsCurVal();\n    const client = readVarUint(decoder.restDecoder);\n    const numberOfDeletes = readVarUint(decoder.restDecoder);\n    if (numberOfDeletes > 0) {\n      const dsField = setIfUndefined(ds.clients, client, () => (\n        /** @type {Array<DeleteItem>} */\n        []\n      ));\n      for (let i2 = 0; i2 < numberOfDeletes; i2++) {\n        dsField.push(new DeleteItem(decoder.readDsClock(), decoder.readDsLen()));\n      }\n    }\n  }\n  return ds;\n};\nvar readAndApplyDeleteSet = (decoder, transaction, store) => {\n  const unappliedDS = new DeleteSet();\n  const numClients = readVarUint(decoder.restDecoder);\n  for (let i = 0; i < numClients; i++) {\n    decoder.resetDsCurVal();\n    const client = readVarUint(decoder.restDecoder);\n    const numberOfDeletes = readVarUint(decoder.restDecoder);\n    const structs = store.clients.get(client) || [];\n    const state = getState(store, client);\n    for (let i2 = 0; i2 < numberOfDeletes; i2++) {\n      const clock = decoder.readDsClock();\n      const clockEnd = clock + decoder.readDsLen();\n      if (clock < state) {\n        if (state < clockEnd) {\n          addToDeleteSet(unappliedDS, client, state, clockEnd - state);\n        }\n        let index = findIndexSS(structs, clock);\n        let struct = structs[index];\n        if (!struct.deleted && struct.id.clock < clock) {\n          structs.splice(index + 1, 0, splitItem(transaction, struct, clock - struct.id.clock));\n          index++;\n        }\n        while (index < structs.length) {\n          struct = structs[index++];\n          if (struct.id.clock < clockEnd) {\n            if (!struct.deleted) {\n              if (clockEnd < struct.id.clock + struct.length) {\n                structs.splice(index, 0, splitItem(transaction, struct, clockEnd - struct.id.clock));\n              }\n              struct.delete(transaction);\n            }\n          } else {\n            break;\n          }\n        }\n      } else {\n        addToDeleteSet(unappliedDS, client, clock, clockEnd - clock);\n      }\n    }\n  }\n  if (unappliedDS.clients.size > 0) {\n    const ds = new UpdateEncoderV2();\n    writeVarUint(ds.restEncoder, 0);\n    writeDeleteSet(ds, unappliedDS);\n    return ds.toUint8Array();\n  }\n  return null;\n};\nvar equalDeleteSets = (ds1, ds2) => {\n  if (ds1.clients.size !== ds2.clients.size)\n    return false;\n  for (const [client, deleteItems1] of ds1.clients.entries()) {\n    const deleteItems2 = (\n      /** @type {Array<import('../internals.js').DeleteItem>} */\n      ds2.clients.get(client)\n    );\n    if (deleteItems2 === void 0 || deleteItems1.length !== deleteItems2.length)\n      return false;\n    for (let i = 0; i < deleteItems1.length; i++) {\n      const di1 = deleteItems1[i];\n      const di2 = deleteItems2[i];\n      if (di1.clock !== di2.clock || di1.len !== di2.len) {\n        return false;\n      }\n    }\n  }\n  return true;\n};\nvar generateNewClientId = uint32;\nvar Doc = class _Doc extends Observable {\n  /**\n   * @param {DocOpts} opts configuration\n   */\n  constructor({ guid = uuidv4(), collectionid = null, gc = true, gcFilter = () => true, meta = null, autoLoad = false, shouldLoad = true } = {}) {\n    super();\n    this.gc = gc;\n    this.gcFilter = gcFilter;\n    this.clientID = generateNewClientId();\n    this.guid = guid;\n    this.collectionid = collectionid;\n    this.share = /* @__PURE__ */ new Map();\n    this.store = new StructStore();\n    this._transaction = null;\n    this._transactionCleanups = [];\n    this.subdocs = /* @__PURE__ */ new Set();\n    this._item = null;\n    this.shouldLoad = shouldLoad;\n    this.autoLoad = autoLoad;\n    this.meta = meta;\n    this.isLoaded = false;\n    this.isSynced = false;\n    this.whenLoaded = create4((resolve) => {\n      this.on(\"load\", () => {\n        this.isLoaded = true;\n        resolve(this);\n      });\n    });\n    const provideSyncedPromise = () => create4((resolve) => {\n      const eventHandler = (isSynced) => {\n        if (isSynced === void 0 || isSynced === true) {\n          this.off(\"sync\", eventHandler);\n          resolve();\n        }\n      };\n      this.on(\"sync\", eventHandler);\n    });\n    this.on(\"sync\", (isSynced) => {\n      if (isSynced === false && this.isSynced) {\n        this.whenSynced = provideSyncedPromise();\n      }\n      this.isSynced = isSynced === void 0 || isSynced === true;\n      if (!this.isLoaded) {\n        this.emit(\"load\", []);\n      }\n    });\n    this.whenSynced = provideSyncedPromise();\n  }\n  /**\n   * Notify the parent document that you request to load data into this subdocument (if it is a subdocument).\n   *\n   * `load()` might be used in the future to request any provider to load the most current data.\n   *\n   * It is safe to call `load()` multiple times.\n   */\n  load() {\n    const item = this._item;\n    if (item !== null && !this.shouldLoad) {\n      transact(\n        /** @type {any} */\n        item.parent.doc,\n        (transaction) => {\n          transaction.subdocsLoaded.add(this);\n        },\n        null,\n        true\n      );\n    }\n    this.shouldLoad = true;\n  }\n  getSubdocs() {\n    return this.subdocs;\n  }\n  getSubdocGuids() {\n    return new Set(from2(this.subdocs).map((doc2) => doc2.guid));\n  }\n  /**\n   * Changes that happen inside of a transaction are bundled. This means that\n   * the observer fires _after_ the transaction is finished and that all changes\n   * that happened inside of the transaction are sent as one message to the\n   * other peers.\n   *\n   * @template T\n   * @param {function(Transaction):T} f The function that should be executed as a transaction\n   * @param {any} [origin] Origin of who started the transaction. Will be stored on transaction.origin\n   * @return T\n   *\n   * @public\n   */\n  transact(f, origin = null) {\n    return transact(this, f, origin);\n  }\n  /**\n   * Define a shared data type.\n   *\n   * Multiple calls of `y.get(name, TypeConstructor)` yield the same result\n   * and do not overwrite each other. I.e.\n   * `y.define(name, Y.Array) === y.define(name, Y.Array)`\n   *\n   * After this method is called, the type is also available on `y.share.get(name)`.\n   *\n   * *Best Practices:*\n   * Define all types right after the Yjs instance is created and store them in a separate object.\n   * Also use the typed methods `getText(name)`, `getArray(name)`, ..\n   *\n   * @example\n   *   const y = new Y(..)\n   *   const appState = {\n   *     document: y.getText('document')\n   *     comments: y.getArray('comments')\n   *   }\n   *\n   * @param {string} name\n   * @param {Function} TypeConstructor The constructor of the type definition. E.g. Y.Text, Y.Array, Y.Map, ...\n   * @return {AbstractType<any>} The created type. Constructed with TypeConstructor\n   *\n   * @public\n   */\n  get(name, TypeConstructor = AbstractType) {\n    const type = setIfUndefined(this.share, name, () => {\n      const t = new TypeConstructor();\n      t._integrate(this, null);\n      return t;\n    });\n    const Constr = type.constructor;\n    if (TypeConstructor !== AbstractType && Constr !== TypeConstructor) {\n      if (Constr === AbstractType) {\n        const t = new TypeConstructor();\n        t._map = type._map;\n        type._map.forEach(\n          /** @param {Item?} n */\n          (n) => {\n            for (; n !== null; n = n.left) {\n              n.parent = t;\n            }\n          }\n        );\n        t._start = type._start;\n        for (let n = t._start; n !== null; n = n.right) {\n          n.parent = t;\n        }\n        t._length = type._length;\n        this.share.set(name, t);\n        t._integrate(this, null);\n        return t;\n      } else {\n        throw new Error(`Type with the name ${name} has already been defined with a different constructor`);\n      }\n    }\n    return type;\n  }\n  /**\n   * @template T\n   * @param {string} [name]\n   * @return {YArray<T>}\n   *\n   * @public\n   */\n  getArray(name = \"\") {\n    return this.get(name, YArray);\n  }\n  /**\n   * @param {string} [name]\n   * @return {YText}\n   *\n   * @public\n   */\n  getText(name = \"\") {\n    return this.get(name, YText);\n  }\n  /**\n   * @template T\n   * @param {string} [name]\n   * @return {YMap<T>}\n   *\n   * @public\n   */\n  getMap(name = \"\") {\n    return this.get(name, YMap);\n  }\n  /**\n   * @param {string} [name]\n   * @return {YXmlFragment}\n   *\n   * @public\n   */\n  getXmlFragment(name = \"\") {\n    return this.get(name, YXmlFragment);\n  }\n  /**\n   * Converts the entire document into a js object, recursively traversing each yjs type\n   * Doesn't log types that have not been defined (using ydoc.getType(..)).\n   *\n   * @deprecated Do not use this method and rather call toJSON directly on the shared types.\n   *\n   * @return {Object<string, any>}\n   */\n  toJSON() {\n    const doc2 = {};\n    this.share.forEach((value, key) => {\n      doc2[key] = value.toJSON();\n    });\n    return doc2;\n  }\n  /**\n   * Emit `destroy` event and unregister all event handlers.\n   */\n  destroy() {\n    from2(this.subdocs).forEach((subdoc) => subdoc.destroy());\n    const item = this._item;\n    if (item !== null) {\n      this._item = null;\n      const content = (\n        /** @type {ContentDoc} */\n        item.content\n      );\n      content.doc = new _Doc({ guid: this.guid, ...content.opts, shouldLoad: false });\n      content.doc._item = item;\n      transact(\n        /** @type {any} */\n        item.parent.doc,\n        (transaction) => {\n          const doc2 = content.doc;\n          if (!item.deleted) {\n            transaction.subdocsAdded.add(doc2);\n          }\n          transaction.subdocsRemoved.add(this);\n        },\n        null,\n        true\n      );\n    }\n    this.emit(\"destroyed\", [true]);\n    this.emit(\"destroy\", [this]);\n    super.destroy();\n  }\n  /**\n   * @param {string} eventName\n   * @param {function(...any):any} f\n   */\n  on(eventName, f) {\n    super.on(eventName, f);\n  }\n  /**\n   * @param {string} eventName\n   * @param {function} f\n   */\n  off(eventName, f) {\n    super.off(eventName, f);\n  }\n};\nvar DSDecoderV1 = class {\n  /**\n   * @param {decoding.Decoder} decoder\n   */\n  constructor(decoder) {\n    this.restDecoder = decoder;\n  }\n  resetDsCurVal() {\n  }\n  /**\n   * @return {number}\n   */\n  readDsClock() {\n    return readVarUint(this.restDecoder);\n  }\n  /**\n   * @return {number}\n   */\n  readDsLen() {\n    return readVarUint(this.restDecoder);\n  }\n};\nvar UpdateDecoderV1 = class extends DSDecoderV1 {\n  /**\n   * @return {ID}\n   */\n  readLeftID() {\n    return createID(readVarUint(this.restDecoder), readVarUint(this.restDecoder));\n  }\n  /**\n   * @return {ID}\n   */\n  readRightID() {\n    return createID(readVarUint(this.restDecoder), readVarUint(this.restDecoder));\n  }\n  /**\n   * Read the next client id.\n   * Use this in favor of readID whenever possible to reduce the number of objects created.\n   */\n  readClient() {\n    return readVarUint(this.restDecoder);\n  }\n  /**\n   * @return {number} info An unsigned 8-bit integer\n   */\n  readInfo() {\n    return readUint8(this.restDecoder);\n  }\n  /**\n   * @return {string}\n   */\n  readString() {\n    return readVarString(this.restDecoder);\n  }\n  /**\n   * @return {boolean} isKey\n   */\n  readParentInfo() {\n    return readVarUint(this.restDecoder) === 1;\n  }\n  /**\n   * @return {number} info An unsigned 8-bit integer\n   */\n  readTypeRef() {\n    return readVarUint(this.restDecoder);\n  }\n  /**\n   * Write len of a struct - well suited for Opt RLE encoder.\n   *\n   * @return {number} len\n   */\n  readLen() {\n    return readVarUint(this.restDecoder);\n  }\n  /**\n   * @return {any}\n   */\n  readAny() {\n    return readAny(this.restDecoder);\n  }\n  /**\n   * @return {Uint8Array}\n   */\n  readBuf() {\n    return copyUint8Array(readVarUint8Array(this.restDecoder));\n  }\n  /**\n   * Legacy implementation uses JSON parse. We use any-decoding in v2.\n   *\n   * @return {any}\n   */\n  readJSON() {\n    return JSON.parse(readVarString(this.restDecoder));\n  }\n  /**\n   * @return {string}\n   */\n  readKey() {\n    return readVarString(this.restDecoder);\n  }\n};\nvar DSDecoderV2 = class {\n  /**\n   * @param {decoding.Decoder} decoder\n   */\n  constructor(decoder) {\n    this.dsCurrVal = 0;\n    this.restDecoder = decoder;\n  }\n  resetDsCurVal() {\n    this.dsCurrVal = 0;\n  }\n  /**\n   * @return {number}\n   */\n  readDsClock() {\n    this.dsCurrVal += readVarUint(this.restDecoder);\n    return this.dsCurrVal;\n  }\n  /**\n   * @return {number}\n   */\n  readDsLen() {\n    const diff = readVarUint(this.restDecoder) + 1;\n    this.dsCurrVal += diff;\n    return diff;\n  }\n};\nvar UpdateDecoderV2 = class extends DSDecoderV2 {\n  /**\n   * @param {decoding.Decoder} decoder\n   */\n  constructor(decoder) {\n    super(decoder);\n    this.keys = [];\n    readVarUint(decoder);\n    this.keyClockDecoder = new IntDiffOptRleDecoder(readVarUint8Array(decoder));\n    this.clientDecoder = new UintOptRleDecoder(readVarUint8Array(decoder));\n    this.leftClockDecoder = new IntDiffOptRleDecoder(readVarUint8Array(decoder));\n    this.rightClockDecoder = new IntDiffOptRleDecoder(readVarUint8Array(decoder));\n    this.infoDecoder = new RleDecoder(readVarUint8Array(decoder), readUint8);\n    this.stringDecoder = new StringDecoder(readVarUint8Array(decoder));\n    this.parentInfoDecoder = new RleDecoder(readVarUint8Array(decoder), readUint8);\n    this.typeRefDecoder = new UintOptRleDecoder(readVarUint8Array(decoder));\n    this.lenDecoder = new UintOptRleDecoder(readVarUint8Array(decoder));\n  }\n  /**\n   * @return {ID}\n   */\n  readLeftID() {\n    return new ID(this.clientDecoder.read(), this.leftClockDecoder.read());\n  }\n  /**\n   * @return {ID}\n   */\n  readRightID() {\n    return new ID(this.clientDecoder.read(), this.rightClockDecoder.read());\n  }\n  /**\n   * Read the next client id.\n   * Use this in favor of readID whenever possible to reduce the number of objects created.\n   */\n  readClient() {\n    return this.clientDecoder.read();\n  }\n  /**\n   * @return {number} info An unsigned 8-bit integer\n   */\n  readInfo() {\n    return (\n      /** @type {number} */\n      this.infoDecoder.read()\n    );\n  }\n  /**\n   * @return {string}\n   */\n  readString() {\n    return this.stringDecoder.read();\n  }\n  /**\n   * @return {boolean}\n   */\n  readParentInfo() {\n    return this.parentInfoDecoder.read() === 1;\n  }\n  /**\n   * @return {number} An unsigned 8-bit integer\n   */\n  readTypeRef() {\n    return this.typeRefDecoder.read();\n  }\n  /**\n   * Write len of a struct - well suited for Opt RLE encoder.\n   *\n   * @return {number}\n   */\n  readLen() {\n    return this.lenDecoder.read();\n  }\n  /**\n   * @return {any}\n   */\n  readAny() {\n    return readAny(this.restDecoder);\n  }\n  /**\n   * @return {Uint8Array}\n   */\n  readBuf() {\n    return readVarUint8Array(this.restDecoder);\n  }\n  /**\n   * This is mainly here for legacy purposes.\n   *\n   * Initial we incoded objects using JSON. Now we use the much faster lib0/any-encoder. This method mainly exists for legacy purposes for the v1 encoder.\n   *\n   * @return {any}\n   */\n  readJSON() {\n    return readAny(this.restDecoder);\n  }\n  /**\n   * @return {string}\n   */\n  readKey() {\n    const keyClock = this.keyClockDecoder.read();\n    if (keyClock < this.keys.length) {\n      return this.keys[keyClock];\n    } else {\n      const key = this.stringDecoder.read();\n      this.keys.push(key);\n      return key;\n    }\n  }\n};\nvar DSEncoderV1 = class {\n  constructor() {\n    this.restEncoder = createEncoder();\n  }\n  toUint8Array() {\n    return toUint8Array(this.restEncoder);\n  }\n  resetDsCurVal() {\n  }\n  /**\n   * @param {number} clock\n   */\n  writeDsClock(clock) {\n    writeVarUint(this.restEncoder, clock);\n  }\n  /**\n   * @param {number} len\n   */\n  writeDsLen(len) {\n    writeVarUint(this.restEncoder, len);\n  }\n};\nvar UpdateEncoderV1 = class extends DSEncoderV1 {\n  /**\n   * @param {ID} id\n   */\n  writeLeftID(id2) {\n    writeVarUint(this.restEncoder, id2.client);\n    writeVarUint(this.restEncoder, id2.clock);\n  }\n  /**\n   * @param {ID} id\n   */\n  writeRightID(id2) {\n    writeVarUint(this.restEncoder, id2.client);\n    writeVarUint(this.restEncoder, id2.clock);\n  }\n  /**\n   * Use writeClient and writeClock instead of writeID if possible.\n   * @param {number} client\n   */\n  writeClient(client) {\n    writeVarUint(this.restEncoder, client);\n  }\n  /**\n   * @param {number} info An unsigned 8-bit integer\n   */\n  writeInfo(info) {\n    writeUint8(this.restEncoder, info);\n  }\n  /**\n   * @param {string} s\n   */\n  writeString(s) {\n    writeVarString(this.restEncoder, s);\n  }\n  /**\n   * @param {boolean} isYKey\n   */\n  writeParentInfo(isYKey) {\n    writeVarUint(this.restEncoder, isYKey ? 1 : 0);\n  }\n  /**\n   * @param {number} info An unsigned 8-bit integer\n   */\n  writeTypeRef(info) {\n    writeVarUint(this.restEncoder, info);\n  }\n  /**\n   * Write len of a struct - well suited for Opt RLE encoder.\n   *\n   * @param {number} len\n   */\n  writeLen(len) {\n    writeVarUint(this.restEncoder, len);\n  }\n  /**\n   * @param {any} any\n   */\n  writeAny(any2) {\n    writeAny(this.restEncoder, any2);\n  }\n  /**\n   * @param {Uint8Array} buf\n   */\n  writeBuf(buf) {\n    writeVarUint8Array(this.restEncoder, buf);\n  }\n  /**\n   * @param {any} embed\n   */\n  writeJSON(embed) {\n    writeVarString(this.restEncoder, JSON.stringify(embed));\n  }\n  /**\n   * @param {string} key\n   */\n  writeKey(key) {\n    writeVarString(this.restEncoder, key);\n  }\n};\nvar DSEncoderV2 = class {\n  constructor() {\n    this.restEncoder = createEncoder();\n    this.dsCurrVal = 0;\n  }\n  toUint8Array() {\n    return toUint8Array(this.restEncoder);\n  }\n  resetDsCurVal() {\n    this.dsCurrVal = 0;\n  }\n  /**\n   * @param {number} clock\n   */\n  writeDsClock(clock) {\n    const diff = clock - this.dsCurrVal;\n    this.dsCurrVal = clock;\n    writeVarUint(this.restEncoder, diff);\n  }\n  /**\n   * @param {number} len\n   */\n  writeDsLen(len) {\n    if (len === 0) {\n      unexpectedCase();\n    }\n    writeVarUint(this.restEncoder, len - 1);\n    this.dsCurrVal += len;\n  }\n};\nvar UpdateEncoderV2 = class extends DSEncoderV2 {\n  constructor() {\n    super();\n    this.keyMap = /* @__PURE__ */ new Map();\n    this.keyClock = 0;\n    this.keyClockEncoder = new IntDiffOptRleEncoder();\n    this.clientEncoder = new UintOptRleEncoder();\n    this.leftClockEncoder = new IntDiffOptRleEncoder();\n    this.rightClockEncoder = new IntDiffOptRleEncoder();\n    this.infoEncoder = new RleEncoder(writeUint8);\n    this.stringEncoder = new StringEncoder();\n    this.parentInfoEncoder = new RleEncoder(writeUint8);\n    this.typeRefEncoder = new UintOptRleEncoder();\n    this.lenEncoder = new UintOptRleEncoder();\n  }\n  toUint8Array() {\n    const encoder = createEncoder();\n    writeVarUint(encoder, 0);\n    writeVarUint8Array(encoder, this.keyClockEncoder.toUint8Array());\n    writeVarUint8Array(encoder, this.clientEncoder.toUint8Array());\n    writeVarUint8Array(encoder, this.leftClockEncoder.toUint8Array());\n    writeVarUint8Array(encoder, this.rightClockEncoder.toUint8Array());\n    writeVarUint8Array(encoder, toUint8Array(this.infoEncoder));\n    writeVarUint8Array(encoder, this.stringEncoder.toUint8Array());\n    writeVarUint8Array(encoder, toUint8Array(this.parentInfoEncoder));\n    writeVarUint8Array(encoder, this.typeRefEncoder.toUint8Array());\n    writeVarUint8Array(encoder, this.lenEncoder.toUint8Array());\n    writeUint8Array(encoder, toUint8Array(this.restEncoder));\n    return toUint8Array(encoder);\n  }\n  /**\n   * @param {ID} id\n   */\n  writeLeftID(id2) {\n    this.clientEncoder.write(id2.client);\n    this.leftClockEncoder.write(id2.clock);\n  }\n  /**\n   * @param {ID} id\n   */\n  writeRightID(id2) {\n    this.clientEncoder.write(id2.client);\n    this.rightClockEncoder.write(id2.clock);\n  }\n  /**\n   * @param {number} client\n   */\n  writeClient(client) {\n    this.clientEncoder.write(client);\n  }\n  /**\n   * @param {number} info An unsigned 8-bit integer\n   */\n  writeInfo(info) {\n    this.infoEncoder.write(info);\n  }\n  /**\n   * @param {string} s\n   */\n  writeString(s) {\n    this.stringEncoder.write(s);\n  }\n  /**\n   * @param {boolean} isYKey\n   */\n  writeParentInfo(isYKey) {\n    this.parentInfoEncoder.write(isYKey ? 1 : 0);\n  }\n  /**\n   * @param {number} info An unsigned 8-bit integer\n   */\n  writeTypeRef(info) {\n    this.typeRefEncoder.write(info);\n  }\n  /**\n   * Write len of a struct - well suited for Opt RLE encoder.\n   *\n   * @param {number} len\n   */\n  writeLen(len) {\n    this.lenEncoder.write(len);\n  }\n  /**\n   * @param {any} any\n   */\n  writeAny(any2) {\n    writeAny(this.restEncoder, any2);\n  }\n  /**\n   * @param {Uint8Array} buf\n   */\n  writeBuf(buf) {\n    writeVarUint8Array(this.restEncoder, buf);\n  }\n  /**\n   * This is mainly here for legacy purposes.\n   *\n   * Initial we incoded objects using JSON. Now we use the much faster lib0/any-encoder. This method mainly exists for legacy purposes for the v1 encoder.\n   *\n   * @param {any} embed\n   */\n  writeJSON(embed) {\n    writeAny(this.restEncoder, embed);\n  }\n  /**\n   * Property keys are often reused. For example, in y-prosemirror the key `bold` might\n   * occur very often. For a 3d application, the key `position` might occur very often.\n   *\n   * We cache these keys in a Map and refer to them via a unique number.\n   *\n   * @param {string} key\n   */\n  writeKey(key) {\n    const clock = this.keyMap.get(key);\n    if (clock === void 0) {\n      this.keyClockEncoder.write(this.keyClock++);\n      this.stringEncoder.write(key);\n    } else {\n      this.keyClockEncoder.write(clock);\n    }\n  }\n};\nvar writeStructs = (encoder, structs, client, clock) => {\n  clock = max(clock, structs[0].id.clock);\n  const startNewStructs = findIndexSS(structs, clock);\n  writeVarUint(encoder.restEncoder, structs.length - startNewStructs);\n  encoder.writeClient(client);\n  writeVarUint(encoder.restEncoder, clock);\n  const firstStruct = structs[startNewStructs];\n  firstStruct.write(encoder, clock - firstStruct.id.clock);\n  for (let i = startNewStructs + 1; i < structs.length; i++) {\n    structs[i].write(encoder, 0);\n  }\n};\nvar writeClientsStructs = (encoder, store, _sm) => {\n  const sm = /* @__PURE__ */ new Map();\n  _sm.forEach((clock, client) => {\n    if (getState(store, client) > clock) {\n      sm.set(client, clock);\n    }\n  });\n  getStateVector(store).forEach((_clock, client) => {\n    if (!_sm.has(client)) {\n      sm.set(client, 0);\n    }\n  });\n  writeVarUint(encoder.restEncoder, sm.size);\n  from2(sm.entries()).sort((a, b) => b[0] - a[0]).forEach(([client, clock]) => {\n    writeStructs(\n      encoder,\n      /** @type {Array<GC|Item>} */\n      store.clients.get(client),\n      client,\n      clock\n    );\n  });\n};\nvar readClientsStructRefs = (decoder, doc2) => {\n  const clientRefs = create();\n  const numOfStateUpdates = readVarUint(decoder.restDecoder);\n  for (let i = 0; i < numOfStateUpdates; i++) {\n    const numberOfStructs = readVarUint(decoder.restDecoder);\n    const refs = new Array(numberOfStructs);\n    const client = decoder.readClient();\n    let clock = readVarUint(decoder.restDecoder);\n    clientRefs.set(client, { i: 0, refs });\n    for (let i2 = 0; i2 < numberOfStructs; i2++) {\n      const info = decoder.readInfo();\n      switch (BITS5 & info) {\n        case 0: {\n          const len = decoder.readLen();\n          refs[i2] = new GC(createID(client, clock), len);\n          clock += len;\n          break;\n        }\n        case 10: {\n          const len = readVarUint(decoder.restDecoder);\n          refs[i2] = new Skip(createID(client, clock), len);\n          clock += len;\n          break;\n        }\n        default: {\n          const cantCopyParentInfo = (info & (BIT7 | BIT8)) === 0;\n          const struct = new Item(\n            createID(client, clock),\n            null,\n            // leftd\n            (info & BIT8) === BIT8 ? decoder.readLeftID() : null,\n            // origin\n            null,\n            // right\n            (info & BIT7) === BIT7 ? decoder.readRightID() : null,\n            // right origin\n            cantCopyParentInfo ? decoder.readParentInfo() ? doc2.get(decoder.readString()) : decoder.readLeftID() : null,\n            // parent\n            cantCopyParentInfo && (info & BIT6) === BIT6 ? decoder.readString() : null,\n            // parentSub\n            readItemContent(decoder, info)\n            // item content\n          );\n          refs[i2] = struct;\n          clock += struct.length;\n        }\n      }\n    }\n  }\n  return clientRefs;\n};\nvar integrateStructs = (transaction, store, clientsStructRefs) => {\n  const stack = [];\n  let clientsStructRefsIds = from2(clientsStructRefs.keys()).sort((a, b) => a - b);\n  if (clientsStructRefsIds.length === 0) {\n    return null;\n  }\n  const getNextStructTarget = () => {\n    if (clientsStructRefsIds.length === 0) {\n      return null;\n    }\n    let nextStructsTarget = (\n      /** @type {{i:number,refs:Array<GC|Item>}} */\n      clientsStructRefs.get(clientsStructRefsIds[clientsStructRefsIds.length - 1])\n    );\n    while (nextStructsTarget.refs.length === nextStructsTarget.i) {\n      clientsStructRefsIds.pop();\n      if (clientsStructRefsIds.length > 0) {\n        nextStructsTarget = /** @type {{i:number,refs:Array<GC|Item>}} */\n        clientsStructRefs.get(clientsStructRefsIds[clientsStructRefsIds.length - 1]);\n      } else {\n        return null;\n      }\n    }\n    return nextStructsTarget;\n  };\n  let curStructsTarget = getNextStructTarget();\n  if (curStructsTarget === null && stack.length === 0) {\n    return null;\n  }\n  const restStructs = new StructStore();\n  const missingSV = /* @__PURE__ */ new Map();\n  const updateMissingSv = (client, clock) => {\n    const mclock = missingSV.get(client);\n    if (mclock == null || mclock > clock) {\n      missingSV.set(client, clock);\n    }\n  };\n  let stackHead = (\n    /** @type {any} */\n    curStructsTarget.refs[\n      /** @type {any} */\n      curStructsTarget.i++\n    ]\n  );\n  const state = /* @__PURE__ */ new Map();\n  const addStackToRestSS = () => {\n    for (const item of stack) {\n      const client = item.id.client;\n      const unapplicableItems = clientsStructRefs.get(client);\n      if (unapplicableItems) {\n        unapplicableItems.i--;\n        restStructs.clients.set(client, unapplicableItems.refs.slice(unapplicableItems.i));\n        clientsStructRefs.delete(client);\n        unapplicableItems.i = 0;\n        unapplicableItems.refs = [];\n      } else {\n        restStructs.clients.set(client, [item]);\n      }\n      clientsStructRefsIds = clientsStructRefsIds.filter((c) => c !== client);\n    }\n    stack.length = 0;\n  };\n  while (true) {\n    if (stackHead.constructor !== Skip) {\n      const localClock = setIfUndefined(state, stackHead.id.client, () => getState(store, stackHead.id.client));\n      const offset = localClock - stackHead.id.clock;\n      if (offset < 0) {\n        stack.push(stackHead);\n        updateMissingSv(stackHead.id.client, stackHead.id.clock - 1);\n        addStackToRestSS();\n      } else {\n        const missing = stackHead.getMissing(transaction, store);\n        if (missing !== null) {\n          stack.push(stackHead);\n          const structRefs = clientsStructRefs.get(\n            /** @type {number} */\n            missing\n          ) || { refs: [], i: 0 };\n          if (structRefs.refs.length === structRefs.i) {\n            updateMissingSv(\n              /** @type {number} */\n              missing,\n              getState(store, missing)\n            );\n            addStackToRestSS();\n          } else {\n            stackHead = structRefs.refs[structRefs.i++];\n            continue;\n          }\n        } else if (offset === 0 || offset < stackHead.length) {\n          stackHead.integrate(transaction, offset);\n          state.set(stackHead.id.client, stackHead.id.clock + stackHead.length);\n        }\n      }\n    }\n    if (stack.length > 0) {\n      stackHead = /** @type {GC|Item} */\n      stack.pop();\n    } else if (curStructsTarget !== null && curStructsTarget.i < curStructsTarget.refs.length) {\n      stackHead = /** @type {GC|Item} */\n      curStructsTarget.refs[curStructsTarget.i++];\n    } else {\n      curStructsTarget = getNextStructTarget();\n      if (curStructsTarget === null) {\n        break;\n      } else {\n        stackHead = /** @type {GC|Item} */\n        curStructsTarget.refs[curStructsTarget.i++];\n      }\n    }\n  }\n  if (restStructs.clients.size > 0) {\n    const encoder = new UpdateEncoderV2();\n    writeClientsStructs(encoder, restStructs, /* @__PURE__ */ new Map());\n    writeVarUint(encoder.restEncoder, 0);\n    return { missing: missingSV, update: encoder.toUint8Array() };\n  }\n  return null;\n};\nvar writeStructsFromTransaction = (encoder, transaction) => writeClientsStructs(encoder, transaction.doc.store, transaction.beforeState);\nvar readUpdateV2 = (decoder, ydoc, transactionOrigin, structDecoder = new UpdateDecoderV2(decoder)) => transact(ydoc, (transaction) => {\n  transaction.local = false;\n  let retry = false;\n  const doc2 = transaction.doc;\n  const store = doc2.store;\n  const ss = readClientsStructRefs(structDecoder, doc2);\n  const restStructs = integrateStructs(transaction, store, ss);\n  const pending = store.pendingStructs;\n  if (pending) {\n    for (const [client, clock] of pending.missing) {\n      if (clock < getState(store, client)) {\n        retry = true;\n        break;\n      }\n    }\n    if (restStructs) {\n      for (const [client, clock] of restStructs.missing) {\n        const mclock = pending.missing.get(client);\n        if (mclock == null || mclock > clock) {\n          pending.missing.set(client, clock);\n        }\n      }\n      pending.update = mergeUpdatesV2([pending.update, restStructs.update]);\n    }\n  } else {\n    store.pendingStructs = restStructs;\n  }\n  const dsRest = readAndApplyDeleteSet(structDecoder, transaction, store);\n  if (store.pendingDs) {\n    const pendingDSUpdate = new UpdateDecoderV2(createDecoder(store.pendingDs));\n    readVarUint(pendingDSUpdate.restDecoder);\n    const dsRest2 = readAndApplyDeleteSet(pendingDSUpdate, transaction, store);\n    if (dsRest && dsRest2) {\n      store.pendingDs = mergeUpdatesV2([dsRest, dsRest2]);\n    } else {\n      store.pendingDs = dsRest || dsRest2;\n    }\n  } else {\n    store.pendingDs = dsRest;\n  }\n  if (retry) {\n    const update = (\n      /** @type {{update: Uint8Array}} */\n      store.pendingStructs.update\n    );\n    store.pendingStructs = null;\n    applyUpdateV2(transaction.doc, update);\n  }\n}, transactionOrigin, false);\nvar readUpdate = (decoder, ydoc, transactionOrigin) => readUpdateV2(decoder, ydoc, transactionOrigin, new UpdateDecoderV1(decoder));\nvar applyUpdateV2 = (ydoc, update, transactionOrigin, YDecoder = UpdateDecoderV2) => {\n  const decoder = createDecoder(update);\n  readUpdateV2(decoder, ydoc, transactionOrigin, new YDecoder(decoder));\n};\nvar applyUpdate = (ydoc, update, transactionOrigin) => applyUpdateV2(ydoc, update, transactionOrigin, UpdateDecoderV1);\nvar writeStateAsUpdate = (encoder, doc2, targetStateVector = /* @__PURE__ */ new Map()) => {\n  writeClientsStructs(encoder, doc2.store, targetStateVector);\n  writeDeleteSet(encoder, createDeleteSetFromStructStore(doc2.store));\n};\nvar encodeStateAsUpdateV2 = (doc2, encodedTargetStateVector = new Uint8Array([0]), encoder = new UpdateEncoderV2()) => {\n  const targetStateVector = decodeStateVector(encodedTargetStateVector);\n  writeStateAsUpdate(encoder, doc2, targetStateVector);\n  const updates = [encoder.toUint8Array()];\n  if (doc2.store.pendingDs) {\n    updates.push(doc2.store.pendingDs);\n  }\n  if (doc2.store.pendingStructs) {\n    updates.push(diffUpdateV2(doc2.store.pendingStructs.update, encodedTargetStateVector));\n  }\n  if (updates.length > 1) {\n    if (encoder.constructor === UpdateEncoderV1) {\n      return mergeUpdates(updates.map((update, i) => i === 0 ? update : convertUpdateFormatV2ToV1(update)));\n    } else if (encoder.constructor === UpdateEncoderV2) {\n      return mergeUpdatesV2(updates);\n    }\n  }\n  return updates[0];\n};\nvar encodeStateAsUpdate = (doc2, encodedTargetStateVector) => encodeStateAsUpdateV2(doc2, encodedTargetStateVector, new UpdateEncoderV1());\nvar readStateVector = (decoder) => {\n  const ss = /* @__PURE__ */ new Map();\n  const ssLength = readVarUint(decoder.restDecoder);\n  for (let i = 0; i < ssLength; i++) {\n    const client = readVarUint(decoder.restDecoder);\n    const clock = readVarUint(decoder.restDecoder);\n    ss.set(client, clock);\n  }\n  return ss;\n};\nvar decodeStateVector = (decodedState) => readStateVector(new DSDecoderV1(createDecoder(decodedState)));\nvar writeStateVector = (encoder, sv) => {\n  writeVarUint(encoder.restEncoder, sv.size);\n  from2(sv.entries()).sort((a, b) => b[0] - a[0]).forEach(([client, clock]) => {\n    writeVarUint(encoder.restEncoder, client);\n    writeVarUint(encoder.restEncoder, clock);\n  });\n  return encoder;\n};\nvar writeDocumentStateVector = (encoder, doc2) => writeStateVector(encoder, getStateVector(doc2.store));\nvar encodeStateVectorV2 = (doc2, encoder = new DSEncoderV2()) => {\n  if (doc2 instanceof Map) {\n    writeStateVector(encoder, doc2);\n  } else {\n    writeDocumentStateVector(encoder, doc2);\n  }\n  return encoder.toUint8Array();\n};\nvar encodeStateVector = (doc2) => encodeStateVectorV2(doc2, new DSEncoderV1());\nvar EventHandler = class {\n  constructor() {\n    this.l = [];\n  }\n};\nvar createEventHandler = () => new EventHandler();\nvar addEventHandlerListener = (eventHandler, f) => eventHandler.l.push(f);\nvar removeEventHandlerListener = (eventHandler, f) => {\n  const l = eventHandler.l;\n  const len = l.length;\n  eventHandler.l = l.filter((g) => f !== g);\n  if (len === eventHandler.l.length) {\n    console.error(\"[yjs] Tried to remove event handler that doesn't exist.\");\n  }\n};\nvar callEventHandlerListeners = (eventHandler, arg0, arg1) => callAll(eventHandler.l, [arg0, arg1]);\nvar ID = class {\n  /**\n   * @param {number} client client id\n   * @param {number} clock unique per client id, continuous number\n   */\n  constructor(client, clock) {\n    this.client = client;\n    this.clock = clock;\n  }\n};\nvar compareIDs = (a, b) => a === b || a !== null && b !== null && a.client === b.client && a.clock === b.clock;\nvar createID = (client, clock) => new ID(client, clock);\nvar writeID = (encoder, id2) => {\n  writeVarUint(encoder, id2.client);\n  writeVarUint(encoder, id2.clock);\n};\nvar readID = (decoder) => createID(readVarUint(decoder), readVarUint(decoder));\nvar findRootTypeKey = (type) => {\n  for (const [key, value] of type.doc.share.entries()) {\n    if (value === type) {\n      return key;\n    }\n  }\n  throw unexpectedCase();\n};\nvar isParentOf = (parent, child) => {\n  while (child !== null) {\n    if (child.parent === parent) {\n      return true;\n    }\n    child = /** @type {AbstractType<any>} */\n    child.parent._item;\n  }\n  return false;\n};\nvar logType = (type) => {\n  const res = [];\n  let n = type._start;\n  while (n) {\n    res.push(n);\n    n = n.right;\n  }\n  console.log(\"Children: \", res);\n  console.log(\"Children content: \", res.filter((m) => !m.deleted).map((m) => m.content));\n};\nvar PermanentUserData = class {\n  /**\n   * @param {Doc} doc\n   * @param {YMap<any>} [storeType]\n   */\n  constructor(doc2, storeType = doc2.getMap(\"users\")) {\n    const dss = /* @__PURE__ */ new Map();\n    this.yusers = storeType;\n    this.doc = doc2;\n    this.clients = /* @__PURE__ */ new Map();\n    this.dss = dss;\n    const initUser = (user, userDescription) => {\n      const ds = user.get(\"ds\");\n      const ids = user.get(\"ids\");\n      const addClientId = (\n        /** @param {number} clientid */\n        (clientid) => this.clients.set(clientid, userDescription)\n      );\n      ds.observe(\n        /** @param {YArrayEvent<any>} event */\n        (event) => {\n          event.changes.added.forEach((item) => {\n            item.content.getContent().forEach((encodedDs) => {\n              if (encodedDs instanceof Uint8Array) {\n                this.dss.set(userDescription, mergeDeleteSets([this.dss.get(userDescription) || createDeleteSet(), readDeleteSet(new DSDecoderV1(createDecoder(encodedDs)))]));\n              }\n            });\n          });\n        }\n      );\n      this.dss.set(userDescription, mergeDeleteSets(ds.map((encodedDs) => readDeleteSet(new DSDecoderV1(createDecoder(encodedDs))))));\n      ids.observe(\n        /** @param {YArrayEvent<any>} event */\n        (event) => event.changes.added.forEach((item) => item.content.getContent().forEach(addClientId))\n      );\n      ids.forEach(addClientId);\n    };\n    storeType.observe((event) => {\n      event.keysChanged.forEach(\n        (userDescription) => initUser(storeType.get(userDescription), userDescription)\n      );\n    });\n    storeType.forEach(initUser);\n  }\n  /**\n   * @param {Doc} doc\n   * @param {number} clientid\n   * @param {string} userDescription\n   * @param {Object} conf\n   * @param {function(Transaction, DeleteSet):boolean} [conf.filter]\n   */\n  setUserMapping(doc2, clientid, userDescription, { filter = () => true } = {}) {\n    const users = this.yusers;\n    let user = users.get(userDescription);\n    if (!user) {\n      user = new YMap();\n      user.set(\"ids\", new YArray());\n      user.set(\"ds\", new YArray());\n      users.set(userDescription, user);\n    }\n    user.get(\"ids\").push([clientid]);\n    users.observe((_event) => {\n      setTimeout(() => {\n        const userOverwrite = users.get(userDescription);\n        if (userOverwrite !== user) {\n          user = userOverwrite;\n          this.clients.forEach((_userDescription, clientid2) => {\n            if (userDescription === _userDescription) {\n              user.get(\"ids\").push([clientid2]);\n            }\n          });\n          const encoder = new DSEncoderV1();\n          const ds = this.dss.get(userDescription);\n          if (ds) {\n            writeDeleteSet(encoder, ds);\n            user.get(\"ds\").push([encoder.toUint8Array()]);\n          }\n        }\n      }, 0);\n    });\n    doc2.on(\n      \"afterTransaction\",\n      /** @param {Transaction} transaction */\n      (transaction) => {\n        setTimeout(() => {\n          const yds = user.get(\"ds\");\n          const ds = transaction.deleteSet;\n          if (transaction.local && ds.clients.size > 0 && filter(transaction, ds)) {\n            const encoder = new DSEncoderV1();\n            writeDeleteSet(encoder, ds);\n            yds.push([encoder.toUint8Array()]);\n          }\n        });\n      }\n    );\n  }\n  /**\n   * @param {number} clientid\n   * @return {any}\n   */\n  getUserByClientId(clientid) {\n    return this.clients.get(clientid) || null;\n  }\n  /**\n   * @param {ID} id\n   * @return {string | null}\n   */\n  getUserByDeletedId(id2) {\n    for (const [userDescription, ds] of this.dss.entries()) {\n      if (isDeleted(ds, id2)) {\n        return userDescription;\n      }\n    }\n    return null;\n  }\n};\nvar RelativePosition = class {\n  /**\n   * @param {ID|null} type\n   * @param {string|null} tname\n   * @param {ID|null} item\n   * @param {number} assoc\n   */\n  constructor(type, tname, item, assoc = 0) {\n    this.type = type;\n    this.tname = tname;\n    this.item = item;\n    this.assoc = assoc;\n  }\n};\nvar relativePositionToJSON = (rpos) => {\n  const json = {};\n  if (rpos.type) {\n    json.type = rpos.type;\n  }\n  if (rpos.tname) {\n    json.tname = rpos.tname;\n  }\n  if (rpos.item) {\n    json.item = rpos.item;\n  }\n  if (rpos.assoc != null) {\n    json.assoc = rpos.assoc;\n  }\n  return json;\n};\nvar createRelativePositionFromJSON = (json) => new RelativePosition(json.type == null ? null : createID(json.type.client, json.type.clock), json.tname || null, json.item == null ? null : createID(json.item.client, json.item.clock), json.assoc == null ? 0 : json.assoc);\nvar AbsolutePosition = class {\n  /**\n   * @param {AbstractType<any>} type\n   * @param {number} index\n   * @param {number} [assoc]\n   */\n  constructor(type, index, assoc = 0) {\n    this.type = type;\n    this.index = index;\n    this.assoc = assoc;\n  }\n};\nvar createAbsolutePosition = (type, index, assoc = 0) => new AbsolutePosition(type, index, assoc);\nvar createRelativePosition = (type, item, assoc) => {\n  let typeid = null;\n  let tname = null;\n  if (type._item === null) {\n    tname = findRootTypeKey(type);\n  } else {\n    typeid = createID(type._item.id.client, type._item.id.clock);\n  }\n  return new RelativePosition(typeid, tname, item, assoc);\n};\nvar createRelativePositionFromTypeIndex = (type, index, assoc = 0) => {\n  let t = type._start;\n  if (assoc < 0) {\n    if (index === 0) {\n      return createRelativePosition(type, null, assoc);\n    }\n    index--;\n  }\n  while (t !== null) {\n    if (!t.deleted && t.countable) {\n      if (t.length > index) {\n        return createRelativePosition(type, createID(t.id.client, t.id.clock + index), assoc);\n      }\n      index -= t.length;\n    }\n    if (t.right === null && assoc < 0) {\n      return createRelativePosition(type, t.lastId, assoc);\n    }\n    t = t.right;\n  }\n  return createRelativePosition(type, null, assoc);\n};\nvar writeRelativePosition = (encoder, rpos) => {\n  const { type, tname, item, assoc } = rpos;\n  if (item !== null) {\n    writeVarUint(encoder, 0);\n    writeID(encoder, item);\n  } else if (tname !== null) {\n    writeUint8(encoder, 1);\n    writeVarString(encoder, tname);\n  } else if (type !== null) {\n    writeUint8(encoder, 2);\n    writeID(encoder, type);\n  } else {\n    throw unexpectedCase();\n  }\n  writeVarInt(encoder, assoc);\n  return encoder;\n};\nvar encodeRelativePosition = (rpos) => {\n  const encoder = createEncoder();\n  writeRelativePosition(encoder, rpos);\n  return toUint8Array(encoder);\n};\nvar readRelativePosition = (decoder) => {\n  let type = null;\n  let tname = null;\n  let itemID = null;\n  switch (readVarUint(decoder)) {\n    case 0:\n      itemID = readID(decoder);\n      break;\n    case 1:\n      tname = readVarString(decoder);\n      break;\n    case 2: {\n      type = readID(decoder);\n    }\n  }\n  const assoc = hasContent(decoder) ? readVarInt(decoder) : 0;\n  return new RelativePosition(type, tname, itemID, assoc);\n};\nvar decodeRelativePosition = (uint8Array) => readRelativePosition(createDecoder(uint8Array));\nvar createAbsolutePositionFromRelativePosition = (rpos, doc2) => {\n  const store = doc2.store;\n  const rightID = rpos.item;\n  const typeID = rpos.type;\n  const tname = rpos.tname;\n  const assoc = rpos.assoc;\n  let type = null;\n  let index = 0;\n  if (rightID !== null) {\n    if (getState(store, rightID.client) <= rightID.clock) {\n      return null;\n    }\n    const res = followRedone(store, rightID);\n    const right = res.item;\n    if (!(right instanceof Item)) {\n      return null;\n    }\n    type = /** @type {AbstractType<any>} */\n    right.parent;\n    if (type._item === null || !type._item.deleted) {\n      index = right.deleted || !right.countable ? 0 : res.diff + (assoc >= 0 ? 0 : 1);\n      let n = right.left;\n      while (n !== null) {\n        if (!n.deleted && n.countable) {\n          index += n.length;\n        }\n        n = n.left;\n      }\n    }\n  } else {\n    if (tname !== null) {\n      type = doc2.get(tname);\n    } else if (typeID !== null) {\n      if (getState(store, typeID.client) <= typeID.clock) {\n        return null;\n      }\n      const { item } = followRedone(store, typeID);\n      if (item instanceof Item && item.content instanceof ContentType) {\n        type = item.content.type;\n      } else {\n        return null;\n      }\n    } else {\n      throw unexpectedCase();\n    }\n    if (assoc >= 0) {\n      index = type._length;\n    } else {\n      index = 0;\n    }\n  }\n  return createAbsolutePosition(type, index, rpos.assoc);\n};\nvar compareRelativePositions = (a, b) => a === b || a !== null && b !== null && a.tname === b.tname && compareIDs(a.item, b.item) && compareIDs(a.type, b.type) && a.assoc === b.assoc;\nvar Snapshot = class {\n  /**\n   * @param {DeleteSet} ds\n   * @param {Map<number,number>} sv state map\n   */\n  constructor(ds, sv) {\n    this.ds = ds;\n    this.sv = sv;\n  }\n};\nvar equalSnapshots = (snap1, snap2) => {\n  const ds1 = snap1.ds.clients;\n  const ds2 = snap2.ds.clients;\n  const sv1 = snap1.sv;\n  const sv2 = snap2.sv;\n  if (sv1.size !== sv2.size || ds1.size !== ds2.size) {\n    return false;\n  }\n  for (const [key, value] of sv1.entries()) {\n    if (sv2.get(key) !== value) {\n      return false;\n    }\n  }\n  for (const [client, dsitems1] of ds1.entries()) {\n    const dsitems2 = ds2.get(client) || [];\n    if (dsitems1.length !== dsitems2.length) {\n      return false;\n    }\n    for (let i = 0; i < dsitems1.length; i++) {\n      const dsitem1 = dsitems1[i];\n      const dsitem2 = dsitems2[i];\n      if (dsitem1.clock !== dsitem2.clock || dsitem1.len !== dsitem2.len) {\n        return false;\n      }\n    }\n  }\n  return true;\n};\nvar encodeSnapshotV2 = (snapshot2, encoder = new DSEncoderV2()) => {\n  writeDeleteSet(encoder, snapshot2.ds);\n  writeStateVector(encoder, snapshot2.sv);\n  return encoder.toUint8Array();\n};\nvar encodeSnapshot = (snapshot2) => encodeSnapshotV2(snapshot2, new DSEncoderV1());\nvar decodeSnapshotV2 = (buf, decoder = new DSDecoderV2(createDecoder(buf))) => {\n  return new Snapshot(readDeleteSet(decoder), readStateVector(decoder));\n};\nvar decodeSnapshot = (buf) => decodeSnapshotV2(buf, new DSDecoderV1(createDecoder(buf)));\nvar createSnapshot = (ds, sm) => new Snapshot(ds, sm);\nvar emptySnapshot = createSnapshot(createDeleteSet(), /* @__PURE__ */ new Map());\nvar snapshot = (doc2) => createSnapshot(createDeleteSetFromStructStore(doc2.store), getStateVector(doc2.store));\nvar isVisible = (item, snapshot2) => snapshot2 === void 0 ? !item.deleted : snapshot2.sv.has(item.id.client) && (snapshot2.sv.get(item.id.client) || 0) > item.id.clock && !isDeleted(snapshot2.ds, item.id);\nvar splitSnapshotAffectedStructs = (transaction, snapshot2) => {\n  const meta = setIfUndefined(transaction.meta, splitSnapshotAffectedStructs, create2);\n  const store = transaction.doc.store;\n  if (!meta.has(snapshot2)) {\n    snapshot2.sv.forEach((clock, client) => {\n      if (clock < getState(store, client)) {\n        getItemCleanStart(transaction, createID(client, clock));\n      }\n    });\n    iterateDeletedStructs(transaction, snapshot2.ds, (_item) => {\n    });\n    meta.add(snapshot2);\n  }\n};\nvar createDocFromSnapshot = (originDoc, snapshot2, newDoc = new Doc()) => {\n  if (originDoc.gc) {\n    throw new Error(\"Garbage-collection must be disabled in `originDoc`!\");\n  }\n  const { sv, ds } = snapshot2;\n  const encoder = new UpdateEncoderV2();\n  originDoc.transact((transaction) => {\n    let size = 0;\n    sv.forEach((clock) => {\n      if (clock > 0) {\n        size++;\n      }\n    });\n    writeVarUint(encoder.restEncoder, size);\n    for (const [client, clock] of sv) {\n      if (clock === 0) {\n        continue;\n      }\n      if (clock < getState(originDoc.store, client)) {\n        getItemCleanStart(transaction, createID(client, clock));\n      }\n      const structs = originDoc.store.clients.get(client) || [];\n      const lastStructIndex = findIndexSS(structs, clock - 1);\n      writeVarUint(encoder.restEncoder, lastStructIndex + 1);\n      encoder.writeClient(client);\n      writeVarUint(encoder.restEncoder, 0);\n      for (let i = 0; i <= lastStructIndex; i++) {\n        structs[i].write(encoder, 0);\n      }\n    }\n    writeDeleteSet(encoder, ds);\n  });\n  applyUpdateV2(newDoc, encoder.toUint8Array(), \"snapshot\");\n  return newDoc;\n};\nvar snapshotContainsUpdateV2 = (snapshot2, update, YDecoder = UpdateDecoderV2) => {\n  const updateDecoder = new YDecoder(createDecoder(update));\n  const lazyDecoder = new LazyStructReader(updateDecoder, false);\n  for (let curr = lazyDecoder.curr; curr !== null; curr = lazyDecoder.next()) {\n    if ((snapshot2.sv.get(curr.id.client) || 0) < curr.id.clock + curr.length) {\n      return false;\n    }\n  }\n  const mergedDS = mergeDeleteSets([snapshot2.ds, readDeleteSet(updateDecoder)]);\n  return equalDeleteSets(snapshot2.ds, mergedDS);\n};\nvar snapshotContainsUpdate = (snapshot2, update) => snapshotContainsUpdateV2(snapshot2, update, UpdateDecoderV1);\nvar StructStore = class {\n  constructor() {\n    this.clients = /* @__PURE__ */ new Map();\n    this.pendingStructs = null;\n    this.pendingDs = null;\n  }\n};\nvar getStateVector = (store) => {\n  const sm = /* @__PURE__ */ new Map();\n  store.clients.forEach((structs, client) => {\n    const struct = structs[structs.length - 1];\n    sm.set(client, struct.id.clock + struct.length);\n  });\n  return sm;\n};\nvar getState = (store, client) => {\n  const structs = store.clients.get(client);\n  if (structs === void 0) {\n    return 0;\n  }\n  const lastStruct = structs[structs.length - 1];\n  return lastStruct.id.clock + lastStruct.length;\n};\nvar addStruct = (store, struct) => {\n  let structs = store.clients.get(struct.id.client);\n  if (structs === void 0) {\n    structs = [];\n    store.clients.set(struct.id.client, structs);\n  } else {\n    const lastStruct = structs[structs.length - 1];\n    if (lastStruct.id.clock + lastStruct.length !== struct.id.clock) {\n      throw unexpectedCase();\n    }\n  }\n  structs.push(struct);\n};\nvar findIndexSS = (structs, clock) => {\n  let left = 0;\n  let right = structs.length - 1;\n  let mid = structs[right];\n  let midclock = mid.id.clock;\n  if (midclock === clock) {\n    return right;\n  }\n  let midindex = floor(clock / (midclock + mid.length - 1) * right);\n  while (left <= right) {\n    mid = structs[midindex];\n    midclock = mid.id.clock;\n    if (midclock <= clock) {\n      if (clock < midclock + mid.length) {\n        return midindex;\n      }\n      left = midindex + 1;\n    } else {\n      right = midindex - 1;\n    }\n    midindex = floor((left + right) / 2);\n  }\n  throw unexpectedCase();\n};\nvar find = (store, id2) => {\n  const structs = store.clients.get(id2.client);\n  return structs[findIndexSS(structs, id2.clock)];\n};\nvar getItem = (\n  /** @type {function(StructStore,ID):Item} */\n  find\n);\nvar findIndexCleanStart = (transaction, structs, clock) => {\n  const index = findIndexSS(structs, clock);\n  const struct = structs[index];\n  if (struct.id.clock < clock && struct instanceof Item) {\n    structs.splice(index + 1, 0, splitItem(transaction, struct, clock - struct.id.clock));\n    return index + 1;\n  }\n  return index;\n};\nvar getItemCleanStart = (transaction, id2) => {\n  const structs = (\n    /** @type {Array<Item>} */\n    transaction.doc.store.clients.get(id2.client)\n  );\n  return structs[findIndexCleanStart(transaction, structs, id2.clock)];\n};\nvar getItemCleanEnd = (transaction, store, id2) => {\n  const structs = store.clients.get(id2.client);\n  const index = findIndexSS(structs, id2.clock);\n  const struct = structs[index];\n  if (id2.clock !== struct.id.clock + struct.length - 1 && struct.constructor !== GC) {\n    structs.splice(index + 1, 0, splitItem(transaction, struct, id2.clock - struct.id.clock + 1));\n  }\n  return struct;\n};\nvar replaceStruct = (store, struct, newStruct) => {\n  const structs = (\n    /** @type {Array<GC|Item>} */\n    store.clients.get(struct.id.client)\n  );\n  structs[findIndexSS(structs, struct.id.clock)] = newStruct;\n};\nvar iterateStructs = (transaction, structs, clockStart, len, f) => {\n  if (len === 0) {\n    return;\n  }\n  const clockEnd = clockStart + len;\n  let index = findIndexCleanStart(transaction, structs, clockStart);\n  let struct;\n  do {\n    struct = structs[index++];\n    if (clockEnd < struct.id.clock + struct.length) {\n      findIndexCleanStart(transaction, structs, clockEnd);\n    }\n    f(struct);\n  } while (index < structs.length && structs[index].id.clock < clockEnd);\n};\nvar Transaction = class {\n  /**\n   * @param {Doc} doc\n   * @param {any} origin\n   * @param {boolean} local\n   */\n  constructor(doc2, origin, local) {\n    this.doc = doc2;\n    this.deleteSet = new DeleteSet();\n    this.beforeState = getStateVector(doc2.store);\n    this.afterState = /* @__PURE__ */ new Map();\n    this.changed = /* @__PURE__ */ new Map();\n    this.changedParentTypes = /* @__PURE__ */ new Map();\n    this._mergeStructs = [];\n    this.origin = origin;\n    this.meta = /* @__PURE__ */ new Map();\n    this.local = local;\n    this.subdocsAdded = /* @__PURE__ */ new Set();\n    this.subdocsRemoved = /* @__PURE__ */ new Set();\n    this.subdocsLoaded = /* @__PURE__ */ new Set();\n    this._needFormattingCleanup = false;\n  }\n};\nvar writeUpdateMessageFromTransaction = (encoder, transaction) => {\n  if (transaction.deleteSet.clients.size === 0 && !any(transaction.afterState, (clock, client) => transaction.beforeState.get(client) !== clock)) {\n    return false;\n  }\n  sortAndMergeDeleteSet(transaction.deleteSet);\n  writeStructsFromTransaction(encoder, transaction);\n  writeDeleteSet(encoder, transaction.deleteSet);\n  return true;\n};\nvar addChangedTypeToTransaction = (transaction, type, parentSub) => {\n  const item = type._item;\n  if (item === null || item.id.clock < (transaction.beforeState.get(item.id.client) || 0) && !item.deleted) {\n    setIfUndefined(transaction.changed, type, create2).add(parentSub);\n  }\n};\nvar tryToMergeWithLefts = (structs, pos) => {\n  let right = structs[pos];\n  let left = structs[pos - 1];\n  let i = pos;\n  for (; i > 0; right = left, left = structs[--i - 1]) {\n    if (left.deleted === right.deleted && left.constructor === right.constructor) {\n      if (left.mergeWith(right)) {\n        if (right instanceof Item && right.parentSub !== null && /** @type {AbstractType<any>} */\n        right.parent._map.get(right.parentSub) === right) {\n          right.parent._map.set(\n            right.parentSub,\n            /** @type {Item} */\n            left\n          );\n        }\n        continue;\n      }\n    }\n    break;\n  }\n  const merged = pos - i;\n  if (merged) {\n    structs.splice(pos + 1 - merged, merged);\n  }\n  return merged;\n};\nvar tryGcDeleteSet = (ds, store, gcFilter) => {\n  for (const [client, deleteItems] of ds.clients.entries()) {\n    const structs = (\n      /** @type {Array<GC|Item>} */\n      store.clients.get(client)\n    );\n    for (let di = deleteItems.length - 1; di >= 0; di--) {\n      const deleteItem = deleteItems[di];\n      const endDeleteItemClock = deleteItem.clock + deleteItem.len;\n      for (let si = findIndexSS(structs, deleteItem.clock), struct = structs[si]; si < structs.length && struct.id.clock < endDeleteItemClock; struct = structs[++si]) {\n        const struct2 = structs[si];\n        if (deleteItem.clock + deleteItem.len <= struct2.id.clock) {\n          break;\n        }\n        if (struct2 instanceof Item && struct2.deleted && !struct2.keep && gcFilter(struct2)) {\n          struct2.gc(store, false);\n        }\n      }\n    }\n  }\n};\nvar tryMergeDeleteSet = (ds, store) => {\n  ds.clients.forEach((deleteItems, client) => {\n    const structs = (\n      /** @type {Array<GC|Item>} */\n      store.clients.get(client)\n    );\n    for (let di = deleteItems.length - 1; di >= 0; di--) {\n      const deleteItem = deleteItems[di];\n      const mostRightIndexToCheck = min(structs.length - 1, 1 + findIndexSS(structs, deleteItem.clock + deleteItem.len - 1));\n      for (let si = mostRightIndexToCheck, struct = structs[si]; si > 0 && struct.id.clock >= deleteItem.clock; struct = structs[si]) {\n        si -= 1 + tryToMergeWithLefts(structs, si);\n      }\n    }\n  });\n};\nvar tryGc = (ds, store, gcFilter) => {\n  tryGcDeleteSet(ds, store, gcFilter);\n  tryMergeDeleteSet(ds, store);\n};\nvar cleanupTransactions = (transactionCleanups, i) => {\n  if (i < transactionCleanups.length) {\n    const transaction = transactionCleanups[i];\n    const doc2 = transaction.doc;\n    const store = doc2.store;\n    const ds = transaction.deleteSet;\n    const mergeStructs = transaction._mergeStructs;\n    try {\n      sortAndMergeDeleteSet(ds);\n      transaction.afterState = getStateVector(transaction.doc.store);\n      doc2.emit(\"beforeObserverCalls\", [transaction, doc2]);\n      const fs = [];\n      transaction.changed.forEach(\n        (subs, itemtype) => fs.push(() => {\n          if (itemtype._item === null || !itemtype._item.deleted) {\n            itemtype._callObserver(transaction, subs);\n          }\n        })\n      );\n      fs.push(() => {\n        transaction.changedParentTypes.forEach((events, type) => {\n          if (type._dEH.l.length > 0 && (type._item === null || !type._item.deleted)) {\n            events = events.filter(\n              (event) => event.target._item === null || !event.target._item.deleted\n            );\n            events.forEach((event) => {\n              event.currentTarget = type;\n              event._path = null;\n            });\n            events.sort((event1, event2) => event1.path.length - event2.path.length);\n            callEventHandlerListeners(type._dEH, events, transaction);\n          }\n        });\n      });\n      fs.push(() => doc2.emit(\"afterTransaction\", [transaction, doc2]));\n      callAll(fs, []);\n      if (transaction._needFormattingCleanup) {\n        cleanupYTextAfterTransaction(transaction);\n      }\n    } finally {\n      if (doc2.gc) {\n        tryGcDeleteSet(ds, store, doc2.gcFilter);\n      }\n      tryMergeDeleteSet(ds, store);\n      transaction.afterState.forEach((clock, client) => {\n        const beforeClock = transaction.beforeState.get(client) || 0;\n        if (beforeClock !== clock) {\n          const structs = (\n            /** @type {Array<GC|Item>} */\n            store.clients.get(client)\n          );\n          const firstChangePos = max(findIndexSS(structs, beforeClock), 1);\n          for (let i2 = structs.length - 1; i2 >= firstChangePos; ) {\n            i2 -= 1 + tryToMergeWithLefts(structs, i2);\n          }\n        }\n      });\n      for (let i2 = mergeStructs.length - 1; i2 >= 0; i2--) {\n        const { client, clock } = mergeStructs[i2].id;\n        const structs = (\n          /** @type {Array<GC|Item>} */\n          store.clients.get(client)\n        );\n        const replacedStructPos = findIndexSS(structs, clock);\n        if (replacedStructPos + 1 < structs.length) {\n          if (tryToMergeWithLefts(structs, replacedStructPos + 1) > 1) {\n            continue;\n          }\n        }\n        if (replacedStructPos > 0) {\n          tryToMergeWithLefts(structs, replacedStructPos);\n        }\n      }\n      if (!transaction.local && transaction.afterState.get(doc2.clientID) !== transaction.beforeState.get(doc2.clientID)) {\n        print(ORANGE, BOLD, \"[yjs] \", UNBOLD, RED, \"Changed the client-id because another client seems to be using it.\");\n        doc2.clientID = generateNewClientId();\n      }\n      doc2.emit(\"afterTransactionCleanup\", [transaction, doc2]);\n      if (doc2._observers.has(\"update\")) {\n        const encoder = new UpdateEncoderV1();\n        const hasContent2 = writeUpdateMessageFromTransaction(encoder, transaction);\n        if (hasContent2) {\n          doc2.emit(\"update\", [encoder.toUint8Array(), transaction.origin, doc2, transaction]);\n        }\n      }\n      if (doc2._observers.has(\"updateV2\")) {\n        const encoder = new UpdateEncoderV2();\n        const hasContent2 = writeUpdateMessageFromTransaction(encoder, transaction);\n        if (hasContent2) {\n          doc2.emit(\"updateV2\", [encoder.toUint8Array(), transaction.origin, doc2, transaction]);\n        }\n      }\n      const { subdocsAdded, subdocsLoaded, subdocsRemoved } = transaction;\n      if (subdocsAdded.size > 0 || subdocsRemoved.size > 0 || subdocsLoaded.size > 0) {\n        subdocsAdded.forEach((subdoc) => {\n          subdoc.clientID = doc2.clientID;\n          if (subdoc.collectionid == null) {\n            subdoc.collectionid = doc2.collectionid;\n          }\n          doc2.subdocs.add(subdoc);\n        });\n        subdocsRemoved.forEach((subdoc) => doc2.subdocs.delete(subdoc));\n        doc2.emit(\"subdocs\", [{ loaded: subdocsLoaded, added: subdocsAdded, removed: subdocsRemoved }, doc2, transaction]);\n        subdocsRemoved.forEach((subdoc) => subdoc.destroy());\n      }\n      if (transactionCleanups.length <= i + 1) {\n        doc2._transactionCleanups = [];\n        doc2.emit(\"afterAllTransactions\", [doc2, transactionCleanups]);\n      } else {\n        cleanupTransactions(transactionCleanups, i + 1);\n      }\n    }\n  }\n};\nvar transact = (doc2, f, origin = null, local = true) => {\n  const transactionCleanups = doc2._transactionCleanups;\n  let initialCall = false;\n  let result = null;\n  if (doc2._transaction === null) {\n    initialCall = true;\n    doc2._transaction = new Transaction(doc2, origin, local);\n    transactionCleanups.push(doc2._transaction);\n    if (transactionCleanups.length === 1) {\n      doc2.emit(\"beforeAllTransactions\", [doc2]);\n    }\n    doc2.emit(\"beforeTransaction\", [doc2._transaction, doc2]);\n  }\n  try {\n    result = f(doc2._transaction);\n  } finally {\n    if (initialCall) {\n      const finishCleanup = doc2._transaction === transactionCleanups[0];\n      doc2._transaction = null;\n      if (finishCleanup) {\n        cleanupTransactions(transactionCleanups, 0);\n      }\n    }\n  }\n  return result;\n};\nvar StackItem = class {\n  /**\n   * @param {DeleteSet} deletions\n   * @param {DeleteSet} insertions\n   */\n  constructor(deletions, insertions) {\n    this.insertions = insertions;\n    this.deletions = deletions;\n    this.meta = /* @__PURE__ */ new Map();\n  }\n};\nvar clearUndoManagerStackItem = (tr, um, stackItem) => {\n  iterateDeletedStructs(tr, stackItem.deletions, (item) => {\n    if (item instanceof Item && um.scope.some((type) => isParentOf(type, item))) {\n      keepItem(item, false);\n    }\n  });\n};\nvar popStackItem = (undoManager, stack, eventType) => {\n  let result = null;\n  let _tr = null;\n  const doc2 = undoManager.doc;\n  const scope = undoManager.scope;\n  transact(doc2, (transaction) => {\n    while (stack.length > 0 && result === null) {\n      const store = doc2.store;\n      const stackItem = (\n        /** @type {StackItem} */\n        stack.pop()\n      );\n      const itemsToRedo = /* @__PURE__ */ new Set();\n      const itemsToDelete = [];\n      let performedChange = false;\n      iterateDeletedStructs(transaction, stackItem.insertions, (struct) => {\n        if (struct instanceof Item) {\n          if (struct.redone !== null) {\n            let { item, diff } = followRedone(store, struct.id);\n            if (diff > 0) {\n              item = getItemCleanStart(transaction, createID(item.id.client, item.id.clock + diff));\n            }\n            struct = item;\n          }\n          if (!struct.deleted && scope.some((type) => isParentOf(\n            type,\n            /** @type {Item} */\n            struct\n          ))) {\n            itemsToDelete.push(struct);\n          }\n        }\n      });\n      iterateDeletedStructs(transaction, stackItem.deletions, (struct) => {\n        if (struct instanceof Item && scope.some((type) => isParentOf(type, struct)) && // Never redo structs in stackItem.insertions because they were created and deleted in the same capture interval.\n        !isDeleted(stackItem.insertions, struct.id)) {\n          itemsToRedo.add(struct);\n        }\n      });\n      itemsToRedo.forEach((struct) => {\n        performedChange = redoItem(transaction, struct, itemsToRedo, stackItem.insertions, undoManager.ignoreRemoteMapChanges, undoManager) !== null || performedChange;\n      });\n      for (let i = itemsToDelete.length - 1; i >= 0; i--) {\n        const item = itemsToDelete[i];\n        if (undoManager.deleteFilter(item)) {\n          item.delete(transaction);\n          performedChange = true;\n        }\n      }\n      result = performedChange ? stackItem : null;\n    }\n    transaction.changed.forEach((subProps, type) => {\n      if (subProps.has(null) && type._searchMarker) {\n        type._searchMarker.length = 0;\n      }\n    });\n    _tr = transaction;\n  }, undoManager);\n  if (result != null) {\n    const changedParentTypes = _tr.changedParentTypes;\n    undoManager.emit(\"stack-item-popped\", [{ stackItem: result, type: eventType, changedParentTypes }, undoManager]);\n  }\n  return result;\n};\nvar UndoManager = class extends Observable {\n  /**\n   * @param {AbstractType<any>|Array<AbstractType<any>>} typeScope Accepts either a single type, or an array of types\n   * @param {UndoManagerOptions} options\n   */\n  constructor(typeScope, {\n    captureTimeout = 500,\n    captureTransaction = (_tr) => true,\n    deleteFilter = () => true,\n    trackedOrigins = /* @__PURE__ */ new Set([null]),\n    ignoreRemoteMapChanges = false,\n    doc: doc2 = (\n      /** @type {Doc} */\n      isArray(typeScope) ? typeScope[0].doc : typeScope.doc\n    )\n  } = {}) {\n    super();\n    this.scope = [];\n    this.addToScope(typeScope);\n    this.deleteFilter = deleteFilter;\n    trackedOrigins.add(this);\n    this.trackedOrigins = trackedOrigins;\n    this.captureTransaction = captureTransaction;\n    this.undoStack = [];\n    this.redoStack = [];\n    this.undoing = false;\n    this.redoing = false;\n    this.doc = doc2;\n    this.lastChange = 0;\n    this.ignoreRemoteMapChanges = ignoreRemoteMapChanges;\n    this.captureTimeout = captureTimeout;\n    this.afterTransactionHandler = (transaction) => {\n      if (!this.captureTransaction(transaction) || !this.scope.some((type) => transaction.changedParentTypes.has(type)) || !this.trackedOrigins.has(transaction.origin) && (!transaction.origin || !this.trackedOrigins.has(transaction.origin.constructor))) {\n        return;\n      }\n      const undoing = this.undoing;\n      const redoing = this.redoing;\n      const stack = undoing ? this.redoStack : this.undoStack;\n      if (undoing) {\n        this.stopCapturing();\n      } else if (!redoing) {\n        this.clear(false, true);\n      }\n      const insertions = new DeleteSet();\n      transaction.afterState.forEach((endClock, client) => {\n        const startClock = transaction.beforeState.get(client) || 0;\n        const len = endClock - startClock;\n        if (len > 0) {\n          addToDeleteSet(insertions, client, startClock, len);\n        }\n      });\n      const now = getUnixTime();\n      let didAdd = false;\n      if (this.lastChange > 0 && now - this.lastChange < this.captureTimeout && stack.length > 0 && !undoing && !redoing) {\n        const lastOp = stack[stack.length - 1];\n        lastOp.deletions = mergeDeleteSets([lastOp.deletions, transaction.deleteSet]);\n        lastOp.insertions = mergeDeleteSets([lastOp.insertions, insertions]);\n      } else {\n        stack.push(new StackItem(transaction.deleteSet, insertions));\n        didAdd = true;\n      }\n      if (!undoing && !redoing) {\n        this.lastChange = now;\n      }\n      iterateDeletedStructs(\n        transaction,\n        transaction.deleteSet,\n        /** @param {Item|GC} item */\n        (item) => {\n          if (item instanceof Item && this.scope.some((type) => isParentOf(type, item))) {\n            keepItem(item, true);\n          }\n        }\n      );\n      const changeEvent = [{ stackItem: stack[stack.length - 1], origin: transaction.origin, type: undoing ? \"redo\" : \"undo\", changedParentTypes: transaction.changedParentTypes }, this];\n      if (didAdd) {\n        this.emit(\"stack-item-added\", changeEvent);\n      } else {\n        this.emit(\"stack-item-updated\", changeEvent);\n      }\n    };\n    this.doc.on(\"afterTransaction\", this.afterTransactionHandler);\n    this.doc.on(\"destroy\", () => {\n      this.destroy();\n    });\n  }\n  /**\n   * @param {Array<AbstractType<any>> | AbstractType<any>} ytypes\n   */\n  addToScope(ytypes) {\n    ytypes = isArray(ytypes) ? ytypes : [ytypes];\n    ytypes.forEach((ytype) => {\n      if (this.scope.every((yt) => yt !== ytype)) {\n        this.scope.push(ytype);\n      }\n    });\n  }\n  /**\n   * @param {any} origin\n   */\n  addTrackedOrigin(origin) {\n    this.trackedOrigins.add(origin);\n  }\n  /**\n   * @param {any} origin\n   */\n  removeTrackedOrigin(origin) {\n    this.trackedOrigins.delete(origin);\n  }\n  clear(clearUndoStack = true, clearRedoStack = true) {\n    if (clearUndoStack && this.canUndo() || clearRedoStack && this.canRedo()) {\n      this.doc.transact((tr) => {\n        if (clearUndoStack) {\n          this.undoStack.forEach((item) => clearUndoManagerStackItem(tr, this, item));\n          this.undoStack = [];\n        }\n        if (clearRedoStack) {\n          this.redoStack.forEach((item) => clearUndoManagerStackItem(tr, this, item));\n          this.redoStack = [];\n        }\n        this.emit(\"stack-cleared\", [{ undoStackCleared: clearUndoStack, redoStackCleared: clearRedoStack }]);\n      });\n    }\n  }\n  /**\n   * UndoManager merges Undo-StackItem if they are created within time-gap\n   * smaller than `options.captureTimeout`. Call `um.stopCapturing()` so that the next\n   * StackItem won't be merged.\n   *\n   *\n   * @example\n   *     // without stopCapturing\n   *     ytext.insert(0, 'a')\n   *     ytext.insert(1, 'b')\n   *     um.undo()\n   *     ytext.toString() // => '' (note that 'ab' was removed)\n   *     // with stopCapturing\n   *     ytext.insert(0, 'a')\n   *     um.stopCapturing()\n   *     ytext.insert(0, 'b')\n   *     um.undo()\n   *     ytext.toString() // => 'a' (note that only 'b' was removed)\n   *\n   */\n  stopCapturing() {\n    this.lastChange = 0;\n  }\n  /**\n   * Undo last changes on type.\n   *\n   * @return {StackItem?} Returns StackItem if a change was applied\n   */\n  undo() {\n    this.undoing = true;\n    let res;\n    try {\n      res = popStackItem(this, this.undoStack, \"undo\");\n    } finally {\n      this.undoing = false;\n    }\n    return res;\n  }\n  /**\n   * Redo last undo operation.\n   *\n   * @return {StackItem?} Returns StackItem if a change was applied\n   */\n  redo() {\n    this.redoing = true;\n    let res;\n    try {\n      res = popStackItem(this, this.redoStack, \"redo\");\n    } finally {\n      this.redoing = false;\n    }\n    return res;\n  }\n  /**\n   * Are undo steps available?\n   *\n   * @return {boolean} `true` if undo is possible\n   */\n  canUndo() {\n    return this.undoStack.length > 0;\n  }\n  /**\n   * Are redo steps available?\n   *\n   * @return {boolean} `true` if redo is possible\n   */\n  canRedo() {\n    return this.redoStack.length > 0;\n  }\n  destroy() {\n    this.trackedOrigins.delete(this);\n    this.doc.off(\"afterTransaction\", this.afterTransactionHandler);\n    super.destroy();\n  }\n};\nfunction* lazyStructReaderGenerator(decoder) {\n  const numOfStateUpdates = readVarUint(decoder.restDecoder);\n  for (let i = 0; i < numOfStateUpdates; i++) {\n    const numberOfStructs = readVarUint(decoder.restDecoder);\n    const client = decoder.readClient();\n    let clock = readVarUint(decoder.restDecoder);\n    for (let i2 = 0; i2 < numberOfStructs; i2++) {\n      const info = decoder.readInfo();\n      if (info === 10) {\n        const len = readVarUint(decoder.restDecoder);\n        yield new Skip(createID(client, clock), len);\n        clock += len;\n      } else if ((BITS5 & info) !== 0) {\n        const cantCopyParentInfo = (info & (BIT7 | BIT8)) === 0;\n        const struct = new Item(\n          createID(client, clock),\n          null,\n          // left\n          (info & BIT8) === BIT8 ? decoder.readLeftID() : null,\n          // origin\n          null,\n          // right\n          (info & BIT7) === BIT7 ? decoder.readRightID() : null,\n          // right origin\n          // @ts-ignore Force writing a string here.\n          cantCopyParentInfo ? decoder.readParentInfo() ? decoder.readString() : decoder.readLeftID() : null,\n          // parent\n          cantCopyParentInfo && (info & BIT6) === BIT6 ? decoder.readString() : null,\n          // parentSub\n          readItemContent(decoder, info)\n          // item content\n        );\n        yield struct;\n        clock += struct.length;\n      } else {\n        const len = decoder.readLen();\n        yield new GC(createID(client, clock), len);\n        clock += len;\n      }\n    }\n  }\n}\nvar LazyStructReader = class {\n  /**\n   * @param {UpdateDecoderV1 | UpdateDecoderV2} decoder\n   * @param {boolean} filterSkips\n   */\n  constructor(decoder, filterSkips) {\n    this.gen = lazyStructReaderGenerator(decoder);\n    this.curr = null;\n    this.done = false;\n    this.filterSkips = filterSkips;\n    this.next();\n  }\n  /**\n   * @return {Item | GC | Skip |null}\n   */\n  next() {\n    do {\n      this.curr = this.gen.next().value || null;\n    } while (this.filterSkips && this.curr !== null && this.curr.constructor === Skip);\n    return this.curr;\n  }\n};\nvar logUpdate = (update) => logUpdateV2(update, UpdateDecoderV1);\nvar logUpdateV2 = (update, YDecoder = UpdateDecoderV2) => {\n  const structs = [];\n  const updateDecoder = new YDecoder(createDecoder(update));\n  const lazyDecoder = new LazyStructReader(updateDecoder, false);\n  for (let curr = lazyDecoder.curr; curr !== null; curr = lazyDecoder.next()) {\n    structs.push(curr);\n  }\n  print(\"Structs: \", structs);\n  const ds = readDeleteSet(updateDecoder);\n  print(\"DeleteSet: \", ds);\n};\nvar decodeUpdate = (update) => decodeUpdateV2(update, UpdateDecoderV1);\nvar decodeUpdateV2 = (update, YDecoder = UpdateDecoderV2) => {\n  const structs = [];\n  const updateDecoder = new YDecoder(createDecoder(update));\n  const lazyDecoder = new LazyStructReader(updateDecoder, false);\n  for (let curr = lazyDecoder.curr; curr !== null; curr = lazyDecoder.next()) {\n    structs.push(curr);\n  }\n  return {\n    structs,\n    ds: readDeleteSet(updateDecoder)\n  };\n};\nvar LazyStructWriter = class {\n  /**\n   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder\n   */\n  constructor(encoder) {\n    this.currClient = 0;\n    this.startClock = 0;\n    this.written = 0;\n    this.encoder = encoder;\n    this.clientStructs = [];\n  }\n};\nvar mergeUpdates = (updates) => mergeUpdatesV2(updates, UpdateDecoderV1, UpdateEncoderV1);\nvar encodeStateVectorFromUpdateV2 = (update, YEncoder = DSEncoderV2, YDecoder = UpdateDecoderV2) => {\n  const encoder = new YEncoder();\n  const updateDecoder = new LazyStructReader(new YDecoder(createDecoder(update)), false);\n  let curr = updateDecoder.curr;\n  if (curr !== null) {\n    let size = 0;\n    let currClient = curr.id.client;\n    let stopCounting = curr.id.clock !== 0;\n    let currClock = stopCounting ? 0 : curr.id.clock + curr.length;\n    for (; curr !== null; curr = updateDecoder.next()) {\n      if (currClient !== curr.id.client) {\n        if (currClock !== 0) {\n          size++;\n          writeVarUint(encoder.restEncoder, currClient);\n          writeVarUint(encoder.restEncoder, currClock);\n        }\n        currClient = curr.id.client;\n        currClock = 0;\n        stopCounting = curr.id.clock !== 0;\n      }\n      if (curr.constructor === Skip) {\n        stopCounting = true;\n      }\n      if (!stopCounting) {\n        currClock = curr.id.clock + curr.length;\n      }\n    }\n    if (currClock !== 0) {\n      size++;\n      writeVarUint(encoder.restEncoder, currClient);\n      writeVarUint(encoder.restEncoder, currClock);\n    }\n    const enc = createEncoder();\n    writeVarUint(enc, size);\n    writeBinaryEncoder(enc, encoder.restEncoder);\n    encoder.restEncoder = enc;\n    return encoder.toUint8Array();\n  } else {\n    writeVarUint(encoder.restEncoder, 0);\n    return encoder.toUint8Array();\n  }\n};\nvar encodeStateVectorFromUpdate = (update) => encodeStateVectorFromUpdateV2(update, DSEncoderV1, UpdateDecoderV1);\nvar parseUpdateMetaV2 = (update, YDecoder = UpdateDecoderV2) => {\n  const from3 = /* @__PURE__ */ new Map();\n  const to = /* @__PURE__ */ new Map();\n  const updateDecoder = new LazyStructReader(new YDecoder(createDecoder(update)), false);\n  let curr = updateDecoder.curr;\n  if (curr !== null) {\n    let currClient = curr.id.client;\n    let currClock = curr.id.clock;\n    from3.set(currClient, currClock);\n    for (; curr !== null; curr = updateDecoder.next()) {\n      if (currClient !== curr.id.client) {\n        to.set(currClient, currClock);\n        from3.set(curr.id.client, curr.id.clock);\n        currClient = curr.id.client;\n      }\n      currClock = curr.id.clock + curr.length;\n    }\n    to.set(currClient, currClock);\n  }\n  return { from: from3, to };\n};\nvar parseUpdateMeta = (update) => parseUpdateMetaV2(update, UpdateDecoderV1);\nvar sliceStruct = (left, diff) => {\n  if (left.constructor === GC) {\n    const { client, clock } = left.id;\n    return new GC(createID(client, clock + diff), left.length - diff);\n  } else if (left.constructor === Skip) {\n    const { client, clock } = left.id;\n    return new Skip(createID(client, clock + diff), left.length - diff);\n  } else {\n    const leftItem = (\n      /** @type {Item} */\n      left\n    );\n    const { client, clock } = leftItem.id;\n    return new Item(\n      createID(client, clock + diff),\n      null,\n      createID(client, clock + diff - 1),\n      null,\n      leftItem.rightOrigin,\n      leftItem.parent,\n      leftItem.parentSub,\n      leftItem.content.splice(diff)\n    );\n  }\n};\nvar mergeUpdatesV2 = (updates, YDecoder = UpdateDecoderV2, YEncoder = UpdateEncoderV2) => {\n  if (updates.length === 1) {\n    return updates[0];\n  }\n  const updateDecoders = updates.map((update) => new YDecoder(createDecoder(update)));\n  let lazyStructDecoders = updateDecoders.map((decoder) => new LazyStructReader(decoder, true));\n  let currWrite = null;\n  const updateEncoder = new YEncoder();\n  const lazyStructEncoder = new LazyStructWriter(updateEncoder);\n  while (true) {\n    lazyStructDecoders = lazyStructDecoders.filter((dec) => dec.curr !== null);\n    lazyStructDecoders.sort(\n      /** @type {function(any,any):number} */\n      (dec1, dec2) => {\n        if (dec1.curr.id.client === dec2.curr.id.client) {\n          const clockDiff = dec1.curr.id.clock - dec2.curr.id.clock;\n          if (clockDiff === 0) {\n            return dec1.curr.constructor === dec2.curr.constructor ? 0 : dec1.curr.constructor === Skip ? 1 : -1;\n          } else {\n            return clockDiff;\n          }\n        } else {\n          return dec2.curr.id.client - dec1.curr.id.client;\n        }\n      }\n    );\n    if (lazyStructDecoders.length === 0) {\n      break;\n    }\n    const currDecoder = lazyStructDecoders[0];\n    const firstClient = (\n      /** @type {Item | GC} */\n      currDecoder.curr.id.client\n    );\n    if (currWrite !== null) {\n      let curr = (\n        /** @type {Item | GC | null} */\n        currDecoder.curr\n      );\n      let iterated = false;\n      while (curr !== null && curr.id.clock + curr.length <= currWrite.struct.id.clock + currWrite.struct.length && curr.id.client >= currWrite.struct.id.client) {\n        curr = currDecoder.next();\n        iterated = true;\n      }\n      if (curr === null || // current decoder is empty\n      curr.id.client !== firstClient || // check whether there is another decoder that has has updates from `firstClient`\n      iterated && curr.id.clock > currWrite.struct.id.clock + currWrite.struct.length) {\n        continue;\n      }\n      if (firstClient !== currWrite.struct.id.client) {\n        writeStructToLazyStructWriter(lazyStructEncoder, currWrite.struct, currWrite.offset);\n        currWrite = { struct: curr, offset: 0 };\n        currDecoder.next();\n      } else {\n        if (currWrite.struct.id.clock + currWrite.struct.length < curr.id.clock) {\n          if (currWrite.struct.constructor === Skip) {\n            currWrite.struct.length = curr.id.clock + curr.length - currWrite.struct.id.clock;\n          } else {\n            writeStructToLazyStructWriter(lazyStructEncoder, currWrite.struct, currWrite.offset);\n            const diff = curr.id.clock - currWrite.struct.id.clock - currWrite.struct.length;\n            const struct = new Skip(createID(firstClient, currWrite.struct.id.clock + currWrite.struct.length), diff);\n            currWrite = { struct, offset: 0 };\n          }\n        } else {\n          const diff = currWrite.struct.id.clock + currWrite.struct.length - curr.id.clock;\n          if (diff > 0) {\n            if (currWrite.struct.constructor === Skip) {\n              currWrite.struct.length -= diff;\n            } else {\n              curr = sliceStruct(curr, diff);\n            }\n          }\n          if (!currWrite.struct.mergeWith(\n            /** @type {any} */\n            curr\n          )) {\n            writeStructToLazyStructWriter(lazyStructEncoder, currWrite.struct, currWrite.offset);\n            currWrite = { struct: curr, offset: 0 };\n            currDecoder.next();\n          }\n        }\n      }\n    } else {\n      currWrite = { struct: (\n        /** @type {Item | GC} */\n        currDecoder.curr\n      ), offset: 0 };\n      currDecoder.next();\n    }\n    for (let next = currDecoder.curr; next !== null && next.id.client === firstClient && next.id.clock === currWrite.struct.id.clock + currWrite.struct.length && next.constructor !== Skip; next = currDecoder.next()) {\n      writeStructToLazyStructWriter(lazyStructEncoder, currWrite.struct, currWrite.offset);\n      currWrite = { struct: next, offset: 0 };\n    }\n  }\n  if (currWrite !== null) {\n    writeStructToLazyStructWriter(lazyStructEncoder, currWrite.struct, currWrite.offset);\n    currWrite = null;\n  }\n  finishLazyStructWriting(lazyStructEncoder);\n  const dss = updateDecoders.map((decoder) => readDeleteSet(decoder));\n  const ds = mergeDeleteSets(dss);\n  writeDeleteSet(updateEncoder, ds);\n  return updateEncoder.toUint8Array();\n};\nvar diffUpdateV2 = (update, sv, YDecoder = UpdateDecoderV2, YEncoder = UpdateEncoderV2) => {\n  const state = decodeStateVector(sv);\n  const encoder = new YEncoder();\n  const lazyStructWriter = new LazyStructWriter(encoder);\n  const decoder = new YDecoder(createDecoder(update));\n  const reader = new LazyStructReader(decoder, false);\n  while (reader.curr) {\n    const curr = reader.curr;\n    const currClient = curr.id.client;\n    const svClock = state.get(currClient) || 0;\n    if (reader.curr.constructor === Skip) {\n      reader.next();\n      continue;\n    }\n    if (curr.id.clock + curr.length > svClock) {\n      writeStructToLazyStructWriter(lazyStructWriter, curr, max(svClock - curr.id.clock, 0));\n      reader.next();\n      while (reader.curr && reader.curr.id.client === currClient) {\n        writeStructToLazyStructWriter(lazyStructWriter, reader.curr, 0);\n        reader.next();\n      }\n    } else {\n      while (reader.curr && reader.curr.id.client === currClient && reader.curr.id.clock + reader.curr.length <= svClock) {\n        reader.next();\n      }\n    }\n  }\n  finishLazyStructWriting(lazyStructWriter);\n  const ds = readDeleteSet(decoder);\n  writeDeleteSet(encoder, ds);\n  return encoder.toUint8Array();\n};\nvar diffUpdate = (update, sv) => diffUpdateV2(update, sv, UpdateDecoderV1, UpdateEncoderV1);\nvar flushLazyStructWriter = (lazyWriter) => {\n  if (lazyWriter.written > 0) {\n    lazyWriter.clientStructs.push({ written: lazyWriter.written, restEncoder: toUint8Array(lazyWriter.encoder.restEncoder) });\n    lazyWriter.encoder.restEncoder = createEncoder();\n    lazyWriter.written = 0;\n  }\n};\nvar writeStructToLazyStructWriter = (lazyWriter, struct, offset) => {\n  if (lazyWriter.written > 0 && lazyWriter.currClient !== struct.id.client) {\n    flushLazyStructWriter(lazyWriter);\n  }\n  if (lazyWriter.written === 0) {\n    lazyWriter.currClient = struct.id.client;\n    lazyWriter.encoder.writeClient(struct.id.client);\n    writeVarUint(lazyWriter.encoder.restEncoder, struct.id.clock + offset);\n  }\n  struct.write(lazyWriter.encoder, offset);\n  lazyWriter.written++;\n};\nvar finishLazyStructWriting = (lazyWriter) => {\n  flushLazyStructWriter(lazyWriter);\n  const restEncoder = lazyWriter.encoder.restEncoder;\n  writeVarUint(restEncoder, lazyWriter.clientStructs.length);\n  for (let i = 0; i < lazyWriter.clientStructs.length; i++) {\n    const partStructs = lazyWriter.clientStructs[i];\n    writeVarUint(restEncoder, partStructs.written);\n    writeUint8Array(restEncoder, partStructs.restEncoder);\n  }\n};\nvar convertUpdateFormat = (update, blockTransformer, YDecoder, YEncoder) => {\n  const updateDecoder = new YDecoder(createDecoder(update));\n  const lazyDecoder = new LazyStructReader(updateDecoder, false);\n  const updateEncoder = new YEncoder();\n  const lazyWriter = new LazyStructWriter(updateEncoder);\n  for (let curr = lazyDecoder.curr; curr !== null; curr = lazyDecoder.next()) {\n    writeStructToLazyStructWriter(lazyWriter, blockTransformer(curr), 0);\n  }\n  finishLazyStructWriting(lazyWriter);\n  const ds = readDeleteSet(updateDecoder);\n  writeDeleteSet(updateEncoder, ds);\n  return updateEncoder.toUint8Array();\n};\nvar createObfuscator = ({ formatting = true, subdocs = true, yxml = true } = {}) => {\n  let i = 0;\n  const mapKeyCache = create();\n  const nodeNameCache = create();\n  const formattingKeyCache = create();\n  const formattingValueCache = create();\n  formattingValueCache.set(null, null);\n  return (block) => {\n    switch (block.constructor) {\n      case GC:\n      case Skip:\n        return block;\n      case Item: {\n        const item = (\n          /** @type {Item} */\n          block\n        );\n        const content = item.content;\n        switch (content.constructor) {\n          case ContentDeleted:\n            break;\n          case ContentType: {\n            if (yxml) {\n              const type = (\n                /** @type {ContentType} */\n                content.type\n              );\n              if (type instanceof YXmlElement) {\n                type.nodeName = setIfUndefined(nodeNameCache, type.nodeName, () => \"node-\" + i);\n              }\n              if (type instanceof YXmlHook) {\n                type.hookName = setIfUndefined(nodeNameCache, type.hookName, () => \"hook-\" + i);\n              }\n            }\n            break;\n          }\n          case ContentAny: {\n            const c = (\n              /** @type {ContentAny} */\n              content\n            );\n            c.arr = c.arr.map(() => i);\n            break;\n          }\n          case ContentBinary: {\n            const c = (\n              /** @type {ContentBinary} */\n              content\n            );\n            c.content = new Uint8Array([i]);\n            break;\n          }\n          case ContentDoc: {\n            const c = (\n              /** @type {ContentDoc} */\n              content\n            );\n            if (subdocs) {\n              c.opts = {};\n              c.doc.guid = i + \"\";\n            }\n            break;\n          }\n          case ContentEmbed: {\n            const c = (\n              /** @type {ContentEmbed} */\n              content\n            );\n            c.embed = {};\n            break;\n          }\n          case ContentFormat: {\n            const c = (\n              /** @type {ContentFormat} */\n              content\n            );\n            if (formatting) {\n              c.key = setIfUndefined(formattingKeyCache, c.key, () => i + \"\");\n              c.value = setIfUndefined(formattingValueCache, c.value, () => ({ i }));\n            }\n            break;\n          }\n          case ContentJSON: {\n            const c = (\n              /** @type {ContentJSON} */\n              content\n            );\n            c.arr = c.arr.map(() => i);\n            break;\n          }\n          case ContentString: {\n            const c = (\n              /** @type {ContentString} */\n              content\n            );\n            c.str = repeat(i % 10 + \"\", c.str.length);\n            break;\n          }\n          default:\n            unexpectedCase();\n        }\n        if (item.parentSub) {\n          item.parentSub = setIfUndefined(mapKeyCache, item.parentSub, () => i + \"\");\n        }\n        i++;\n        return block;\n      }\n      default:\n        unexpectedCase();\n    }\n  };\n};\nvar obfuscateUpdate = (update, opts) => convertUpdateFormat(update, createObfuscator(opts), UpdateDecoderV1, UpdateEncoderV1);\nvar obfuscateUpdateV2 = (update, opts) => convertUpdateFormat(update, createObfuscator(opts), UpdateDecoderV2, UpdateEncoderV2);\nvar convertUpdateFormatV1ToV2 = (update) => convertUpdateFormat(update, id, UpdateDecoderV1, UpdateEncoderV2);\nvar convertUpdateFormatV2ToV1 = (update) => convertUpdateFormat(update, id, UpdateDecoderV2, UpdateEncoderV1);\nvar errorComputeChanges = \"You must not compute changes after the event-handler fired.\";\nvar YEvent = class {\n  /**\n   * @param {T} target The changed type.\n   * @param {Transaction} transaction\n   */\n  constructor(target, transaction) {\n    this.target = target;\n    this.currentTarget = target;\n    this.transaction = transaction;\n    this._changes = null;\n    this._keys = null;\n    this._delta = null;\n    this._path = null;\n  }\n  /**\n   * Computes the path from `y` to the changed type.\n   *\n   * @todo v14 should standardize on path: Array<{parent, index}> because that is easier to work with.\n   *\n   * The following property holds:\n   * @example\n   *   let type = y\n   *   event.path.forEach(dir => {\n   *     type = type.get(dir)\n   *   })\n   *   type === event.target // => true\n   */\n  get path() {\n    return this._path || (this._path = getPathTo(this.currentTarget, this.target));\n  }\n  /**\n   * Check if a struct is deleted by this event.\n   *\n   * In contrast to change.deleted, this method also returns true if the struct was added and then deleted.\n   *\n   * @param {AbstractStruct} struct\n   * @return {boolean}\n   */\n  deletes(struct) {\n    return isDeleted(this.transaction.deleteSet, struct.id);\n  }\n  /**\n   * @type {Map<string, { action: 'add' | 'update' | 'delete', oldValue: any, newValue: any }>}\n   */\n  get keys() {\n    if (this._keys === null) {\n      if (this.transaction.doc._transactionCleanups.length === 0) {\n        throw create3(errorComputeChanges);\n      }\n      const keys2 = /* @__PURE__ */ new Map();\n      const target = this.target;\n      const changed = (\n        /** @type Set<string|null> */\n        this.transaction.changed.get(target)\n      );\n      changed.forEach((key) => {\n        if (key !== null) {\n          const item = (\n            /** @type {Item} */\n            target._map.get(key)\n          );\n          let action;\n          let oldValue;\n          if (this.adds(item)) {\n            let prev = item.left;\n            while (prev !== null && this.adds(prev)) {\n              prev = prev.left;\n            }\n            if (this.deletes(item)) {\n              if (prev !== null && this.deletes(prev)) {\n                action = \"delete\";\n                oldValue = last(prev.content.getContent());\n              } else {\n                return;\n              }\n            } else {\n              if (prev !== null && this.deletes(prev)) {\n                action = \"update\";\n                oldValue = last(prev.content.getContent());\n              } else {\n                action = \"add\";\n                oldValue = void 0;\n              }\n            }\n          } else {\n            if (this.deletes(item)) {\n              action = \"delete\";\n              oldValue = last(\n                /** @type {Item} */\n                item.content.getContent()\n              );\n            } else {\n              return;\n            }\n          }\n          keys2.set(key, { action, oldValue });\n        }\n      });\n      this._keys = keys2;\n    }\n    return this._keys;\n  }\n  /**\n   * This is a computed property. Note that this can only be safely computed during the\n   * event call. Computing this property after other changes happened might result in\n   * unexpected behavior (incorrect computation of deltas). A safe way to collect changes\n   * is to store the `changes` or the `delta` object. Avoid storing the `transaction` object.\n   *\n   * @type {Array<{insert?: string | Array<any> | object | AbstractType<any>, retain?: number, delete?: number, attributes?: Object<string, any>}>}\n   */\n  get delta() {\n    return this.changes.delta;\n  }\n  /**\n   * Check if a struct is added by this event.\n   *\n   * In contrast to change.deleted, this method also returns true if the struct was added and then deleted.\n   *\n   * @param {AbstractStruct} struct\n   * @return {boolean}\n   */\n  adds(struct) {\n    return struct.id.clock >= (this.transaction.beforeState.get(struct.id.client) || 0);\n  }\n  /**\n   * This is a computed property. Note that this can only be safely computed during the\n   * event call. Computing this property after other changes happened might result in\n   * unexpected behavior (incorrect computation of deltas). A safe way to collect changes\n   * is to store the `changes` or the `delta` object. Avoid storing the `transaction` object.\n   *\n   * @type {{added:Set<Item>,deleted:Set<Item>,keys:Map<string,{action:'add'|'update'|'delete',oldValue:any}>,delta:Array<{insert?:Array<any>|string, delete?:number, retain?:number}>}}\n   */\n  get changes() {\n    let changes = this._changes;\n    if (changes === null) {\n      if (this.transaction.doc._transactionCleanups.length === 0) {\n        throw create3(errorComputeChanges);\n      }\n      const target = this.target;\n      const added = create2();\n      const deleted = create2();\n      const delta = [];\n      changes = {\n        added,\n        deleted,\n        delta,\n        keys: this.keys\n      };\n      const changed = (\n        /** @type Set<string|null> */\n        this.transaction.changed.get(target)\n      );\n      if (changed.has(null)) {\n        let lastOp = null;\n        const packOp = () => {\n          if (lastOp) {\n            delta.push(lastOp);\n          }\n        };\n        for (let item = target._start; item !== null; item = item.right) {\n          if (item.deleted) {\n            if (this.deletes(item) && !this.adds(item)) {\n              if (lastOp === null || lastOp.delete === void 0) {\n                packOp();\n                lastOp = { delete: 0 };\n              }\n              lastOp.delete += item.length;\n              deleted.add(item);\n            }\n          } else {\n            if (this.adds(item)) {\n              if (lastOp === null || lastOp.insert === void 0) {\n                packOp();\n                lastOp = { insert: [] };\n              }\n              lastOp.insert = lastOp.insert.concat(item.content.getContent());\n              added.add(item);\n            } else {\n              if (lastOp === null || lastOp.retain === void 0) {\n                packOp();\n                lastOp = { retain: 0 };\n              }\n              lastOp.retain += item.length;\n            }\n          }\n        }\n        if (lastOp !== null && lastOp.retain === void 0) {\n          packOp();\n        }\n      }\n      this._changes = changes;\n    }\n    return (\n      /** @type {any} */\n      changes\n    );\n  }\n};\nvar getPathTo = (parent, child) => {\n  const path = [];\n  while (child._item !== null && child !== parent) {\n    if (child._item.parentSub !== null) {\n      path.unshift(child._item.parentSub);\n    } else {\n      let i = 0;\n      let c = (\n        /** @type {AbstractType<any>} */\n        child._item.parent._start\n      );\n      while (c !== child._item && c !== null) {\n        if (!c.deleted) {\n          i++;\n        }\n        c = c.right;\n      }\n      path.unshift(i);\n    }\n    child = /** @type {AbstractType<any>} */\n    child._item.parent;\n  }\n  return path;\n};\nvar maxSearchMarker = 80;\nvar globalSearchMarkerTimestamp = 0;\nvar ArraySearchMarker = class {\n  /**\n   * @param {Item} p\n   * @param {number} index\n   */\n  constructor(p, index) {\n    p.marker = true;\n    this.p = p;\n    this.index = index;\n    this.timestamp = globalSearchMarkerTimestamp++;\n  }\n};\nvar refreshMarkerTimestamp = (marker) => {\n  marker.timestamp = globalSearchMarkerTimestamp++;\n};\nvar overwriteMarker = (marker, p, index) => {\n  marker.p.marker = false;\n  marker.p = p;\n  p.marker = true;\n  marker.index = index;\n  marker.timestamp = globalSearchMarkerTimestamp++;\n};\nvar markPosition = (searchMarker, p, index) => {\n  if (searchMarker.length >= maxSearchMarker) {\n    const marker = searchMarker.reduce((a, b) => a.timestamp < b.timestamp ? a : b);\n    overwriteMarker(marker, p, index);\n    return marker;\n  } else {\n    const pm = new ArraySearchMarker(p, index);\n    searchMarker.push(pm);\n    return pm;\n  }\n};\nvar findMarker = (yarray, index) => {\n  if (yarray._start === null || index === 0 || yarray._searchMarker === null) {\n    return null;\n  }\n  const marker = yarray._searchMarker.length === 0 ? null : yarray._searchMarker.reduce((a, b) => abs(index - a.index) < abs(index - b.index) ? a : b);\n  let p = yarray._start;\n  let pindex = 0;\n  if (marker !== null) {\n    p = marker.p;\n    pindex = marker.index;\n    refreshMarkerTimestamp(marker);\n  }\n  while (p.right !== null && pindex < index) {\n    if (!p.deleted && p.countable) {\n      if (index < pindex + p.length) {\n        break;\n      }\n      pindex += p.length;\n    }\n    p = p.right;\n  }\n  while (p.left !== null && pindex > index) {\n    p = p.left;\n    if (!p.deleted && p.countable) {\n      pindex -= p.length;\n    }\n  }\n  while (p.left !== null && p.left.id.client === p.id.client && p.left.id.clock + p.left.length === p.id.clock) {\n    p = p.left;\n    if (!p.deleted && p.countable) {\n      pindex -= p.length;\n    }\n  }\n  if (marker !== null && abs(marker.index - pindex) < /** @type {YText|YArray<any>} */\n  p.parent.length / maxSearchMarker) {\n    overwriteMarker(marker, p, pindex);\n    return marker;\n  } else {\n    return markPosition(yarray._searchMarker, p, pindex);\n  }\n};\nvar updateMarkerChanges = (searchMarker, index, len) => {\n  for (let i = searchMarker.length - 1; i >= 0; i--) {\n    const m = searchMarker[i];\n    if (len > 0) {\n      let p = m.p;\n      p.marker = false;\n      while (p && (p.deleted || !p.countable)) {\n        p = p.left;\n        if (p && !p.deleted && p.countable) {\n          m.index -= p.length;\n        }\n      }\n      if (p === null || p.marker === true) {\n        searchMarker.splice(i, 1);\n        continue;\n      }\n      m.p = p;\n      p.marker = true;\n    }\n    if (index < m.index || len > 0 && index === m.index) {\n      m.index = max(index, m.index + len);\n    }\n  }\n};\nvar getTypeChildren = (t) => {\n  let s = t._start;\n  const arr = [];\n  while (s) {\n    arr.push(s);\n    s = s.right;\n  }\n  return arr;\n};\nvar callTypeObservers = (type, transaction, event) => {\n  const changedType = type;\n  const changedParentTypes = transaction.changedParentTypes;\n  while (true) {\n    setIfUndefined(changedParentTypes, type, () => []).push(event);\n    if (type._item === null) {\n      break;\n    }\n    type = /** @type {AbstractType<any>} */\n    type._item.parent;\n  }\n  callEventHandlerListeners(changedType._eH, event, transaction);\n};\nvar AbstractType = class {\n  constructor() {\n    this._item = null;\n    this._map = /* @__PURE__ */ new Map();\n    this._start = null;\n    this.doc = null;\n    this._length = 0;\n    this._eH = createEventHandler();\n    this._dEH = createEventHandler();\n    this._searchMarker = null;\n  }\n  /**\n   * @return {AbstractType<any>|null}\n   */\n  get parent() {\n    return this._item ? (\n      /** @type {AbstractType<any>} */\n      this._item.parent\n    ) : null;\n  }\n  /**\n   * Integrate this type into the Yjs instance.\n   *\n   * * Save this struct in the os\n   * * This type is sent to other client\n   * * Observer functions are fired\n   *\n   * @param {Doc} y The Yjs instance\n   * @param {Item|null} item\n   */\n  _integrate(y, item) {\n    this.doc = y;\n    this._item = item;\n  }\n  /**\n   * @return {AbstractType<EventType>}\n   */\n  _copy() {\n    throw methodUnimplemented();\n  }\n  /**\n   * @return {AbstractType<EventType>}\n   */\n  clone() {\n    throw methodUnimplemented();\n  }\n  /**\n   * @param {UpdateEncoderV1 | UpdateEncoderV2} _encoder\n   */\n  _write(_encoder) {\n  }\n  /**\n   * The first non-deleted item\n   */\n  get _first() {\n    let n = this._start;\n    while (n !== null && n.deleted) {\n      n = n.right;\n    }\n    return n;\n  }\n  /**\n   * Creates YEvent and calls all type observers.\n   * Must be implemented by each type.\n   *\n   * @param {Transaction} transaction\n   * @param {Set<null|string>} _parentSubs Keys changed on this type. `null` if list was modified.\n   */\n  _callObserver(transaction, _parentSubs) {\n    if (!transaction.local && this._searchMarker) {\n      this._searchMarker.length = 0;\n    }\n  }\n  /**\n   * Observe all events that are created on this type.\n   *\n   * @param {function(EventType, Transaction):void} f Observer function\n   */\n  observe(f) {\n    addEventHandlerListener(this._eH, f);\n  }\n  /**\n   * Observe all events that are created by this type and its children.\n   *\n   * @param {function(Array<YEvent<any>>,Transaction):void} f Observer function\n   */\n  observeDeep(f) {\n    addEventHandlerListener(this._dEH, f);\n  }\n  /**\n   * Unregister an observer function.\n   *\n   * @param {function(EventType,Transaction):void} f Observer function\n   */\n  unobserve(f) {\n    removeEventHandlerListener(this._eH, f);\n  }\n  /**\n   * Unregister an observer function.\n   *\n   * @param {function(Array<YEvent<any>>,Transaction):void} f Observer function\n   */\n  unobserveDeep(f) {\n    removeEventHandlerListener(this._dEH, f);\n  }\n  /**\n   * @abstract\n   * @return {any}\n   */\n  toJSON() {\n  }\n};\nvar typeListSlice = (type, start, end) => {\n  if (start < 0) {\n    start = type._length + start;\n  }\n  if (end < 0) {\n    end = type._length + end;\n  }\n  let len = end - start;\n  const cs = [];\n  let n = type._start;\n  while (n !== null && len > 0) {\n    if (n.countable && !n.deleted) {\n      const c = n.content.getContent();\n      if (c.length <= start) {\n        start -= c.length;\n      } else {\n        for (let i = start; i < c.length && len > 0; i++) {\n          cs.push(c[i]);\n          len--;\n        }\n        start = 0;\n      }\n    }\n    n = n.right;\n  }\n  return cs;\n};\nvar typeListToArray = (type) => {\n  const cs = [];\n  let n = type._start;\n  while (n !== null) {\n    if (n.countable && !n.deleted) {\n      const c = n.content.getContent();\n      for (let i = 0; i < c.length; i++) {\n        cs.push(c[i]);\n      }\n    }\n    n = n.right;\n  }\n  return cs;\n};\nvar typeListToArraySnapshot = (type, snapshot2) => {\n  const cs = [];\n  let n = type._start;\n  while (n !== null) {\n    if (n.countable && isVisible(n, snapshot2)) {\n      const c = n.content.getContent();\n      for (let i = 0; i < c.length; i++) {\n        cs.push(c[i]);\n      }\n    }\n    n = n.right;\n  }\n  return cs;\n};\nvar typeListForEach = (type, f) => {\n  let index = 0;\n  let n = type._start;\n  while (n !== null) {\n    if (n.countable && !n.deleted) {\n      const c = n.content.getContent();\n      for (let i = 0; i < c.length; i++) {\n        f(c[i], index++, type);\n      }\n    }\n    n = n.right;\n  }\n};\nvar typeListMap = (type, f) => {\n  const result = [];\n  typeListForEach(type, (c, i) => {\n    result.push(f(c, i, type));\n  });\n  return result;\n};\nvar typeListCreateIterator = (type) => {\n  let n = type._start;\n  let currentContent = null;\n  let currentContentIndex = 0;\n  return {\n    [Symbol.iterator]() {\n      return this;\n    },\n    next: () => {\n      if (currentContent === null) {\n        while (n !== null && n.deleted) {\n          n = n.right;\n        }\n        if (n === null) {\n          return {\n            done: true,\n            value: void 0\n          };\n        }\n        currentContent = n.content.getContent();\n        currentContentIndex = 0;\n        n = n.right;\n      }\n      const value = currentContent[currentContentIndex++];\n      if (currentContent.length <= currentContentIndex) {\n        currentContent = null;\n      }\n      return {\n        done: false,\n        value\n      };\n    }\n  };\n};\nvar typeListGet = (type, index) => {\n  const marker = findMarker(type, index);\n  let n = type._start;\n  if (marker !== null) {\n    n = marker.p;\n    index -= marker.index;\n  }\n  for (; n !== null; n = n.right) {\n    if (!n.deleted && n.countable) {\n      if (index < n.length) {\n        return n.content.getContent()[index];\n      }\n      index -= n.length;\n    }\n  }\n};\nvar typeListInsertGenericsAfter = (transaction, parent, referenceItem, content) => {\n  let left = referenceItem;\n  const doc2 = transaction.doc;\n  const ownClientId = doc2.clientID;\n  const store = doc2.store;\n  const right = referenceItem === null ? parent._start : referenceItem.right;\n  let jsonContent = [];\n  const packJsonContent = () => {\n    if (jsonContent.length > 0) {\n      left = new Item(createID(ownClientId, getState(store, ownClientId)), left, left && left.lastId, right, right && right.id, parent, null, new ContentAny(jsonContent));\n      left.integrate(transaction, 0);\n      jsonContent = [];\n    }\n  };\n  content.forEach((c) => {\n    if (c === null) {\n      jsonContent.push(c);\n    } else {\n      switch (c.constructor) {\n        case Number:\n        case Object:\n        case Boolean:\n        case Array:\n        case String:\n          jsonContent.push(c);\n          break;\n        default:\n          packJsonContent();\n          switch (c.constructor) {\n            case Uint8Array:\n            case ArrayBuffer:\n              left = new Item(createID(ownClientId, getState(store, ownClientId)), left, left && left.lastId, right, right && right.id, parent, null, new ContentBinary(new Uint8Array(\n                /** @type {Uint8Array} */\n                c\n              )));\n              left.integrate(transaction, 0);\n              break;\n            case Doc:\n              left = new Item(createID(ownClientId, getState(store, ownClientId)), left, left && left.lastId, right, right && right.id, parent, null, new ContentDoc(\n                /** @type {Doc} */\n                c\n              ));\n              left.integrate(transaction, 0);\n              break;\n            default:\n              if (c instanceof AbstractType) {\n                left = new Item(createID(ownClientId, getState(store, ownClientId)), left, left && left.lastId, right, right && right.id, parent, null, new ContentType(c));\n                left.integrate(transaction, 0);\n              } else {\n                throw new Error(\"Unexpected content type in insert operation\");\n              }\n          }\n      }\n    }\n  });\n  packJsonContent();\n};\nvar lengthExceeded = create3(\"Length exceeded!\");\nvar typeListInsertGenerics = (transaction, parent, index, content) => {\n  if (index > parent._length) {\n    throw lengthExceeded;\n  }\n  if (index === 0) {\n    if (parent._searchMarker) {\n      updateMarkerChanges(parent._searchMarker, index, content.length);\n    }\n    return typeListInsertGenericsAfter(transaction, parent, null, content);\n  }\n  const startIndex = index;\n  const marker = findMarker(parent, index);\n  let n = parent._start;\n  if (marker !== null) {\n    n = marker.p;\n    index -= marker.index;\n    if (index === 0) {\n      n = n.prev;\n      index += n && n.countable && !n.deleted ? n.length : 0;\n    }\n  }\n  for (; n !== null; n = n.right) {\n    if (!n.deleted && n.countable) {\n      if (index <= n.length) {\n        if (index < n.length) {\n          getItemCleanStart(transaction, createID(n.id.client, n.id.clock + index));\n        }\n        break;\n      }\n      index -= n.length;\n    }\n  }\n  if (parent._searchMarker) {\n    updateMarkerChanges(parent._searchMarker, startIndex, content.length);\n  }\n  return typeListInsertGenericsAfter(transaction, parent, n, content);\n};\nvar typeListPushGenerics = (transaction, parent, content) => {\n  const marker = (parent._searchMarker || []).reduce((maxMarker, currMarker) => currMarker.index > maxMarker.index ? currMarker : maxMarker, { index: 0, p: parent._start });\n  let n = marker.p;\n  if (n) {\n    while (n.right) {\n      n = n.right;\n    }\n  }\n  return typeListInsertGenericsAfter(transaction, parent, n, content);\n};\nvar typeListDelete = (transaction, parent, index, length3) => {\n  if (length3 === 0) {\n    return;\n  }\n  const startIndex = index;\n  const startLength = length3;\n  const marker = findMarker(parent, index);\n  let n = parent._start;\n  if (marker !== null) {\n    n = marker.p;\n    index -= marker.index;\n  }\n  for (; n !== null && index > 0; n = n.right) {\n    if (!n.deleted && n.countable) {\n      if (index < n.length) {\n        getItemCleanStart(transaction, createID(n.id.client, n.id.clock + index));\n      }\n      index -= n.length;\n    }\n  }\n  while (length3 > 0 && n !== null) {\n    if (!n.deleted) {\n      if (length3 < n.length) {\n        getItemCleanStart(transaction, createID(n.id.client, n.id.clock + length3));\n      }\n      n.delete(transaction);\n      length3 -= n.length;\n    }\n    n = n.right;\n  }\n  if (length3 > 0) {\n    throw lengthExceeded;\n  }\n  if (parent._searchMarker) {\n    updateMarkerChanges(\n      parent._searchMarker,\n      startIndex,\n      -startLength + length3\n      /* in case we remove the above exception */\n    );\n  }\n};\nvar typeMapDelete = (transaction, parent, key) => {\n  const c = parent._map.get(key);\n  if (c !== void 0) {\n    c.delete(transaction);\n  }\n};\nvar typeMapSet = (transaction, parent, key, value) => {\n  const left = parent._map.get(key) || null;\n  const doc2 = transaction.doc;\n  const ownClientId = doc2.clientID;\n  let content;\n  if (value == null) {\n    content = new ContentAny([value]);\n  } else {\n    switch (value.constructor) {\n      case Number:\n      case Object:\n      case Boolean:\n      case Array:\n      case String:\n        content = new ContentAny([value]);\n        break;\n      case Uint8Array:\n        content = new ContentBinary(\n          /** @type {Uint8Array} */\n          value\n        );\n        break;\n      case Doc:\n        content = new ContentDoc(\n          /** @type {Doc} */\n          value\n        );\n        break;\n      default:\n        if (value instanceof AbstractType) {\n          content = new ContentType(value);\n        } else {\n          throw new Error(\"Unexpected content type\");\n        }\n    }\n  }\n  new Item(createID(ownClientId, getState(doc2.store, ownClientId)), left, left && left.lastId, null, null, parent, key, content).integrate(transaction, 0);\n};\nvar typeMapGet = (parent, key) => {\n  const val = parent._map.get(key);\n  return val !== void 0 && !val.deleted ? val.content.getContent()[val.length - 1] : void 0;\n};\nvar typeMapGetAll = (parent) => {\n  const res = {};\n  parent._map.forEach((value, key) => {\n    if (!value.deleted) {\n      res[key] = value.content.getContent()[value.length - 1];\n    }\n  });\n  return res;\n};\nvar typeMapHas = (parent, key) => {\n  const val = parent._map.get(key);\n  return val !== void 0 && !val.deleted;\n};\nvar typeMapGetSnapshot = (parent, key, snapshot2) => {\n  let v = parent._map.get(key) || null;\n  while (v !== null && (!snapshot2.sv.has(v.id.client) || v.id.clock >= (snapshot2.sv.get(v.id.client) || 0))) {\n    v = v.left;\n  }\n  return v !== null && isVisible(v, snapshot2) ? v.content.getContent()[v.length - 1] : void 0;\n};\nvar createMapIterator = (map3) => iteratorFilter(\n  map3.entries(),\n  /** @param {any} entry */\n  (entry) => !entry[1].deleted\n);\nvar YArrayEvent = class extends YEvent {\n  /**\n   * @param {YArray<T>} yarray The changed type\n   * @param {Transaction} transaction The transaction object\n   */\n  constructor(yarray, transaction) {\n    super(yarray, transaction);\n    this._transaction = transaction;\n  }\n};\nvar YArray = class _YArray extends AbstractType {\n  constructor() {\n    super();\n    this._prelimContent = [];\n    this._searchMarker = [];\n  }\n  /**\n   * Construct a new YArray containing the specified items.\n   * @template {Object<string,any>|Array<any>|number|null|string|Uint8Array} T\n   * @param {Array<T>} items\n   * @return {YArray<T>}\n   */\n  static from(items) {\n    const a = new _YArray();\n    a.push(items);\n    return a;\n  }\n  /**\n   * Integrate this type into the Yjs instance.\n   *\n   * * Save this struct in the os\n   * * This type is sent to other client\n   * * Observer functions are fired\n   *\n   * @param {Doc} y The Yjs instance\n   * @param {Item} item\n   */\n  _integrate(y, item) {\n    super._integrate(y, item);\n    this.insert(\n      0,\n      /** @type {Array<any>} */\n      this._prelimContent\n    );\n    this._prelimContent = null;\n  }\n  /**\n   * @return {YArray<T>}\n   */\n  _copy() {\n    return new _YArray();\n  }\n  /**\n   * @return {YArray<T>}\n   */\n  clone() {\n    const arr = new _YArray();\n    arr.insert(0, this.toArray().map(\n      (el) => el instanceof AbstractType ? (\n        /** @type {typeof el} */\n        el.clone()\n      ) : el\n    ));\n    return arr;\n  }\n  get length() {\n    return this._prelimContent === null ? this._length : this._prelimContent.length;\n  }\n  /**\n   * Creates YArrayEvent and calls observers.\n   *\n   * @param {Transaction} transaction\n   * @param {Set<null|string>} parentSubs Keys changed on this type. `null` if list was modified.\n   */\n  _callObserver(transaction, parentSubs) {\n    super._callObserver(transaction, parentSubs);\n    callTypeObservers(this, transaction, new YArrayEvent(this, transaction));\n  }\n  /**\n   * Inserts new content at an index.\n   *\n   * Important: This function expects an array of content. Not just a content\n   * object. The reason for this \"weirdness\" is that inserting several elements\n   * is very efficient when it is done as a single operation.\n   *\n   * @example\n   *  // Insert character 'a' at position 0\n   *  yarray.insert(0, ['a'])\n   *  // Insert numbers 1, 2 at position 1\n   *  yarray.insert(1, [1, 2])\n   *\n   * @param {number} index The index to insert content at.\n   * @param {Array<T>} content The array of content\n   */\n  insert(index, content) {\n    if (this.doc !== null) {\n      transact(this.doc, (transaction) => {\n        typeListInsertGenerics(\n          transaction,\n          this,\n          index,\n          /** @type {any} */\n          content\n        );\n      });\n    } else {\n      this._prelimContent.splice(index, 0, ...content);\n    }\n  }\n  /**\n   * Appends content to this YArray.\n   *\n   * @param {Array<T>} content Array of content to append.\n   *\n   * @todo Use the following implementation in all types.\n   */\n  push(content) {\n    if (this.doc !== null) {\n      transact(this.doc, (transaction) => {\n        typeListPushGenerics(\n          transaction,\n          this,\n          /** @type {any} */\n          content\n        );\n      });\n    } else {\n      this._prelimContent.push(...content);\n    }\n  }\n  /**\n   * Preppends content to this YArray.\n   *\n   * @param {Array<T>} content Array of content to preppend.\n   */\n  unshift(content) {\n    this.insert(0, content);\n  }\n  /**\n   * Deletes elements starting from an index.\n   *\n   * @param {number} index Index at which to start deleting elements\n   * @param {number} length The number of elements to remove. Defaults to 1.\n   */\n  delete(index, length3 = 1) {\n    if (this.doc !== null) {\n      transact(this.doc, (transaction) => {\n        typeListDelete(transaction, this, index, length3);\n      });\n    } else {\n      this._prelimContent.splice(index, length3);\n    }\n  }\n  /**\n   * Returns the i-th element from a YArray.\n   *\n   * @param {number} index The index of the element to return from the YArray\n   * @return {T}\n   */\n  get(index) {\n    return typeListGet(this, index);\n  }\n  /**\n   * Transforms this YArray to a JavaScript Array.\n   *\n   * @return {Array<T>}\n   */\n  toArray() {\n    return typeListToArray(this);\n  }\n  /**\n   * Transforms this YArray to a JavaScript Array.\n   *\n   * @param {number} [start]\n   * @param {number} [end]\n   * @return {Array<T>}\n   */\n  slice(start = 0, end = this.length) {\n    return typeListSlice(this, start, end);\n  }\n  /**\n   * Transforms this Shared Type to a JSON object.\n   *\n   * @return {Array<any>}\n   */\n  toJSON() {\n    return this.map((c) => c instanceof AbstractType ? c.toJSON() : c);\n  }\n  /**\n   * Returns an Array with the result of calling a provided function on every\n   * element of this YArray.\n   *\n   * @template M\n   * @param {function(T,number,YArray<T>):M} f Function that produces an element of the new Array\n   * @return {Array<M>} A new array with each element being the result of the\n   *                 callback function\n   */\n  map(f) {\n    return typeListMap(\n      this,\n      /** @type {any} */\n      f\n    );\n  }\n  /**\n   * Executes a provided function once on overy element of this YArray.\n   *\n   * @param {function(T,number,YArray<T>):void} f A function to execute on every element of this YArray.\n   */\n  forEach(f) {\n    typeListForEach(this, f);\n  }\n  /**\n   * @return {IterableIterator<T>}\n   */\n  [Symbol.iterator]() {\n    return typeListCreateIterator(this);\n  }\n  /**\n   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder\n   */\n  _write(encoder) {\n    encoder.writeTypeRef(YArrayRefID);\n  }\n};\nvar readYArray = (_decoder) => new YArray();\nvar YMapEvent = class extends YEvent {\n  /**\n   * @param {YMap<T>} ymap The YArray that changed.\n   * @param {Transaction} transaction\n   * @param {Set<any>} subs The keys that changed.\n   */\n  constructor(ymap, transaction, subs) {\n    super(ymap, transaction);\n    this.keysChanged = subs;\n  }\n};\nvar YMap = class _YMap extends AbstractType {\n  /**\n   *\n   * @param {Iterable<readonly [string, any]>=} entries - an optional iterable to initialize the YMap\n   */\n  constructor(entries) {\n    super();\n    this._prelimContent = null;\n    if (entries === void 0) {\n      this._prelimContent = /* @__PURE__ */ new Map();\n    } else {\n      this._prelimContent = new Map(entries);\n    }\n  }\n  /**\n   * Integrate this type into the Yjs instance.\n   *\n   * * Save this struct in the os\n   * * This type is sent to other client\n   * * Observer functions are fired\n   *\n   * @param {Doc} y The Yjs instance\n   * @param {Item} item\n   */\n  _integrate(y, item) {\n    super._integrate(y, item);\n    this._prelimContent.forEach((value, key) => {\n      this.set(key, value);\n    });\n    this._prelimContent = null;\n  }\n  /**\n   * @return {YMap<MapType>}\n   */\n  _copy() {\n    return new _YMap();\n  }\n  /**\n   * @return {YMap<MapType>}\n   */\n  clone() {\n    const map3 = new _YMap();\n    this.forEach((value, key) => {\n      map3.set(key, value instanceof AbstractType ? (\n        /** @type {typeof value} */\n        value.clone()\n      ) : value);\n    });\n    return map3;\n  }\n  /**\n   * Creates YMapEvent and calls observers.\n   *\n   * @param {Transaction} transaction\n   * @param {Set<null|string>} parentSubs Keys changed on this type. `null` if list was modified.\n   */\n  _callObserver(transaction, parentSubs) {\n    callTypeObservers(this, transaction, new YMapEvent(this, transaction, parentSubs));\n  }\n  /**\n   * Transforms this Shared Type to a JSON object.\n   *\n   * @return {Object<string,any>}\n   */\n  toJSON() {\n    const map3 = {};\n    this._map.forEach((item, key) => {\n      if (!item.deleted) {\n        const v = item.content.getContent()[item.length - 1];\n        map3[key] = v instanceof AbstractType ? v.toJSON() : v;\n      }\n    });\n    return map3;\n  }\n  /**\n   * Returns the size of the YMap (count of key/value pairs)\n   *\n   * @return {number}\n   */\n  get size() {\n    return [...createMapIterator(this._map)].length;\n  }\n  /**\n   * Returns the keys for each element in the YMap Type.\n   *\n   * @return {IterableIterator<string>}\n   */\n  keys() {\n    return iteratorMap(\n      createMapIterator(this._map),\n      /** @param {any} v */\n      (v) => v[0]\n    );\n  }\n  /**\n   * Returns the values for each element in the YMap Type.\n   *\n   * @return {IterableIterator<any>}\n   */\n  values() {\n    return iteratorMap(\n      createMapIterator(this._map),\n      /** @param {any} v */\n      (v) => v[1].content.getContent()[v[1].length - 1]\n    );\n  }\n  /**\n   * Returns an Iterator of [key, value] pairs\n   *\n   * @return {IterableIterator<any>}\n   */\n  entries() {\n    return iteratorMap(\n      createMapIterator(this._map),\n      /** @param {any} v */\n      (v) => [v[0], v[1].content.getContent()[v[1].length - 1]]\n    );\n  }\n  /**\n   * Executes a provided function on once on every key-value pair.\n   *\n   * @param {function(MapType,string,YMap<MapType>):void} f A function to execute on every element of this YArray.\n   */\n  forEach(f) {\n    this._map.forEach((item, key) => {\n      if (!item.deleted) {\n        f(item.content.getContent()[item.length - 1], key, this);\n      }\n    });\n  }\n  /**\n   * Returns an Iterator of [key, value] pairs\n   *\n   * @return {IterableIterator<any>}\n   */\n  [Symbol.iterator]() {\n    return this.entries();\n  }\n  /**\n   * Remove a specified element from this YMap.\n   *\n   * @param {string} key The key of the element to remove.\n   */\n  delete(key) {\n    if (this.doc !== null) {\n      transact(this.doc, (transaction) => {\n        typeMapDelete(transaction, this, key);\n      });\n    } else {\n      this._prelimContent.delete(key);\n    }\n  }\n  /**\n   * Adds or updates an element with a specified key and value.\n   * @template {MapType} VAL\n   *\n   * @param {string} key The key of the element to add to this YMap\n   * @param {VAL} value The value of the element to add\n   * @return {VAL}\n   */\n  set(key, value) {\n    if (this.doc !== null) {\n      transact(this.doc, (transaction) => {\n        typeMapSet(\n          transaction,\n          this,\n          key,\n          /** @type {any} */\n          value\n        );\n      });\n    } else {\n      this._prelimContent.set(key, value);\n    }\n    return value;\n  }\n  /**\n   * Returns a specified element from this YMap.\n   *\n   * @param {string} key\n   * @return {MapType|undefined}\n   */\n  get(key) {\n    return (\n      /** @type {any} */\n      typeMapGet(this, key)\n    );\n  }\n  /**\n   * Returns a boolean indicating whether the specified key exists or not.\n   *\n   * @param {string} key The key to test.\n   * @return {boolean}\n   */\n  has(key) {\n    return typeMapHas(this, key);\n  }\n  /**\n   * Removes all elements from this YMap.\n   */\n  clear() {\n    if (this.doc !== null) {\n      transact(this.doc, (transaction) => {\n        this.forEach(function(_value, key, map3) {\n          typeMapDelete(transaction, map3, key);\n        });\n      });\n    } else {\n      this._prelimContent.clear();\n    }\n  }\n  /**\n   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder\n   */\n  _write(encoder) {\n    encoder.writeTypeRef(YMapRefID);\n  }\n};\nvar readYMap = (_decoder) => new YMap();\nvar equalAttrs = (a, b) => a === b || typeof a === \"object\" && typeof b === \"object\" && a && b && equalFlat(a, b);\nvar ItemTextListPosition = class {\n  /**\n   * @param {Item|null} left\n   * @param {Item|null} right\n   * @param {number} index\n   * @param {Map<string,any>} currentAttributes\n   */\n  constructor(left, right, index, currentAttributes) {\n    this.left = left;\n    this.right = right;\n    this.index = index;\n    this.currentAttributes = currentAttributes;\n  }\n  /**\n   * Only call this if you know that this.right is defined\n   */\n  forward() {\n    if (this.right === null) {\n      unexpectedCase();\n    }\n    switch (this.right.content.constructor) {\n      case ContentFormat:\n        if (!this.right.deleted) {\n          updateCurrentAttributes(\n            this.currentAttributes,\n            /** @type {ContentFormat} */\n            this.right.content\n          );\n        }\n        break;\n      default:\n        if (!this.right.deleted) {\n          this.index += this.right.length;\n        }\n        break;\n    }\n    this.left = this.right;\n    this.right = this.right.right;\n  }\n};\nvar findNextPosition = (transaction, pos, count) => {\n  while (pos.right !== null && count > 0) {\n    switch (pos.right.content.constructor) {\n      case ContentFormat:\n        if (!pos.right.deleted) {\n          updateCurrentAttributes(\n            pos.currentAttributes,\n            /** @type {ContentFormat} */\n            pos.right.content\n          );\n        }\n        break;\n      default:\n        if (!pos.right.deleted) {\n          if (count < pos.right.length) {\n            getItemCleanStart(transaction, createID(pos.right.id.client, pos.right.id.clock + count));\n          }\n          pos.index += pos.right.length;\n          count -= pos.right.length;\n        }\n        break;\n    }\n    pos.left = pos.right;\n    pos.right = pos.right.right;\n  }\n  return pos;\n};\nvar findPosition = (transaction, parent, index) => {\n  const currentAttributes = /* @__PURE__ */ new Map();\n  const marker = findMarker(parent, index);\n  if (marker) {\n    const pos = new ItemTextListPosition(marker.p.left, marker.p, marker.index, currentAttributes);\n    return findNextPosition(transaction, pos, index - marker.index);\n  } else {\n    const pos = new ItemTextListPosition(null, parent._start, 0, currentAttributes);\n    return findNextPosition(transaction, pos, index);\n  }\n};\nvar insertNegatedAttributes = (transaction, parent, currPos, negatedAttributes) => {\n  while (currPos.right !== null && (currPos.right.deleted === true || currPos.right.content.constructor === ContentFormat && equalAttrs(\n    negatedAttributes.get(\n      /** @type {ContentFormat} */\n      currPos.right.content.key\n    ),\n    /** @type {ContentFormat} */\n    currPos.right.content.value\n  ))) {\n    if (!currPos.right.deleted) {\n      negatedAttributes.delete(\n        /** @type {ContentFormat} */\n        currPos.right.content.key\n      );\n    }\n    currPos.forward();\n  }\n  const doc2 = transaction.doc;\n  const ownClientId = doc2.clientID;\n  negatedAttributes.forEach((val, key) => {\n    const left = currPos.left;\n    const right = currPos.right;\n    const nextFormat = new Item(createID(ownClientId, getState(doc2.store, ownClientId)), left, left && left.lastId, right, right && right.id, parent, null, new ContentFormat(key, val));\n    nextFormat.integrate(transaction, 0);\n    currPos.right = nextFormat;\n    currPos.forward();\n  });\n};\nvar updateCurrentAttributes = (currentAttributes, format) => {\n  const { key, value } = format;\n  if (value === null) {\n    currentAttributes.delete(key);\n  } else {\n    currentAttributes.set(key, value);\n  }\n};\nvar minimizeAttributeChanges = (currPos, attributes) => {\n  while (true) {\n    if (currPos.right === null) {\n      break;\n    } else if (currPos.right.deleted || currPos.right.content.constructor === ContentFormat && equalAttrs(\n      attributes[\n        /** @type {ContentFormat} */\n        currPos.right.content.key\n      ] || null,\n      /** @type {ContentFormat} */\n      currPos.right.content.value\n    ))\n      ;\n    else {\n      break;\n    }\n    currPos.forward();\n  }\n};\nvar insertAttributes = (transaction, parent, currPos, attributes) => {\n  const doc2 = transaction.doc;\n  const ownClientId = doc2.clientID;\n  const negatedAttributes = /* @__PURE__ */ new Map();\n  for (const key in attributes) {\n    const val = attributes[key];\n    const currentVal = currPos.currentAttributes.get(key) || null;\n    if (!equalAttrs(currentVal, val)) {\n      negatedAttributes.set(key, currentVal);\n      const { left, right } = currPos;\n      currPos.right = new Item(createID(ownClientId, getState(doc2.store, ownClientId)), left, left && left.lastId, right, right && right.id, parent, null, new ContentFormat(key, val));\n      currPos.right.integrate(transaction, 0);\n      currPos.forward();\n    }\n  }\n  return negatedAttributes;\n};\nvar insertText = (transaction, parent, currPos, text2, attributes) => {\n  currPos.currentAttributes.forEach((_val, key) => {\n    if (attributes[key] === void 0) {\n      attributes[key] = null;\n    }\n  });\n  const doc2 = transaction.doc;\n  const ownClientId = doc2.clientID;\n  minimizeAttributeChanges(currPos, attributes);\n  const negatedAttributes = insertAttributes(transaction, parent, currPos, attributes);\n  const content = text2.constructor === String ? new ContentString(\n    /** @type {string} */\n    text2\n  ) : text2 instanceof AbstractType ? new ContentType(text2) : new ContentEmbed(text2);\n  let { left, right, index } = currPos;\n  if (parent._searchMarker) {\n    updateMarkerChanges(parent._searchMarker, currPos.index, content.getLength());\n  }\n  right = new Item(createID(ownClientId, getState(doc2.store, ownClientId)), left, left && left.lastId, right, right && right.id, parent, null, content);\n  right.integrate(transaction, 0);\n  currPos.right = right;\n  currPos.index = index;\n  currPos.forward();\n  insertNegatedAttributes(transaction, parent, currPos, negatedAttributes);\n};\nvar formatText = (transaction, parent, currPos, length3, attributes) => {\n  const doc2 = transaction.doc;\n  const ownClientId = doc2.clientID;\n  minimizeAttributeChanges(currPos, attributes);\n  const negatedAttributes = insertAttributes(transaction, parent, currPos, attributes);\n  iterationLoop:\n    while (currPos.right !== null && (length3 > 0 || negatedAttributes.size > 0 && (currPos.right.deleted || currPos.right.content.constructor === ContentFormat))) {\n      if (!currPos.right.deleted) {\n        switch (currPos.right.content.constructor) {\n          case ContentFormat: {\n            const { key, value } = (\n              /** @type {ContentFormat} */\n              currPos.right.content\n            );\n            const attr = attributes[key];\n            if (attr !== void 0) {\n              if (equalAttrs(attr, value)) {\n                negatedAttributes.delete(key);\n              } else {\n                if (length3 === 0) {\n                  break iterationLoop;\n                }\n                negatedAttributes.set(key, value);\n              }\n              currPos.right.delete(transaction);\n            } else {\n              currPos.currentAttributes.set(key, value);\n            }\n            break;\n          }\n          default:\n            if (length3 < currPos.right.length) {\n              getItemCleanStart(transaction, createID(currPos.right.id.client, currPos.right.id.clock + length3));\n            }\n            length3 -= currPos.right.length;\n            break;\n        }\n      }\n      currPos.forward();\n    }\n  if (length3 > 0) {\n    let newlines = \"\";\n    for (; length3 > 0; length3--) {\n      newlines += \"\\n\";\n    }\n    currPos.right = new Item(createID(ownClientId, getState(doc2.store, ownClientId)), currPos.left, currPos.left && currPos.left.lastId, currPos.right, currPos.right && currPos.right.id, parent, null, new ContentString(newlines));\n    currPos.right.integrate(transaction, 0);\n    currPos.forward();\n  }\n  insertNegatedAttributes(transaction, parent, currPos, negatedAttributes);\n};\nvar cleanupFormattingGap = (transaction, start, curr, startAttributes, currAttributes) => {\n  let end = start;\n  const endFormats = create();\n  while (end && (!end.countable || end.deleted)) {\n    if (!end.deleted && end.content.constructor === ContentFormat) {\n      const cf = (\n        /** @type {ContentFormat} */\n        end.content\n      );\n      endFormats.set(cf.key, cf);\n    }\n    end = end.right;\n  }\n  let cleanups = 0;\n  let reachedCurr = false;\n  while (start !== end) {\n    if (curr === start) {\n      reachedCurr = true;\n    }\n    if (!start.deleted) {\n      const content = start.content;\n      switch (content.constructor) {\n        case ContentFormat: {\n          const { key, value } = (\n            /** @type {ContentFormat} */\n            content\n          );\n          const startAttrValue = startAttributes.get(key) || null;\n          if (endFormats.get(key) !== content || startAttrValue === value) {\n            start.delete(transaction);\n            cleanups++;\n            if (!reachedCurr && (currAttributes.get(key) || null) === value && startAttrValue !== value) {\n              if (startAttrValue === null) {\n                currAttributes.delete(key);\n              } else {\n                currAttributes.set(key, startAttrValue);\n              }\n            }\n          }\n          if (!reachedCurr && !start.deleted) {\n            updateCurrentAttributes(\n              currAttributes,\n              /** @type {ContentFormat} */\n              content\n            );\n          }\n          break;\n        }\n      }\n    }\n    start = /** @type {Item} */\n    start.right;\n  }\n  return cleanups;\n};\nvar cleanupContextlessFormattingGap = (transaction, item) => {\n  while (item && item.right && (item.right.deleted || !item.right.countable)) {\n    item = item.right;\n  }\n  const attrs = /* @__PURE__ */ new Set();\n  while (item && (item.deleted || !item.countable)) {\n    if (!item.deleted && item.content.constructor === ContentFormat) {\n      const key = (\n        /** @type {ContentFormat} */\n        item.content.key\n      );\n      if (attrs.has(key)) {\n        item.delete(transaction);\n      } else {\n        attrs.add(key);\n      }\n    }\n    item = item.left;\n  }\n};\nvar cleanupYTextFormatting = (type) => {\n  let res = 0;\n  transact(\n    /** @type {Doc} */\n    type.doc,\n    (transaction) => {\n      let start = (\n        /** @type {Item} */\n        type._start\n      );\n      let end = type._start;\n      let startAttributes = create();\n      const currentAttributes = copy(startAttributes);\n      while (end) {\n        if (end.deleted === false) {\n          switch (end.content.constructor) {\n            case ContentFormat:\n              updateCurrentAttributes(\n                currentAttributes,\n                /** @type {ContentFormat} */\n                end.content\n              );\n              break;\n            default:\n              res += cleanupFormattingGap(transaction, start, end, startAttributes, currentAttributes);\n              startAttributes = copy(currentAttributes);\n              start = end;\n              break;\n          }\n        }\n        end = end.right;\n      }\n    }\n  );\n  return res;\n};\nvar cleanupYTextAfterTransaction = (transaction) => {\n  const needFullCleanup = /* @__PURE__ */ new Set();\n  const doc2 = transaction.doc;\n  for (const [client, afterClock] of transaction.afterState.entries()) {\n    const clock = transaction.beforeState.get(client) || 0;\n    if (afterClock === clock) {\n      continue;\n    }\n    iterateStructs(\n      transaction,\n      /** @type {Array<Item|GC>} */\n      doc2.store.clients.get(client),\n      clock,\n      afterClock,\n      (item) => {\n        if (!item.deleted && /** @type {Item} */\n        item.content.constructor === ContentFormat && item.constructor !== GC) {\n          needFullCleanup.add(\n            /** @type {any} */\n            item.parent\n          );\n        }\n      }\n    );\n  }\n  transact(doc2, (t) => {\n    iterateDeletedStructs(transaction, transaction.deleteSet, (item) => {\n      if (item instanceof GC || !/** @type {YText} */\n      item.parent._hasFormatting || needFullCleanup.has(\n        /** @type {YText} */\n        item.parent\n      )) {\n        return;\n      }\n      const parent = (\n        /** @type {YText} */\n        item.parent\n      );\n      if (item.content.constructor === ContentFormat) {\n        needFullCleanup.add(parent);\n      } else {\n        cleanupContextlessFormattingGap(t, item);\n      }\n    });\n    for (const yText of needFullCleanup) {\n      cleanupYTextFormatting(yText);\n    }\n  });\n};\nvar deleteText = (transaction, currPos, length3) => {\n  const startLength = length3;\n  const startAttrs = copy(currPos.currentAttributes);\n  const start = currPos.right;\n  while (length3 > 0 && currPos.right !== null) {\n    if (currPos.right.deleted === false) {\n      switch (currPos.right.content.constructor) {\n        case ContentType:\n        case ContentEmbed:\n        case ContentString:\n          if (length3 < currPos.right.length) {\n            getItemCleanStart(transaction, createID(currPos.right.id.client, currPos.right.id.clock + length3));\n          }\n          length3 -= currPos.right.length;\n          currPos.right.delete(transaction);\n          break;\n      }\n    }\n    currPos.forward();\n  }\n  if (start) {\n    cleanupFormattingGap(transaction, start, currPos.right, startAttrs, currPos.currentAttributes);\n  }\n  const parent = (\n    /** @type {AbstractType<any>} */\n    /** @type {Item} */\n    (currPos.left || currPos.right).parent\n  );\n  if (parent._searchMarker) {\n    updateMarkerChanges(parent._searchMarker, currPos.index, -startLength + length3);\n  }\n  return currPos;\n};\nvar YTextEvent = class extends YEvent {\n  /**\n   * @param {YText} ytext\n   * @param {Transaction} transaction\n   * @param {Set<any>} subs The keys that changed\n   */\n  constructor(ytext, transaction, subs) {\n    super(ytext, transaction);\n    this.childListChanged = false;\n    this.keysChanged = /* @__PURE__ */ new Set();\n    subs.forEach((sub) => {\n      if (sub === null) {\n        this.childListChanged = true;\n      } else {\n        this.keysChanged.add(sub);\n      }\n    });\n  }\n  /**\n   * @type {{added:Set<Item>,deleted:Set<Item>,keys:Map<string,{action:'add'|'update'|'delete',oldValue:any}>,delta:Array<{insert?:Array<any>|string, delete?:number, retain?:number}>}}\n   */\n  get changes() {\n    if (this._changes === null) {\n      const changes = {\n        keys: this.keys,\n        delta: this.delta,\n        added: /* @__PURE__ */ new Set(),\n        deleted: /* @__PURE__ */ new Set()\n      };\n      this._changes = changes;\n    }\n    return (\n      /** @type {any} */\n      this._changes\n    );\n  }\n  /**\n   * Compute the changes in the delta format.\n   * A {@link https://quilljs.com/docs/delta/|Quill Delta}) that represents the changes on the document.\n   *\n   * @type {Array<{insert?:string|object|AbstractType<any>, delete?:number, retain?:number, attributes?: Object<string,any>}>}\n   *\n   * @public\n   */\n  get delta() {\n    if (this._delta === null) {\n      const y = (\n        /** @type {Doc} */\n        this.target.doc\n      );\n      const delta = [];\n      transact(y, (transaction) => {\n        const currentAttributes = /* @__PURE__ */ new Map();\n        const oldAttributes = /* @__PURE__ */ new Map();\n        let item = this.target._start;\n        let action = null;\n        const attributes = {};\n        let insert = \"\";\n        let retain = 0;\n        let deleteLen = 0;\n        const addOp = () => {\n          if (action !== null) {\n            let op = null;\n            switch (action) {\n              case \"delete\":\n                if (deleteLen > 0) {\n                  op = { delete: deleteLen };\n                }\n                deleteLen = 0;\n                break;\n              case \"insert\":\n                if (typeof insert === \"object\" || insert.length > 0) {\n                  op = { insert };\n                  if (currentAttributes.size > 0) {\n                    op.attributes = {};\n                    currentAttributes.forEach((value, key) => {\n                      if (value !== null) {\n                        op.attributes[key] = value;\n                      }\n                    });\n                  }\n                }\n                insert = \"\";\n                break;\n              case \"retain\":\n                if (retain > 0) {\n                  op = { retain };\n                  if (!isEmpty(attributes)) {\n                    op.attributes = assign({}, attributes);\n                  }\n                }\n                retain = 0;\n                break;\n            }\n            if (op)\n              delta.push(op);\n            action = null;\n          }\n        };\n        while (item !== null) {\n          switch (item.content.constructor) {\n            case ContentType:\n            case ContentEmbed:\n              if (this.adds(item)) {\n                if (!this.deletes(item)) {\n                  addOp();\n                  action = \"insert\";\n                  insert = item.content.getContent()[0];\n                  addOp();\n                }\n              } else if (this.deletes(item)) {\n                if (action !== \"delete\") {\n                  addOp();\n                  action = \"delete\";\n                }\n                deleteLen += 1;\n              } else if (!item.deleted) {\n                if (action !== \"retain\") {\n                  addOp();\n                  action = \"retain\";\n                }\n                retain += 1;\n              }\n              break;\n            case ContentString:\n              if (this.adds(item)) {\n                if (!this.deletes(item)) {\n                  if (action !== \"insert\") {\n                    addOp();\n                    action = \"insert\";\n                  }\n                  insert += /** @type {ContentString} */\n                  item.content.str;\n                }\n              } else if (this.deletes(item)) {\n                if (action !== \"delete\") {\n                  addOp();\n                  action = \"delete\";\n                }\n                deleteLen += item.length;\n              } else if (!item.deleted) {\n                if (action !== \"retain\") {\n                  addOp();\n                  action = \"retain\";\n                }\n                retain += item.length;\n              }\n              break;\n            case ContentFormat: {\n              const { key, value } = (\n                /** @type {ContentFormat} */\n                item.content\n              );\n              if (this.adds(item)) {\n                if (!this.deletes(item)) {\n                  const curVal = currentAttributes.get(key) || null;\n                  if (!equalAttrs(curVal, value)) {\n                    if (action === \"retain\") {\n                      addOp();\n                    }\n                    if (equalAttrs(value, oldAttributes.get(key) || null)) {\n                      delete attributes[key];\n                    } else {\n                      attributes[key] = value;\n                    }\n                  } else if (value !== null) {\n                    item.delete(transaction);\n                  }\n                }\n              } else if (this.deletes(item)) {\n                oldAttributes.set(key, value);\n                const curVal = currentAttributes.get(key) || null;\n                if (!equalAttrs(curVal, value)) {\n                  if (action === \"retain\") {\n                    addOp();\n                  }\n                  attributes[key] = curVal;\n                }\n              } else if (!item.deleted) {\n                oldAttributes.set(key, value);\n                const attr = attributes[key];\n                if (attr !== void 0) {\n                  if (!equalAttrs(attr, value)) {\n                    if (action === \"retain\") {\n                      addOp();\n                    }\n                    if (value === null) {\n                      delete attributes[key];\n                    } else {\n                      attributes[key] = value;\n                    }\n                  } else if (attr !== null) {\n                    item.delete(transaction);\n                  }\n                }\n              }\n              if (!item.deleted) {\n                if (action === \"insert\") {\n                  addOp();\n                }\n                updateCurrentAttributes(\n                  currentAttributes,\n                  /** @type {ContentFormat} */\n                  item.content\n                );\n              }\n              break;\n            }\n          }\n          item = item.right;\n        }\n        addOp();\n        while (delta.length > 0) {\n          const lastOp = delta[delta.length - 1];\n          if (lastOp.retain !== void 0 && lastOp.attributes === void 0) {\n            delta.pop();\n          } else {\n            break;\n          }\n        }\n      });\n      this._delta = delta;\n    }\n    return (\n      /** @type {any} */\n      this._delta\n    );\n  }\n};\nvar YText = class _YText extends AbstractType {\n  /**\n   * @param {String} [string] The initial value of the YText.\n   */\n  constructor(string) {\n    super();\n    this._pending = string !== void 0 ? [() => this.insert(0, string)] : [];\n    this._searchMarker = [];\n    this._hasFormatting = false;\n  }\n  /**\n   * Number of characters of this text type.\n   *\n   * @type {number}\n   */\n  get length() {\n    return this._length;\n  }\n  /**\n   * @param {Doc} y\n   * @param {Item} item\n   */\n  _integrate(y, item) {\n    super._integrate(y, item);\n    try {\n      this._pending.forEach((f) => f());\n    } catch (e) {\n      console.error(e);\n    }\n    this._pending = null;\n  }\n  _copy() {\n    return new _YText();\n  }\n  /**\n   * @return {YText}\n   */\n  clone() {\n    const text2 = new _YText();\n    text2.applyDelta(this.toDelta());\n    return text2;\n  }\n  /**\n   * Creates YTextEvent and calls observers.\n   *\n   * @param {Transaction} transaction\n   * @param {Set<null|string>} parentSubs Keys changed on this type. `null` if list was modified.\n   */\n  _callObserver(transaction, parentSubs) {\n    super._callObserver(transaction, parentSubs);\n    const event = new YTextEvent(this, transaction, parentSubs);\n    callTypeObservers(this, transaction, event);\n    if (!transaction.local && this._hasFormatting) {\n      transaction._needFormattingCleanup = true;\n    }\n  }\n  /**\n   * Returns the unformatted string representation of this YText type.\n   *\n   * @public\n   */\n  toString() {\n    let str = \"\";\n    let n = this._start;\n    while (n !== null) {\n      if (!n.deleted && n.countable && n.content.constructor === ContentString) {\n        str += /** @type {ContentString} */\n        n.content.str;\n      }\n      n = n.right;\n    }\n    return str;\n  }\n  /**\n   * Returns the unformatted string representation of this YText type.\n   *\n   * @return {string}\n   * @public\n   */\n  toJSON() {\n    return this.toString();\n  }\n  /**\n   * Apply a {@link Delta} on this shared YText type.\n   *\n   * @param {any} delta The changes to apply on this element.\n   * @param {object}  opts\n   * @param {boolean} [opts.sanitize] Sanitize input delta. Removes ending newlines if set to true.\n   *\n   *\n   * @public\n   */\n  applyDelta(delta, { sanitize = true } = {}) {\n    if (this.doc !== null) {\n      transact(this.doc, (transaction) => {\n        const currPos = new ItemTextListPosition(null, this._start, 0, /* @__PURE__ */ new Map());\n        for (let i = 0; i < delta.length; i++) {\n          const op = delta[i];\n          if (op.insert !== void 0) {\n            const ins = !sanitize && typeof op.insert === \"string\" && i === delta.length - 1 && currPos.right === null && op.insert.slice(-1) === \"\\n\" ? op.insert.slice(0, -1) : op.insert;\n            if (typeof ins !== \"string\" || ins.length > 0) {\n              insertText(transaction, this, currPos, ins, op.attributes || {});\n            }\n          } else if (op.retain !== void 0) {\n            formatText(transaction, this, currPos, op.retain, op.attributes || {});\n          } else if (op.delete !== void 0) {\n            deleteText(transaction, currPos, op.delete);\n          }\n        }\n      });\n    } else {\n      this._pending.push(() => this.applyDelta(delta));\n    }\n  }\n  /**\n   * Returns the Delta representation of this YText type.\n   *\n   * @param {Snapshot} [snapshot]\n   * @param {Snapshot} [prevSnapshot]\n   * @param {function('removed' | 'added', ID):any} [computeYChange]\n   * @return {any} The Delta representation of this type.\n   *\n   * @public\n   */\n  toDelta(snapshot2, prevSnapshot, computeYChange) {\n    const ops = [];\n    const currentAttributes = /* @__PURE__ */ new Map();\n    const doc2 = (\n      /** @type {Doc} */\n      this.doc\n    );\n    let str = \"\";\n    let n = this._start;\n    function packStr() {\n      if (str.length > 0) {\n        const attributes = {};\n        let addAttributes = false;\n        currentAttributes.forEach((value, key) => {\n          addAttributes = true;\n          attributes[key] = value;\n        });\n        const op = { insert: str };\n        if (addAttributes) {\n          op.attributes = attributes;\n        }\n        ops.push(op);\n        str = \"\";\n      }\n    }\n    const computeDelta = () => {\n      while (n !== null) {\n        if (isVisible(n, snapshot2) || prevSnapshot !== void 0 && isVisible(n, prevSnapshot)) {\n          switch (n.content.constructor) {\n            case ContentString: {\n              const cur = currentAttributes.get(\"ychange\");\n              if (snapshot2 !== void 0 && !isVisible(n, snapshot2)) {\n                if (cur === void 0 || cur.user !== n.id.client || cur.type !== \"removed\") {\n                  packStr();\n                  currentAttributes.set(\"ychange\", computeYChange ? computeYChange(\"removed\", n.id) : { type: \"removed\" });\n                }\n              } else if (prevSnapshot !== void 0 && !isVisible(n, prevSnapshot)) {\n                if (cur === void 0 || cur.user !== n.id.client || cur.type !== \"added\") {\n                  packStr();\n                  currentAttributes.set(\"ychange\", computeYChange ? computeYChange(\"added\", n.id) : { type: \"added\" });\n                }\n              } else if (cur !== void 0) {\n                packStr();\n                currentAttributes.delete(\"ychange\");\n              }\n              str += /** @type {ContentString} */\n              n.content.str;\n              break;\n            }\n            case ContentType:\n            case ContentEmbed: {\n              packStr();\n              const op = {\n                insert: n.content.getContent()[0]\n              };\n              if (currentAttributes.size > 0) {\n                const attrs = (\n                  /** @type {Object<string,any>} */\n                  {}\n                );\n                op.attributes = attrs;\n                currentAttributes.forEach((value, key) => {\n                  attrs[key] = value;\n                });\n              }\n              ops.push(op);\n              break;\n            }\n            case ContentFormat:\n              if (isVisible(n, snapshot2)) {\n                packStr();\n                updateCurrentAttributes(\n                  currentAttributes,\n                  /** @type {ContentFormat} */\n                  n.content\n                );\n              }\n              break;\n          }\n        }\n        n = n.right;\n      }\n      packStr();\n    };\n    if (snapshot2 || prevSnapshot) {\n      transact(doc2, (transaction) => {\n        if (snapshot2) {\n          splitSnapshotAffectedStructs(transaction, snapshot2);\n        }\n        if (prevSnapshot) {\n          splitSnapshotAffectedStructs(transaction, prevSnapshot);\n        }\n        computeDelta();\n      }, \"cleanup\");\n    } else {\n      computeDelta();\n    }\n    return ops;\n  }\n  /**\n   * Insert text at a given index.\n   *\n   * @param {number} index The index at which to start inserting.\n   * @param {String} text The text to insert at the specified position.\n   * @param {TextAttributes} [attributes] Optionally define some formatting\n   *                                    information to apply on the inserted\n   *                                    Text.\n   * @public\n   */\n  insert(index, text2, attributes) {\n    if (text2.length <= 0) {\n      return;\n    }\n    const y = this.doc;\n    if (y !== null) {\n      transact(y, (transaction) => {\n        const pos = findPosition(transaction, this, index);\n        if (!attributes) {\n          attributes = {};\n          pos.currentAttributes.forEach((v, k) => {\n            attributes[k] = v;\n          });\n        }\n        insertText(transaction, this, pos, text2, attributes);\n      });\n    } else {\n      this._pending.push(() => this.insert(index, text2, attributes));\n    }\n  }\n  /**\n   * Inserts an embed at a index.\n   *\n   * @param {number} index The index to insert the embed at.\n   * @param {Object | AbstractType<any>} embed The Object that represents the embed.\n   * @param {TextAttributes} attributes Attribute information to apply on the\n   *                                    embed\n   *\n   * @public\n   */\n  insertEmbed(index, embed, attributes = {}) {\n    const y = this.doc;\n    if (y !== null) {\n      transact(y, (transaction) => {\n        const pos = findPosition(transaction, this, index);\n        insertText(transaction, this, pos, embed, attributes);\n      });\n    } else {\n      this._pending.push(() => this.insertEmbed(index, embed, attributes));\n    }\n  }\n  /**\n   * Deletes text starting from an index.\n   *\n   * @param {number} index Index at which to start deleting.\n   * @param {number} length The number of characters to remove. Defaults to 1.\n   *\n   * @public\n   */\n  delete(index, length3) {\n    if (length3 === 0) {\n      return;\n    }\n    const y = this.doc;\n    if (y !== null) {\n      transact(y, (transaction) => {\n        deleteText(transaction, findPosition(transaction, this, index), length3);\n      });\n    } else {\n      this._pending.push(() => this.delete(index, length3));\n    }\n  }\n  /**\n   * Assigns properties to a range of text.\n   *\n   * @param {number} index The position where to start formatting.\n   * @param {number} length The amount of characters to assign properties to.\n   * @param {TextAttributes} attributes Attribute information to apply on the\n   *                                    text.\n   *\n   * @public\n   */\n  format(index, length3, attributes) {\n    if (length3 === 0) {\n      return;\n    }\n    const y = this.doc;\n    if (y !== null) {\n      transact(y, (transaction) => {\n        const pos = findPosition(transaction, this, index);\n        if (pos.right === null) {\n          return;\n        }\n        formatText(transaction, this, pos, length3, attributes);\n      });\n    } else {\n      this._pending.push(() => this.format(index, length3, attributes));\n    }\n  }\n  /**\n   * Removes an attribute.\n   *\n   * @note Xml-Text nodes don't have attributes. You can use this feature to assign properties to complete text-blocks.\n   *\n   * @param {String} attributeName The attribute name that is to be removed.\n   *\n   * @public\n   */\n  removeAttribute(attributeName) {\n    if (this.doc !== null) {\n      transact(this.doc, (transaction) => {\n        typeMapDelete(transaction, this, attributeName);\n      });\n    } else {\n      this._pending.push(() => this.removeAttribute(attributeName));\n    }\n  }\n  /**\n   * Sets or updates an attribute.\n   *\n   * @note Xml-Text nodes don't have attributes. You can use this feature to assign properties to complete text-blocks.\n   *\n   * @param {String} attributeName The attribute name that is to be set.\n   * @param {any} attributeValue The attribute value that is to be set.\n   *\n   * @public\n   */\n  setAttribute(attributeName, attributeValue) {\n    if (this.doc !== null) {\n      transact(this.doc, (transaction) => {\n        typeMapSet(transaction, this, attributeName, attributeValue);\n      });\n    } else {\n      this._pending.push(() => this.setAttribute(attributeName, attributeValue));\n    }\n  }\n  /**\n   * Returns an attribute value that belongs to the attribute name.\n   *\n   * @note Xml-Text nodes don't have attributes. You can use this feature to assign properties to complete text-blocks.\n   *\n   * @param {String} attributeName The attribute name that identifies the\n   *                               queried value.\n   * @return {any} The queried attribute value.\n   *\n   * @public\n   */\n  getAttribute(attributeName) {\n    return (\n      /** @type {any} */\n      typeMapGet(this, attributeName)\n    );\n  }\n  /**\n   * Returns all attribute name/value pairs in a JSON Object.\n   *\n   * @note Xml-Text nodes don't have attributes. You can use this feature to assign properties to complete text-blocks.\n   *\n   * @return {Object<string, any>} A JSON Object that describes the attributes.\n   *\n   * @public\n   */\n  getAttributes() {\n    return typeMapGetAll(this);\n  }\n  /**\n   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder\n   */\n  _write(encoder) {\n    encoder.writeTypeRef(YTextRefID);\n  }\n};\nvar readYText = (_decoder) => new YText();\nvar YXmlTreeWalker = class {\n  /**\n   * @param {YXmlFragment | YXmlElement} root\n   * @param {function(AbstractType<any>):boolean} [f]\n   */\n  constructor(root, f = () => true) {\n    this._filter = f;\n    this._root = root;\n    this._currentNode = /** @type {Item} */\n    root._start;\n    this._firstCall = true;\n  }\n  [Symbol.iterator]() {\n    return this;\n  }\n  /**\n   * Get the next node.\n   *\n   * @return {IteratorResult<YXmlElement|YXmlText|YXmlHook>} The next node.\n   *\n   * @public\n   */\n  next() {\n    let n = this._currentNode;\n    let type = n && n.content && /** @type {any} */\n    n.content.type;\n    if (n !== null && (!this._firstCall || n.deleted || !this._filter(type))) {\n      do {\n        type = /** @type {any} */\n        n.content.type;\n        if (!n.deleted && (type.constructor === YXmlElement || type.constructor === YXmlFragment) && type._start !== null) {\n          n = type._start;\n        } else {\n          while (n !== null) {\n            if (n.right !== null) {\n              n = n.right;\n              break;\n            } else if (n.parent === this._root) {\n              n = null;\n            } else {\n              n = /** @type {AbstractType<any>} */\n              n.parent._item;\n            }\n          }\n        }\n      } while (n !== null && (n.deleted || !this._filter(\n        /** @type {ContentType} */\n        n.content.type\n      )));\n    }\n    this._firstCall = false;\n    if (n === null) {\n      return { value: void 0, done: true };\n    }\n    this._currentNode = n;\n    return { value: (\n      /** @type {any} */\n      n.content.type\n    ), done: false };\n  }\n};\nvar YXmlFragment = class _YXmlFragment extends AbstractType {\n  constructor() {\n    super();\n    this._prelimContent = [];\n  }\n  /**\n   * @type {YXmlElement|YXmlText|null}\n   */\n  get firstChild() {\n    const first = this._first;\n    return first ? first.content.getContent()[0] : null;\n  }\n  /**\n   * Integrate this type into the Yjs instance.\n   *\n   * * Save this struct in the os\n   * * This type is sent to other client\n   * * Observer functions are fired\n   *\n   * @param {Doc} y The Yjs instance\n   * @param {Item} item\n   */\n  _integrate(y, item) {\n    super._integrate(y, item);\n    this.insert(\n      0,\n      /** @type {Array<any>} */\n      this._prelimContent\n    );\n    this._prelimContent = null;\n  }\n  _copy() {\n    return new _YXmlFragment();\n  }\n  /**\n   * @return {YXmlFragment}\n   */\n  clone() {\n    const el = new _YXmlFragment();\n    el.insert(0, this.toArray().map((item) => item instanceof AbstractType ? item.clone() : item));\n    return el;\n  }\n  get length() {\n    return this._prelimContent === null ? this._length : this._prelimContent.length;\n  }\n  /**\n   * Create a subtree of childNodes.\n   *\n   * @example\n   * const walker = elem.createTreeWalker(dom => dom.nodeName === 'div')\n   * for (let node in walker) {\n   *   // `node` is a div node\n   *   nop(node)\n   * }\n   *\n   * @param {function(AbstractType<any>):boolean} filter Function that is called on each child element and\n   *                          returns a Boolean indicating whether the child\n   *                          is to be included in the subtree.\n   * @return {YXmlTreeWalker} A subtree and a position within it.\n   *\n   * @public\n   */\n  createTreeWalker(filter) {\n    return new YXmlTreeWalker(this, filter);\n  }\n  /**\n   * Returns the first YXmlElement that matches the query.\n   * Similar to DOM's {@link querySelector}.\n   *\n   * Query support:\n   *   - tagname\n   * TODO:\n   *   - id\n   *   - attribute\n   *\n   * @param {CSS_Selector} query The query on the children.\n   * @return {YXmlElement|YXmlText|YXmlHook|null} The first element that matches the query or null.\n   *\n   * @public\n   */\n  querySelector(query) {\n    query = query.toUpperCase();\n    const iterator = new YXmlTreeWalker(this, (element2) => element2.nodeName && element2.nodeName.toUpperCase() === query);\n    const next = iterator.next();\n    if (next.done) {\n      return null;\n    } else {\n      return next.value;\n    }\n  }\n  /**\n   * Returns all YXmlElements that match the query.\n   * Similar to Dom's {@link querySelectorAll}.\n   *\n   * @todo Does not yet support all queries. Currently only query by tagName.\n   *\n   * @param {CSS_Selector} query The query on the children\n   * @return {Array<YXmlElement|YXmlText|YXmlHook|null>} The elements that match this query.\n   *\n   * @public\n   */\n  querySelectorAll(query) {\n    query = query.toUpperCase();\n    return from2(new YXmlTreeWalker(this, (element2) => element2.nodeName && element2.nodeName.toUpperCase() === query));\n  }\n  /**\n   * Creates YXmlEvent and calls observers.\n   *\n   * @param {Transaction} transaction\n   * @param {Set<null|string>} parentSubs Keys changed on this type. `null` if list was modified.\n   */\n  _callObserver(transaction, parentSubs) {\n    callTypeObservers(this, transaction, new YXmlEvent(this, parentSubs, transaction));\n  }\n  /**\n   * Get the string representation of all the children of this YXmlFragment.\n   *\n   * @return {string} The string representation of all children.\n   */\n  toString() {\n    return typeListMap(this, (xml) => xml.toString()).join(\"\");\n  }\n  /**\n   * @return {string}\n   */\n  toJSON() {\n    return this.toString();\n  }\n  /**\n   * Creates a Dom Element that mirrors this YXmlElement.\n   *\n   * @param {Document} [_document=document] The document object (you must define\n   *                                        this when calling this method in\n   *                                        nodejs)\n   * @param {Object<string, any>} [hooks={}] Optional property to customize how hooks\n   *                                             are presented in the DOM\n   * @param {any} [binding] You should not set this property. This is\n   *                               used if DomBinding wants to create a\n   *                               association to the created DOM type.\n   * @return {Node} The {@link https://developer.mozilla.org/en-US/docs/Web/API/Element|Dom Element}\n   *\n   * @public\n   */\n  toDOM(_document = document, hooks = {}, binding) {\n    const fragment = _document.createDocumentFragment();\n    if (binding !== void 0) {\n      binding._createAssociation(fragment, this);\n    }\n    typeListForEach(this, (xmlType) => {\n      fragment.insertBefore(xmlType.toDOM(_document, hooks, binding), null);\n    });\n    return fragment;\n  }\n  /**\n   * Inserts new content at an index.\n   *\n   * @example\n   *  // Insert character 'a' at position 0\n   *  xml.insert(0, [new Y.XmlText('text')])\n   *\n   * @param {number} index The index to insert content at\n   * @param {Array<YXmlElement|YXmlText>} content The array of content\n   */\n  insert(index, content) {\n    if (this.doc !== null) {\n      transact(this.doc, (transaction) => {\n        typeListInsertGenerics(transaction, this, index, content);\n      });\n    } else {\n      this._prelimContent.splice(index, 0, ...content);\n    }\n  }\n  /**\n   * Inserts new content at an index.\n   *\n   * @example\n   *  // Insert character 'a' at position 0\n   *  xml.insert(0, [new Y.XmlText('text')])\n   *\n   * @param {null|Item|YXmlElement|YXmlText} ref The index to insert content at\n   * @param {Array<YXmlElement|YXmlText>} content The array of content\n   */\n  insertAfter(ref, content) {\n    if (this.doc !== null) {\n      transact(this.doc, (transaction) => {\n        const refItem = ref && ref instanceof AbstractType ? ref._item : ref;\n        typeListInsertGenericsAfter(transaction, this, refItem, content);\n      });\n    } else {\n      const pc = (\n        /** @type {Array<any>} */\n        this._prelimContent\n      );\n      const index = ref === null ? 0 : pc.findIndex((el) => el === ref) + 1;\n      if (index === 0 && ref !== null) {\n        throw create3(\"Reference item not found\");\n      }\n      pc.splice(index, 0, ...content);\n    }\n  }\n  /**\n   * Deletes elements starting from an index.\n   *\n   * @param {number} index Index at which to start deleting elements\n   * @param {number} [length=1] The number of elements to remove. Defaults to 1.\n   */\n  delete(index, length3 = 1) {\n    if (this.doc !== null) {\n      transact(this.doc, (transaction) => {\n        typeListDelete(transaction, this, index, length3);\n      });\n    } else {\n      this._prelimContent.splice(index, length3);\n    }\n  }\n  /**\n   * Transforms this YArray to a JavaScript Array.\n   *\n   * @return {Array<YXmlElement|YXmlText|YXmlHook>}\n   */\n  toArray() {\n    return typeListToArray(this);\n  }\n  /**\n   * Appends content to this YArray.\n   *\n   * @param {Array<YXmlElement|YXmlText>} content Array of content to append.\n   */\n  push(content) {\n    this.insert(this.length, content);\n  }\n  /**\n   * Preppends content to this YArray.\n   *\n   * @param {Array<YXmlElement|YXmlText>} content Array of content to preppend.\n   */\n  unshift(content) {\n    this.insert(0, content);\n  }\n  /**\n   * Returns the i-th element from a YArray.\n   *\n   * @param {number} index The index of the element to return from the YArray\n   * @return {YXmlElement|YXmlText}\n   */\n  get(index) {\n    return typeListGet(this, index);\n  }\n  /**\n   * Transforms this YArray to a JavaScript Array.\n   *\n   * @param {number} [start]\n   * @param {number} [end]\n   * @return {Array<YXmlElement|YXmlText>}\n   */\n  slice(start = 0, end = this.length) {\n    return typeListSlice(this, start, end);\n  }\n  /**\n   * Executes a provided function on once on overy child element.\n   *\n   * @param {function(YXmlElement|YXmlText,number, typeof self):void} f A function to execute on every element of this YArray.\n   */\n  forEach(f) {\n    typeListForEach(this, f);\n  }\n  /**\n   * Transform the properties of this type to binary and write it to an\n   * BinaryEncoder.\n   *\n   * This is called when this Item is sent to a remote peer.\n   *\n   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder The encoder to write data to.\n   */\n  _write(encoder) {\n    encoder.writeTypeRef(YXmlFragmentRefID);\n  }\n};\nvar readYXmlFragment = (_decoder) => new YXmlFragment();\nvar YXmlElement = class _YXmlElement extends YXmlFragment {\n  constructor(nodeName = \"UNDEFINED\") {\n    super();\n    this.nodeName = nodeName;\n    this._prelimAttrs = /* @__PURE__ */ new Map();\n  }\n  /**\n   * @type {YXmlElement|YXmlText|null}\n   */\n  get nextSibling() {\n    const n = this._item ? this._item.next : null;\n    return n ? (\n      /** @type {YXmlElement|YXmlText} */\n      /** @type {ContentType} */\n      n.content.type\n    ) : null;\n  }\n  /**\n   * @type {YXmlElement|YXmlText|null}\n   */\n  get prevSibling() {\n    const n = this._item ? this._item.prev : null;\n    return n ? (\n      /** @type {YXmlElement|YXmlText} */\n      /** @type {ContentType} */\n      n.content.type\n    ) : null;\n  }\n  /**\n   * Integrate this type into the Yjs instance.\n   *\n   * * Save this struct in the os\n   * * This type is sent to other client\n   * * Observer functions are fired\n   *\n   * @param {Doc} y The Yjs instance\n   * @param {Item} item\n   */\n  _integrate(y, item) {\n    super._integrate(y, item);\n    /** @type {Map<string, any>} */\n    this._prelimAttrs.forEach((value, key) => {\n      this.setAttribute(key, value);\n    });\n    this._prelimAttrs = null;\n  }\n  /**\n   * Creates an Item with the same effect as this Item (without position effect)\n   *\n   * @return {YXmlElement}\n   */\n  _copy() {\n    return new _YXmlElement(this.nodeName);\n  }\n  /**\n   * @return {YXmlElement<KV>}\n   */\n  clone() {\n    const el = new _YXmlElement(this.nodeName);\n    const attrs = this.getAttributes();\n    forEach(attrs, (value, key) => {\n      if (typeof value === \"string\") {\n        el.setAttribute(key, value);\n      }\n    });\n    el.insert(0, this.toArray().map((item) => item instanceof AbstractType ? item.clone() : item));\n    return el;\n  }\n  /**\n   * Returns the XML serialization of this YXmlElement.\n   * The attributes are ordered by attribute-name, so you can easily use this\n   * method to compare YXmlElements\n   *\n   * @return {string} The string representation of this type.\n   *\n   * @public\n   */\n  toString() {\n    const attrs = this.getAttributes();\n    const stringBuilder = [];\n    const keys2 = [];\n    for (const key in attrs) {\n      keys2.push(key);\n    }\n    keys2.sort();\n    const keysLen = keys2.length;\n    for (let i = 0; i < keysLen; i++) {\n      const key = keys2[i];\n      stringBuilder.push(key + '=\"' + attrs[key] + '\"');\n    }\n    const nodeName = this.nodeName.toLocaleLowerCase();\n    const attrsString = stringBuilder.length > 0 ? \" \" + stringBuilder.join(\" \") : \"\";\n    return `<${nodeName}${attrsString}>${super.toString()}</${nodeName}>`;\n  }\n  /**\n   * Removes an attribute from this YXmlElement.\n   *\n   * @param {string} attributeName The attribute name that is to be removed.\n   *\n   * @public\n   */\n  removeAttribute(attributeName) {\n    if (this.doc !== null) {\n      transact(this.doc, (transaction) => {\n        typeMapDelete(transaction, this, attributeName);\n      });\n    } else {\n      this._prelimAttrs.delete(attributeName);\n    }\n  }\n  /**\n   * Sets or updates an attribute.\n   *\n   * @template {keyof KV & string} KEY\n   *\n   * @param {KEY} attributeName The attribute name that is to be set.\n   * @param {KV[KEY]} attributeValue The attribute value that is to be set.\n   *\n   * @public\n   */\n  setAttribute(attributeName, attributeValue) {\n    if (this.doc !== null) {\n      transact(this.doc, (transaction) => {\n        typeMapSet(transaction, this, attributeName, attributeValue);\n      });\n    } else {\n      this._prelimAttrs.set(attributeName, attributeValue);\n    }\n  }\n  /**\n   * Returns an attribute value that belongs to the attribute name.\n   *\n   * @template {keyof KV & string} KEY\n   *\n   * @param {KEY} attributeName The attribute name that identifies the\n   *                               queried value.\n   * @return {KV[KEY]|undefined} The queried attribute value.\n   *\n   * @public\n   */\n  getAttribute(attributeName) {\n    return (\n      /** @type {any} */\n      typeMapGet(this, attributeName)\n    );\n  }\n  /**\n   * Returns whether an attribute exists\n   *\n   * @param {string} attributeName The attribute name to check for existence.\n   * @return {boolean} whether the attribute exists.\n   *\n   * @public\n   */\n  hasAttribute(attributeName) {\n    return (\n      /** @type {any} */\n      typeMapHas(this, attributeName)\n    );\n  }\n  /**\n   * Returns all attribute name/value pairs in a JSON Object.\n   *\n   * @return {{ [Key in Extract<keyof KV,string>]?: KV[Key]}} A JSON Object that describes the attributes.\n   *\n   * @public\n   */\n  getAttributes() {\n    return (\n      /** @type {any} */\n      typeMapGetAll(this)\n    );\n  }\n  /**\n   * Creates a Dom Element that mirrors this YXmlElement.\n   *\n   * @param {Document} [_document=document] The document object (you must define\n   *                                        this when calling this method in\n   *                                        nodejs)\n   * @param {Object<string, any>} [hooks={}] Optional property to customize how hooks\n   *                                             are presented in the DOM\n   * @param {any} [binding] You should not set this property. This is\n   *                               used if DomBinding wants to create a\n   *                               association to the created DOM type.\n   * @return {Node} The {@link https://developer.mozilla.org/en-US/docs/Web/API/Element|Dom Element}\n   *\n   * @public\n   */\n  toDOM(_document = document, hooks = {}, binding) {\n    const dom = _document.createElement(this.nodeName);\n    const attrs = this.getAttributes();\n    for (const key in attrs) {\n      const value = attrs[key];\n      if (typeof value === \"string\") {\n        dom.setAttribute(key, value);\n      }\n    }\n    typeListForEach(this, (yxml) => {\n      dom.appendChild(yxml.toDOM(_document, hooks, binding));\n    });\n    if (binding !== void 0) {\n      binding._createAssociation(dom, this);\n    }\n    return dom;\n  }\n  /**\n   * Transform the properties of this type to binary and write it to an\n   * BinaryEncoder.\n   *\n   * This is called when this Item is sent to a remote peer.\n   *\n   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder The encoder to write data to.\n   */\n  _write(encoder) {\n    encoder.writeTypeRef(YXmlElementRefID);\n    encoder.writeKey(this.nodeName);\n  }\n};\nvar readYXmlElement = (decoder) => new YXmlElement(decoder.readKey());\nvar YXmlEvent = class extends YEvent {\n  /**\n   * @param {YXmlElement|YXmlText|YXmlFragment} target The target on which the event is created.\n   * @param {Set<string|null>} subs The set of changed attributes. `null` is included if the\n   *                   child list changed.\n   * @param {Transaction} transaction The transaction instance with wich the\n   *                                  change was created.\n   */\n  constructor(target, subs, transaction) {\n    super(target, transaction);\n    this.childListChanged = false;\n    this.attributesChanged = /* @__PURE__ */ new Set();\n    subs.forEach((sub) => {\n      if (sub === null) {\n        this.childListChanged = true;\n      } else {\n        this.attributesChanged.add(sub);\n      }\n    });\n  }\n};\nvar YXmlHook = class _YXmlHook extends YMap {\n  /**\n   * @param {string} hookName nodeName of the Dom Node.\n   */\n  constructor(hookName) {\n    super();\n    this.hookName = hookName;\n  }\n  /**\n   * Creates an Item with the same effect as this Item (without position effect)\n   */\n  _copy() {\n    return new _YXmlHook(this.hookName);\n  }\n  /**\n   * @return {YXmlHook}\n   */\n  clone() {\n    const el = new _YXmlHook(this.hookName);\n    this.forEach((value, key) => {\n      el.set(key, value);\n    });\n    return el;\n  }\n  /**\n   * Creates a Dom Element that mirrors this YXmlElement.\n   *\n   * @param {Document} [_document=document] The document object (you must define\n   *                                        this when calling this method in\n   *                                        nodejs)\n   * @param {Object.<string, any>} [hooks] Optional property to customize how hooks\n   *                                             are presented in the DOM\n   * @param {any} [binding] You should not set this property. This is\n   *                               used if DomBinding wants to create a\n   *                               association to the created DOM type\n   * @return {Element} The {@link https://developer.mozilla.org/en-US/docs/Web/API/Element|Dom Element}\n   *\n   * @public\n   */\n  toDOM(_document = document, hooks = {}, binding) {\n    const hook = hooks[this.hookName];\n    let dom;\n    if (hook !== void 0) {\n      dom = hook.createDom(this);\n    } else {\n      dom = document.createElement(this.hookName);\n    }\n    dom.setAttribute(\"data-yjs-hook\", this.hookName);\n    if (binding !== void 0) {\n      binding._createAssociation(dom, this);\n    }\n    return dom;\n  }\n  /**\n   * Transform the properties of this type to binary and write it to an\n   * BinaryEncoder.\n   *\n   * This is called when this Item is sent to a remote peer.\n   *\n   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder The encoder to write data to.\n   */\n  _write(encoder) {\n    encoder.writeTypeRef(YXmlHookRefID);\n    encoder.writeKey(this.hookName);\n  }\n};\nvar readYXmlHook = (decoder) => new YXmlHook(decoder.readKey());\nvar YXmlText = class _YXmlText extends YText {\n  /**\n   * @type {YXmlElement|YXmlText|null}\n   */\n  get nextSibling() {\n    const n = this._item ? this._item.next : null;\n    return n ? (\n      /** @type {YXmlElement|YXmlText} */\n      /** @type {ContentType} */\n      n.content.type\n    ) : null;\n  }\n  /**\n   * @type {YXmlElement|YXmlText|null}\n   */\n  get prevSibling() {\n    const n = this._item ? this._item.prev : null;\n    return n ? (\n      /** @type {YXmlElement|YXmlText} */\n      /** @type {ContentType} */\n      n.content.type\n    ) : null;\n  }\n  _copy() {\n    return new _YXmlText();\n  }\n  /**\n   * @return {YXmlText}\n   */\n  clone() {\n    const text2 = new _YXmlText();\n    text2.applyDelta(this.toDelta());\n    return text2;\n  }\n  /**\n   * Creates a Dom Element that mirrors this YXmlText.\n   *\n   * @param {Document} [_document=document] The document object (you must define\n   *                                        this when calling this method in\n   *                                        nodejs)\n   * @param {Object<string, any>} [hooks] Optional property to customize how hooks\n   *                                             are presented in the DOM\n   * @param {any} [binding] You should not set this property. This is\n   *                               used if DomBinding wants to create a\n   *                               association to the created DOM type.\n   * @return {Text} The {@link https://developer.mozilla.org/en-US/docs/Web/API/Element|Dom Element}\n   *\n   * @public\n   */\n  toDOM(_document = document, hooks, binding) {\n    const dom = _document.createTextNode(this.toString());\n    if (binding !== void 0) {\n      binding._createAssociation(dom, this);\n    }\n    return dom;\n  }\n  toString() {\n    return this.toDelta().map((delta) => {\n      const nestedNodes = [];\n      for (const nodeName in delta.attributes) {\n        const attrs = [];\n        for (const key in delta.attributes[nodeName]) {\n          attrs.push({ key, value: delta.attributes[nodeName][key] });\n        }\n        attrs.sort((a, b) => a.key < b.key ? -1 : 1);\n        nestedNodes.push({ nodeName, attrs });\n      }\n      nestedNodes.sort((a, b) => a.nodeName < b.nodeName ? -1 : 1);\n      let str = \"\";\n      for (let i = 0; i < nestedNodes.length; i++) {\n        const node = nestedNodes[i];\n        str += `<${node.nodeName}`;\n        for (let j = 0; j < node.attrs.length; j++) {\n          const attr = node.attrs[j];\n          str += ` ${attr.key}=\"${attr.value}\"`;\n        }\n        str += \">\";\n      }\n      str += delta.insert;\n      for (let i = nestedNodes.length - 1; i >= 0; i--) {\n        str += `</${nestedNodes[i].nodeName}>`;\n      }\n      return str;\n    }).join(\"\");\n  }\n  /**\n   * @return {string}\n   */\n  toJSON() {\n    return this.toString();\n  }\n  /**\n   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder\n   */\n  _write(encoder) {\n    encoder.writeTypeRef(YXmlTextRefID);\n  }\n};\nvar readYXmlText = (decoder) => new YXmlText();\nvar AbstractStruct = class {\n  /**\n   * @param {ID} id\n   * @param {number} length\n   */\n  constructor(id2, length3) {\n    this.id = id2;\n    this.length = length3;\n  }\n  /**\n   * @type {boolean}\n   */\n  get deleted() {\n    throw methodUnimplemented();\n  }\n  /**\n   * Merge this struct with the item to the right.\n   * This method is already assuming that `this.id.clock + this.length === this.id.clock`.\n   * Also this method does *not* remove right from StructStore!\n   * @param {AbstractStruct} right\n   * @return {boolean} wether this merged with right\n   */\n  mergeWith(right) {\n    return false;\n  }\n  /**\n   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder The encoder to write data to.\n   * @param {number} offset\n   * @param {number} encodingRef\n   */\n  write(encoder, offset, encodingRef) {\n    throw methodUnimplemented();\n  }\n  /**\n   * @param {Transaction} transaction\n   * @param {number} offset\n   */\n  integrate(transaction, offset) {\n    throw methodUnimplemented();\n  }\n};\nvar structGCRefNumber = 0;\nvar GC = class extends AbstractStruct {\n  get deleted() {\n    return true;\n  }\n  delete() {\n  }\n  /**\n   * @param {GC} right\n   * @return {boolean}\n   */\n  mergeWith(right) {\n    if (this.constructor !== right.constructor) {\n      return false;\n    }\n    this.length += right.length;\n    return true;\n  }\n  /**\n   * @param {Transaction} transaction\n   * @param {number} offset\n   */\n  integrate(transaction, offset) {\n    if (offset > 0) {\n      this.id.clock += offset;\n      this.length -= offset;\n    }\n    addStruct(transaction.doc.store, this);\n  }\n  /**\n   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder\n   * @param {number} offset\n   */\n  write(encoder, offset) {\n    encoder.writeInfo(structGCRefNumber);\n    encoder.writeLen(this.length - offset);\n  }\n  /**\n   * @param {Transaction} transaction\n   * @param {StructStore} store\n   * @return {null | number}\n   */\n  getMissing(transaction, store) {\n    return null;\n  }\n};\nvar ContentBinary = class _ContentBinary {\n  /**\n   * @param {Uint8Array} content\n   */\n  constructor(content) {\n    this.content = content;\n  }\n  /**\n   * @return {number}\n   */\n  getLength() {\n    return 1;\n  }\n  /**\n   * @return {Array<any>}\n   */\n  getContent() {\n    return [this.content];\n  }\n  /**\n   * @return {boolean}\n   */\n  isCountable() {\n    return true;\n  }\n  /**\n   * @return {ContentBinary}\n   */\n  copy() {\n    return new _ContentBinary(this.content);\n  }\n  /**\n   * @param {number} offset\n   * @return {ContentBinary}\n   */\n  splice(offset) {\n    throw methodUnimplemented();\n  }\n  /**\n   * @param {ContentBinary} right\n   * @return {boolean}\n   */\n  mergeWith(right) {\n    return false;\n  }\n  /**\n   * @param {Transaction} transaction\n   * @param {Item} item\n   */\n  integrate(transaction, item) {\n  }\n  /**\n   * @param {Transaction} transaction\n   */\n  delete(transaction) {\n  }\n  /**\n   * @param {StructStore} store\n   */\n  gc(store) {\n  }\n  /**\n   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder\n   * @param {number} offset\n   */\n  write(encoder, offset) {\n    encoder.writeBuf(this.content);\n  }\n  /**\n   * @return {number}\n   */\n  getRef() {\n    return 3;\n  }\n};\nvar readContentBinary = (decoder) => new ContentBinary(decoder.readBuf());\nvar ContentDeleted = class _ContentDeleted {\n  /**\n   * @param {number} len\n   */\n  constructor(len) {\n    this.len = len;\n  }\n  /**\n   * @return {number}\n   */\n  getLength() {\n    return this.len;\n  }\n  /**\n   * @return {Array<any>}\n   */\n  getContent() {\n    return [];\n  }\n  /**\n   * @return {boolean}\n   */\n  isCountable() {\n    return false;\n  }\n  /**\n   * @return {ContentDeleted}\n   */\n  copy() {\n    return new _ContentDeleted(this.len);\n  }\n  /**\n   * @param {number} offset\n   * @return {ContentDeleted}\n   */\n  splice(offset) {\n    const right = new _ContentDeleted(this.len - offset);\n    this.len = offset;\n    return right;\n  }\n  /**\n   * @param {ContentDeleted} right\n   * @return {boolean}\n   */\n  mergeWith(right) {\n    this.len += right.len;\n    return true;\n  }\n  /**\n   * @param {Transaction} transaction\n   * @param {Item} item\n   */\n  integrate(transaction, item) {\n    addToDeleteSet(transaction.deleteSet, item.id.client, item.id.clock, this.len);\n    item.markDeleted();\n  }\n  /**\n   * @param {Transaction} transaction\n   */\n  delete(transaction) {\n  }\n  /**\n   * @param {StructStore} store\n   */\n  gc(store) {\n  }\n  /**\n   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder\n   * @param {number} offset\n   */\n  write(encoder, offset) {\n    encoder.writeLen(this.len - offset);\n  }\n  /**\n   * @return {number}\n   */\n  getRef() {\n    return 1;\n  }\n};\nvar readContentDeleted = (decoder) => new ContentDeleted(decoder.readLen());\nvar createDocFromOpts = (guid, opts) => new Doc({ guid, ...opts, shouldLoad: opts.shouldLoad || opts.autoLoad || false });\nvar ContentDoc = class _ContentDoc {\n  /**\n   * @param {Doc} doc\n   */\n  constructor(doc2) {\n    if (doc2._item) {\n      console.error(\"This document was already integrated as a sub-document. You should create a second instance instead with the same guid.\");\n    }\n    this.doc = doc2;\n    const opts = {};\n    this.opts = opts;\n    if (!doc2.gc) {\n      opts.gc = false;\n    }\n    if (doc2.autoLoad) {\n      opts.autoLoad = true;\n    }\n    if (doc2.meta !== null) {\n      opts.meta = doc2.meta;\n    }\n  }\n  /**\n   * @return {number}\n   */\n  getLength() {\n    return 1;\n  }\n  /**\n   * @return {Array<any>}\n   */\n  getContent() {\n    return [this.doc];\n  }\n  /**\n   * @return {boolean}\n   */\n  isCountable() {\n    return true;\n  }\n  /**\n   * @return {ContentDoc}\n   */\n  copy() {\n    return new _ContentDoc(createDocFromOpts(this.doc.guid, this.opts));\n  }\n  /**\n   * @param {number} offset\n   * @return {ContentDoc}\n   */\n  splice(offset) {\n    throw methodUnimplemented();\n  }\n  /**\n   * @param {ContentDoc} right\n   * @return {boolean}\n   */\n  mergeWith(right) {\n    return false;\n  }\n  /**\n   * @param {Transaction} transaction\n   * @param {Item} item\n   */\n  integrate(transaction, item) {\n    this.doc._item = item;\n    transaction.subdocsAdded.add(this.doc);\n    if (this.doc.shouldLoad) {\n      transaction.subdocsLoaded.add(this.doc);\n    }\n  }\n  /**\n   * @param {Transaction} transaction\n   */\n  delete(transaction) {\n    if (transaction.subdocsAdded.has(this.doc)) {\n      transaction.subdocsAdded.delete(this.doc);\n    } else {\n      transaction.subdocsRemoved.add(this.doc);\n    }\n  }\n  /**\n   * @param {StructStore} store\n   */\n  gc(store) {\n  }\n  /**\n   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder\n   * @param {number} offset\n   */\n  write(encoder, offset) {\n    encoder.writeString(this.doc.guid);\n    encoder.writeAny(this.opts);\n  }\n  /**\n   * @return {number}\n   */\n  getRef() {\n    return 9;\n  }\n};\nvar readContentDoc = (decoder) => new ContentDoc(createDocFromOpts(decoder.readString(), decoder.readAny()));\nvar ContentEmbed = class _ContentEmbed {\n  /**\n   * @param {Object} embed\n   */\n  constructor(embed) {\n    this.embed = embed;\n  }\n  /**\n   * @return {number}\n   */\n  getLength() {\n    return 1;\n  }\n  /**\n   * @return {Array<any>}\n   */\n  getContent() {\n    return [this.embed];\n  }\n  /**\n   * @return {boolean}\n   */\n  isCountable() {\n    return true;\n  }\n  /**\n   * @return {ContentEmbed}\n   */\n  copy() {\n    return new _ContentEmbed(this.embed);\n  }\n  /**\n   * @param {number} offset\n   * @return {ContentEmbed}\n   */\n  splice(offset) {\n    throw methodUnimplemented();\n  }\n  /**\n   * @param {ContentEmbed} right\n   * @return {boolean}\n   */\n  mergeWith(right) {\n    return false;\n  }\n  /**\n   * @param {Transaction} transaction\n   * @param {Item} item\n   */\n  integrate(transaction, item) {\n  }\n  /**\n   * @param {Transaction} transaction\n   */\n  delete(transaction) {\n  }\n  /**\n   * @param {StructStore} store\n   */\n  gc(store) {\n  }\n  /**\n   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder\n   * @param {number} offset\n   */\n  write(encoder, offset) {\n    encoder.writeJSON(this.embed);\n  }\n  /**\n   * @return {number}\n   */\n  getRef() {\n    return 5;\n  }\n};\nvar readContentEmbed = (decoder) => new ContentEmbed(decoder.readJSON());\nvar ContentFormat = class _ContentFormat {\n  /**\n   * @param {string} key\n   * @param {Object} value\n   */\n  constructor(key, value) {\n    this.key = key;\n    this.value = value;\n  }\n  /**\n   * @return {number}\n   */\n  getLength() {\n    return 1;\n  }\n  /**\n   * @return {Array<any>}\n   */\n  getContent() {\n    return [];\n  }\n  /**\n   * @return {boolean}\n   */\n  isCountable() {\n    return false;\n  }\n  /**\n   * @return {ContentFormat}\n   */\n  copy() {\n    return new _ContentFormat(this.key, this.value);\n  }\n  /**\n   * @param {number} _offset\n   * @return {ContentFormat}\n   */\n  splice(_offset) {\n    throw methodUnimplemented();\n  }\n  /**\n   * @param {ContentFormat} _right\n   * @return {boolean}\n   */\n  mergeWith(_right) {\n    return false;\n  }\n  /**\n   * @param {Transaction} _transaction\n   * @param {Item} item\n   */\n  integrate(_transaction, item) {\n    const p = (\n      /** @type {YText} */\n      item.parent\n    );\n    p._searchMarker = null;\n    p._hasFormatting = true;\n  }\n  /**\n   * @param {Transaction} transaction\n   */\n  delete(transaction) {\n  }\n  /**\n   * @param {StructStore} store\n   */\n  gc(store) {\n  }\n  /**\n   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder\n   * @param {number} offset\n   */\n  write(encoder, offset) {\n    encoder.writeKey(this.key);\n    encoder.writeJSON(this.value);\n  }\n  /**\n   * @return {number}\n   */\n  getRef() {\n    return 6;\n  }\n};\nvar readContentFormat = (decoder) => new ContentFormat(decoder.readKey(), decoder.readJSON());\nvar ContentJSON = class _ContentJSON {\n  /**\n   * @param {Array<any>} arr\n   */\n  constructor(arr) {\n    this.arr = arr;\n  }\n  /**\n   * @return {number}\n   */\n  getLength() {\n    return this.arr.length;\n  }\n  /**\n   * @return {Array<any>}\n   */\n  getContent() {\n    return this.arr;\n  }\n  /**\n   * @return {boolean}\n   */\n  isCountable() {\n    return true;\n  }\n  /**\n   * @return {ContentJSON}\n   */\n  copy() {\n    return new _ContentJSON(this.arr);\n  }\n  /**\n   * @param {number} offset\n   * @return {ContentJSON}\n   */\n  splice(offset) {\n    const right = new _ContentJSON(this.arr.slice(offset));\n    this.arr = this.arr.slice(0, offset);\n    return right;\n  }\n  /**\n   * @param {ContentJSON} right\n   * @return {boolean}\n   */\n  mergeWith(right) {\n    this.arr = this.arr.concat(right.arr);\n    return true;\n  }\n  /**\n   * @param {Transaction} transaction\n   * @param {Item} item\n   */\n  integrate(transaction, item) {\n  }\n  /**\n   * @param {Transaction} transaction\n   */\n  delete(transaction) {\n  }\n  /**\n   * @param {StructStore} store\n   */\n  gc(store) {\n  }\n  /**\n   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder\n   * @param {number} offset\n   */\n  write(encoder, offset) {\n    const len = this.arr.length;\n    encoder.writeLen(len - offset);\n    for (let i = offset; i < len; i++) {\n      const c = this.arr[i];\n      encoder.writeString(c === void 0 ? \"undefined\" : JSON.stringify(c));\n    }\n  }\n  /**\n   * @return {number}\n   */\n  getRef() {\n    return 2;\n  }\n};\nvar readContentJSON = (decoder) => {\n  const len = decoder.readLen();\n  const cs = [];\n  for (let i = 0; i < len; i++) {\n    const c = decoder.readString();\n    if (c === \"undefined\") {\n      cs.push(void 0);\n    } else {\n      cs.push(JSON.parse(c));\n    }\n  }\n  return new ContentJSON(cs);\n};\nvar ContentAny = class _ContentAny {\n  /**\n   * @param {Array<any>} arr\n   */\n  constructor(arr) {\n    this.arr = arr;\n  }\n  /**\n   * @return {number}\n   */\n  getLength() {\n    return this.arr.length;\n  }\n  /**\n   * @return {Array<any>}\n   */\n  getContent() {\n    return this.arr;\n  }\n  /**\n   * @return {boolean}\n   */\n  isCountable() {\n    return true;\n  }\n  /**\n   * @return {ContentAny}\n   */\n  copy() {\n    return new _ContentAny(this.arr);\n  }\n  /**\n   * @param {number} offset\n   * @return {ContentAny}\n   */\n  splice(offset) {\n    const right = new _ContentAny(this.arr.slice(offset));\n    this.arr = this.arr.slice(0, offset);\n    return right;\n  }\n  /**\n   * @param {ContentAny} right\n   * @return {boolean}\n   */\n  mergeWith(right) {\n    this.arr = this.arr.concat(right.arr);\n    return true;\n  }\n  /**\n   * @param {Transaction} transaction\n   * @param {Item} item\n   */\n  integrate(transaction, item) {\n  }\n  /**\n   * @param {Transaction} transaction\n   */\n  delete(transaction) {\n  }\n  /**\n   * @param {StructStore} store\n   */\n  gc(store) {\n  }\n  /**\n   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder\n   * @param {number} offset\n   */\n  write(encoder, offset) {\n    const len = this.arr.length;\n    encoder.writeLen(len - offset);\n    for (let i = offset; i < len; i++) {\n      const c = this.arr[i];\n      encoder.writeAny(c);\n    }\n  }\n  /**\n   * @return {number}\n   */\n  getRef() {\n    return 8;\n  }\n};\nvar readContentAny = (decoder) => {\n  const len = decoder.readLen();\n  const cs = [];\n  for (let i = 0; i < len; i++) {\n    cs.push(decoder.readAny());\n  }\n  return new ContentAny(cs);\n};\nvar ContentString = class _ContentString {\n  /**\n   * @param {string} str\n   */\n  constructor(str) {\n    this.str = str;\n  }\n  /**\n   * @return {number}\n   */\n  getLength() {\n    return this.str.length;\n  }\n  /**\n   * @return {Array<any>}\n   */\n  getContent() {\n    return this.str.split(\"\");\n  }\n  /**\n   * @return {boolean}\n   */\n  isCountable() {\n    return true;\n  }\n  /**\n   * @return {ContentString}\n   */\n  copy() {\n    return new _ContentString(this.str);\n  }\n  /**\n   * @param {number} offset\n   * @return {ContentString}\n   */\n  splice(offset) {\n    const right = new _ContentString(this.str.slice(offset));\n    this.str = this.str.slice(0, offset);\n    const firstCharCode = this.str.charCodeAt(offset - 1);\n    if (firstCharCode >= 55296 && firstCharCode <= 56319) {\n      this.str = this.str.slice(0, offset - 1) + \"\";\n      right.str = \"\" + right.str.slice(1);\n    }\n    return right;\n  }\n  /**\n   * @param {ContentString} right\n   * @return {boolean}\n   */\n  mergeWith(right) {\n    this.str += right.str;\n    return true;\n  }\n  /**\n   * @param {Transaction} transaction\n   * @param {Item} item\n   */\n  integrate(transaction, item) {\n  }\n  /**\n   * @param {Transaction} transaction\n   */\n  delete(transaction) {\n  }\n  /**\n   * @param {StructStore} store\n   */\n  gc(store) {\n  }\n  /**\n   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder\n   * @param {number} offset\n   */\n  write(encoder, offset) {\n    encoder.writeString(offset === 0 ? this.str : this.str.slice(offset));\n  }\n  /**\n   * @return {number}\n   */\n  getRef() {\n    return 4;\n  }\n};\nvar readContentString = (decoder) => new ContentString(decoder.readString());\nvar typeRefs = [\n  readYArray,\n  readYMap,\n  readYText,\n  readYXmlElement,\n  readYXmlFragment,\n  readYXmlHook,\n  readYXmlText\n];\nvar YArrayRefID = 0;\nvar YMapRefID = 1;\nvar YTextRefID = 2;\nvar YXmlElementRefID = 3;\nvar YXmlFragmentRefID = 4;\nvar YXmlHookRefID = 5;\nvar YXmlTextRefID = 6;\nvar ContentType = class _ContentType {\n  /**\n   * @param {AbstractType<any>} type\n   */\n  constructor(type) {\n    this.type = type;\n  }\n  /**\n   * @return {number}\n   */\n  getLength() {\n    return 1;\n  }\n  /**\n   * @return {Array<any>}\n   */\n  getContent() {\n    return [this.type];\n  }\n  /**\n   * @return {boolean}\n   */\n  isCountable() {\n    return true;\n  }\n  /**\n   * @return {ContentType}\n   */\n  copy() {\n    return new _ContentType(this.type._copy());\n  }\n  /**\n   * @param {number} offset\n   * @return {ContentType}\n   */\n  splice(offset) {\n    throw methodUnimplemented();\n  }\n  /**\n   * @param {ContentType} right\n   * @return {boolean}\n   */\n  mergeWith(right) {\n    return false;\n  }\n  /**\n   * @param {Transaction} transaction\n   * @param {Item} item\n   */\n  integrate(transaction, item) {\n    this.type._integrate(transaction.doc, item);\n  }\n  /**\n   * @param {Transaction} transaction\n   */\n  delete(transaction) {\n    let item = this.type._start;\n    while (item !== null) {\n      if (!item.deleted) {\n        item.delete(transaction);\n      } else if (item.id.clock < (transaction.beforeState.get(item.id.client) || 0)) {\n        transaction._mergeStructs.push(item);\n      }\n      item = item.right;\n    }\n    this.type._map.forEach((item2) => {\n      if (!item2.deleted) {\n        item2.delete(transaction);\n      } else if (item2.id.clock < (transaction.beforeState.get(item2.id.client) || 0)) {\n        transaction._mergeStructs.push(item2);\n      }\n    });\n    transaction.changed.delete(this.type);\n  }\n  /**\n   * @param {StructStore} store\n   */\n  gc(store) {\n    let item = this.type._start;\n    while (item !== null) {\n      item.gc(store, true);\n      item = item.right;\n    }\n    this.type._start = null;\n    this.type._map.forEach(\n      /** @param {Item | null} item */\n      (item2) => {\n        while (item2 !== null) {\n          item2.gc(store, true);\n          item2 = item2.left;\n        }\n      }\n    );\n    this.type._map = /* @__PURE__ */ new Map();\n  }\n  /**\n   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder\n   * @param {number} offset\n   */\n  write(encoder, offset) {\n    this.type._write(encoder);\n  }\n  /**\n   * @return {number}\n   */\n  getRef() {\n    return 7;\n  }\n};\nvar readContentType = (decoder) => new ContentType(typeRefs[decoder.readTypeRef()](decoder));\nvar followRedone = (store, id2) => {\n  let nextID = id2;\n  let diff = 0;\n  let item;\n  do {\n    if (diff > 0) {\n      nextID = createID(nextID.client, nextID.clock + diff);\n    }\n    item = getItem(store, nextID);\n    diff = nextID.clock - item.id.clock;\n    nextID = item.redone;\n  } while (nextID !== null && item instanceof Item);\n  return {\n    item,\n    diff\n  };\n};\nvar keepItem = (item, keep) => {\n  while (item !== null && item.keep !== keep) {\n    item.keep = keep;\n    item = /** @type {AbstractType<any>} */\n    item.parent._item;\n  }\n};\nvar splitItem = (transaction, leftItem, diff) => {\n  const { client, clock } = leftItem.id;\n  const rightItem = new Item(\n    createID(client, clock + diff),\n    leftItem,\n    createID(client, clock + diff - 1),\n    leftItem.right,\n    leftItem.rightOrigin,\n    leftItem.parent,\n    leftItem.parentSub,\n    leftItem.content.splice(diff)\n  );\n  if (leftItem.deleted) {\n    rightItem.markDeleted();\n  }\n  if (leftItem.keep) {\n    rightItem.keep = true;\n  }\n  if (leftItem.redone !== null) {\n    rightItem.redone = createID(leftItem.redone.client, leftItem.redone.clock + diff);\n  }\n  leftItem.right = rightItem;\n  if (rightItem.right !== null) {\n    rightItem.right.left = rightItem;\n  }\n  transaction._mergeStructs.push(rightItem);\n  if (rightItem.parentSub !== null && rightItem.right === null) {\n    rightItem.parent._map.set(rightItem.parentSub, rightItem);\n  }\n  leftItem.length = diff;\n  return rightItem;\n};\nvar isDeletedByUndoStack = (stack, id2) => some(\n  stack,\n  /** @param {StackItem} s */\n  (s) => isDeleted(s.deletions, id2)\n);\nvar redoItem = (transaction, item, redoitems, itemsToDelete, ignoreRemoteMapChanges, um) => {\n  const doc2 = transaction.doc;\n  const store = doc2.store;\n  const ownClientID = doc2.clientID;\n  const redone = item.redone;\n  if (redone !== null) {\n    return getItemCleanStart(transaction, redone);\n  }\n  let parentItem = (\n    /** @type {AbstractType<any>} */\n    item.parent._item\n  );\n  let left = null;\n  let right;\n  if (parentItem !== null && parentItem.deleted === true) {\n    if (parentItem.redone === null && (!redoitems.has(parentItem) || redoItem(transaction, parentItem, redoitems, itemsToDelete, ignoreRemoteMapChanges, um) === null)) {\n      return null;\n    }\n    while (parentItem.redone !== null) {\n      parentItem = getItemCleanStart(transaction, parentItem.redone);\n    }\n  }\n  const parentType = parentItem === null ? (\n    /** @type {AbstractType<any>} */\n    item.parent\n  ) : (\n    /** @type {ContentType} */\n    parentItem.content.type\n  );\n  if (item.parentSub === null) {\n    left = item.left;\n    right = item;\n    while (left !== null) {\n      let leftTrace = left;\n      while (leftTrace !== null && /** @type {AbstractType<any>} */\n      leftTrace.parent._item !== parentItem) {\n        leftTrace = leftTrace.redone === null ? null : getItemCleanStart(transaction, leftTrace.redone);\n      }\n      if (leftTrace !== null && /** @type {AbstractType<any>} */\n      leftTrace.parent._item === parentItem) {\n        left = leftTrace;\n        break;\n      }\n      left = left.left;\n    }\n    while (right !== null) {\n      let rightTrace = right;\n      while (rightTrace !== null && /** @type {AbstractType<any>} */\n      rightTrace.parent._item !== parentItem) {\n        rightTrace = rightTrace.redone === null ? null : getItemCleanStart(transaction, rightTrace.redone);\n      }\n      if (rightTrace !== null && /** @type {AbstractType<any>} */\n      rightTrace.parent._item === parentItem) {\n        right = rightTrace;\n        break;\n      }\n      right = right.right;\n    }\n  } else {\n    right = null;\n    if (item.right && !ignoreRemoteMapChanges) {\n      left = item;\n      while (left !== null && left.right !== null && (left.right.redone || isDeleted(itemsToDelete, left.right.id) || isDeletedByUndoStack(um.undoStack, left.right.id) || isDeletedByUndoStack(um.redoStack, left.right.id))) {\n        left = left.right;\n        while (left.redone)\n          left = getItemCleanStart(transaction, left.redone);\n      }\n      if (left && left.right !== null) {\n        return null;\n      }\n    } else {\n      left = parentType._map.get(item.parentSub) || null;\n    }\n  }\n  const nextClock = getState(store, ownClientID);\n  const nextId = createID(ownClientID, nextClock);\n  const redoneItem = new Item(\n    nextId,\n    left,\n    left && left.lastId,\n    right,\n    right && right.id,\n    parentType,\n    item.parentSub,\n    item.content.copy()\n  );\n  item.redone = nextId;\n  keepItem(redoneItem, true);\n  redoneItem.integrate(transaction, 0);\n  return redoneItem;\n};\nvar Item = class _Item extends AbstractStruct {\n  /**\n   * @param {ID} id\n   * @param {Item | null} left\n   * @param {ID | null} origin\n   * @param {Item | null} right\n   * @param {ID | null} rightOrigin\n   * @param {AbstractType<any>|ID|null} parent Is a type if integrated, is null if it is possible to copy parent from left or right, is ID before integration to search for it.\n   * @param {string | null} parentSub\n   * @param {AbstractContent} content\n   */\n  constructor(id2, left, origin, right, rightOrigin, parent, parentSub, content) {\n    super(id2, content.getLength());\n    this.origin = origin;\n    this.left = left;\n    this.right = right;\n    this.rightOrigin = rightOrigin;\n    this.parent = parent;\n    this.parentSub = parentSub;\n    this.redone = null;\n    this.content = content;\n    this.info = this.content.isCountable() ? BIT2 : 0;\n  }\n  /**\n   * This is used to mark the item as an indexed fast-search marker\n   *\n   * @type {boolean}\n   */\n  set marker(isMarked) {\n    if ((this.info & BIT4) > 0 !== isMarked) {\n      this.info ^= BIT4;\n    }\n  }\n  get marker() {\n    return (this.info & BIT4) > 0;\n  }\n  /**\n   * If true, do not garbage collect this Item.\n   */\n  get keep() {\n    return (this.info & BIT1) > 0;\n  }\n  set keep(doKeep) {\n    if (this.keep !== doKeep) {\n      this.info ^= BIT1;\n    }\n  }\n  get countable() {\n    return (this.info & BIT2) > 0;\n  }\n  /**\n   * Whether this item was deleted or not.\n   * @type {Boolean}\n   */\n  get deleted() {\n    return (this.info & BIT3) > 0;\n  }\n  set deleted(doDelete) {\n    if (this.deleted !== doDelete) {\n      this.info ^= BIT3;\n    }\n  }\n  markDeleted() {\n    this.info |= BIT3;\n  }\n  /**\n   * Return the creator clientID of the missing op or define missing items and return null.\n   *\n   * @param {Transaction} transaction\n   * @param {StructStore} store\n   * @return {null | number}\n   */\n  getMissing(transaction, store) {\n    if (this.origin && this.origin.client !== this.id.client && this.origin.clock >= getState(store, this.origin.client)) {\n      return this.origin.client;\n    }\n    if (this.rightOrigin && this.rightOrigin.client !== this.id.client && this.rightOrigin.clock >= getState(store, this.rightOrigin.client)) {\n      return this.rightOrigin.client;\n    }\n    if (this.parent && this.parent.constructor === ID && this.id.client !== this.parent.client && this.parent.clock >= getState(store, this.parent.client)) {\n      return this.parent.client;\n    }\n    if (this.origin) {\n      this.left = getItemCleanEnd(transaction, store, this.origin);\n      this.origin = this.left.lastId;\n    }\n    if (this.rightOrigin) {\n      this.right = getItemCleanStart(transaction, this.rightOrigin);\n      this.rightOrigin = this.right.id;\n    }\n    if (this.left && this.left.constructor === GC || this.right && this.right.constructor === GC) {\n      this.parent = null;\n    }\n    if (!this.parent) {\n      if (this.left && this.left.constructor === _Item) {\n        this.parent = this.left.parent;\n        this.parentSub = this.left.parentSub;\n      }\n      if (this.right && this.right.constructor === _Item) {\n        this.parent = this.right.parent;\n        this.parentSub = this.right.parentSub;\n      }\n    } else if (this.parent.constructor === ID) {\n      const parentItem = getItem(store, this.parent);\n      if (parentItem.constructor === GC) {\n        this.parent = null;\n      } else {\n        this.parent = /** @type {ContentType} */\n        parentItem.content.type;\n      }\n    }\n    return null;\n  }\n  /**\n   * @param {Transaction} transaction\n   * @param {number} offset\n   */\n  integrate(transaction, offset) {\n    if (offset > 0) {\n      this.id.clock += offset;\n      this.left = getItemCleanEnd(transaction, transaction.doc.store, createID(this.id.client, this.id.clock - 1));\n      this.origin = this.left.lastId;\n      this.content = this.content.splice(offset);\n      this.length -= offset;\n    }\n    if (this.parent) {\n      if (!this.left && (!this.right || this.right.left !== null) || this.left && this.left.right !== this.right) {\n        let left = this.left;\n        let o;\n        if (left !== null) {\n          o = left.right;\n        } else if (this.parentSub !== null) {\n          o = /** @type {AbstractType<any>} */\n          this.parent._map.get(this.parentSub) || null;\n          while (o !== null && o.left !== null) {\n            o = o.left;\n          }\n        } else {\n          o = /** @type {AbstractType<any>} */\n          this.parent._start;\n        }\n        const conflictingItems = /* @__PURE__ */ new Set();\n        const itemsBeforeOrigin = /* @__PURE__ */ new Set();\n        while (o !== null && o !== this.right) {\n          itemsBeforeOrigin.add(o);\n          conflictingItems.add(o);\n          if (compareIDs(this.origin, o.origin)) {\n            if (o.id.client < this.id.client) {\n              left = o;\n              conflictingItems.clear();\n            } else if (compareIDs(this.rightOrigin, o.rightOrigin)) {\n              break;\n            }\n          } else if (o.origin !== null && itemsBeforeOrigin.has(getItem(transaction.doc.store, o.origin))) {\n            if (!conflictingItems.has(getItem(transaction.doc.store, o.origin))) {\n              left = o;\n              conflictingItems.clear();\n            }\n          } else {\n            break;\n          }\n          o = o.right;\n        }\n        this.left = left;\n      }\n      if (this.left !== null) {\n        const right = this.left.right;\n        this.right = right;\n        this.left.right = this;\n      } else {\n        let r;\n        if (this.parentSub !== null) {\n          r = /** @type {AbstractType<any>} */\n          this.parent._map.get(this.parentSub) || null;\n          while (r !== null && r.left !== null) {\n            r = r.left;\n          }\n        } else {\n          r = /** @type {AbstractType<any>} */\n          this.parent._start;\n          this.parent._start = this;\n        }\n        this.right = r;\n      }\n      if (this.right !== null) {\n        this.right.left = this;\n      } else if (this.parentSub !== null) {\n        this.parent._map.set(this.parentSub, this);\n        if (this.left !== null) {\n          this.left.delete(transaction);\n        }\n      }\n      if (this.parentSub === null && this.countable && !this.deleted) {\n        this.parent._length += this.length;\n      }\n      addStruct(transaction.doc.store, this);\n      this.content.integrate(transaction, this);\n      addChangedTypeToTransaction(\n        transaction,\n        /** @type {AbstractType<any>} */\n        this.parent,\n        this.parentSub\n      );\n      if (\n        /** @type {AbstractType<any>} */\n        this.parent._item !== null && /** @type {AbstractType<any>} */\n        this.parent._item.deleted || this.parentSub !== null && this.right !== null\n      ) {\n        this.delete(transaction);\n      }\n    } else {\n      new GC(this.id, this.length).integrate(transaction, 0);\n    }\n  }\n  /**\n   * Returns the next non-deleted item\n   */\n  get next() {\n    let n = this.right;\n    while (n !== null && n.deleted) {\n      n = n.right;\n    }\n    return n;\n  }\n  /**\n   * Returns the previous non-deleted item\n   */\n  get prev() {\n    let n = this.left;\n    while (n !== null && n.deleted) {\n      n = n.left;\n    }\n    return n;\n  }\n  /**\n   * Computes the last content address of this Item.\n   */\n  get lastId() {\n    return this.length === 1 ? this.id : createID(this.id.client, this.id.clock + this.length - 1);\n  }\n  /**\n   * Try to merge two items\n   *\n   * @param {Item} right\n   * @return {boolean}\n   */\n  mergeWith(right) {\n    if (this.constructor === right.constructor && compareIDs(right.origin, this.lastId) && this.right === right && compareIDs(this.rightOrigin, right.rightOrigin) && this.id.client === right.id.client && this.id.clock + this.length === right.id.clock && this.deleted === right.deleted && this.redone === null && right.redone === null && this.content.constructor === right.content.constructor && this.content.mergeWith(right.content)) {\n      const searchMarker = (\n        /** @type {AbstractType<any>} */\n        this.parent._searchMarker\n      );\n      if (searchMarker) {\n        searchMarker.forEach((marker) => {\n          if (marker.p === right) {\n            marker.p = this;\n            if (!this.deleted && this.countable) {\n              marker.index -= this.length;\n            }\n          }\n        });\n      }\n      if (right.keep) {\n        this.keep = true;\n      }\n      this.right = right.right;\n      if (this.right !== null) {\n        this.right.left = this;\n      }\n      this.length += right.length;\n      return true;\n    }\n    return false;\n  }\n  /**\n   * Mark this Item as deleted.\n   *\n   * @param {Transaction} transaction\n   */\n  delete(transaction) {\n    if (!this.deleted) {\n      const parent = (\n        /** @type {AbstractType<any>} */\n        this.parent\n      );\n      if (this.countable && this.parentSub === null) {\n        parent._length -= this.length;\n      }\n      this.markDeleted();\n      addToDeleteSet(transaction.deleteSet, this.id.client, this.id.clock, this.length);\n      addChangedTypeToTransaction(transaction, parent, this.parentSub);\n      this.content.delete(transaction);\n    }\n  }\n  /**\n   * @param {StructStore} store\n   * @param {boolean} parentGCd\n   */\n  gc(store, parentGCd) {\n    if (!this.deleted) {\n      throw unexpectedCase();\n    }\n    this.content.gc(store);\n    if (parentGCd) {\n      replaceStruct(store, this, new GC(this.id, this.length));\n    } else {\n      this.content = new ContentDeleted(this.length);\n    }\n  }\n  /**\n   * Transform the properties of this type to binary and write it to an\n   * BinaryEncoder.\n   *\n   * This is called when this Item is sent to a remote peer.\n   *\n   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder The encoder to write data to.\n   * @param {number} offset\n   */\n  write(encoder, offset) {\n    const origin = offset > 0 ? createID(this.id.client, this.id.clock + offset - 1) : this.origin;\n    const rightOrigin = this.rightOrigin;\n    const parentSub = this.parentSub;\n    const info = this.content.getRef() & BITS5 | (origin === null ? 0 : BIT8) | // origin is defined\n    (rightOrigin === null ? 0 : BIT7) | // right origin is defined\n    (parentSub === null ? 0 : BIT6);\n    encoder.writeInfo(info);\n    if (origin !== null) {\n      encoder.writeLeftID(origin);\n    }\n    if (rightOrigin !== null) {\n      encoder.writeRightID(rightOrigin);\n    }\n    if (origin === null && rightOrigin === null) {\n      const parent = (\n        /** @type {AbstractType<any>} */\n        this.parent\n      );\n      if (parent._item !== void 0) {\n        const parentItem = parent._item;\n        if (parentItem === null) {\n          const ykey = findRootTypeKey(parent);\n          encoder.writeParentInfo(true);\n          encoder.writeString(ykey);\n        } else {\n          encoder.writeParentInfo(false);\n          encoder.writeLeftID(parentItem.id);\n        }\n      } else if (parent.constructor === String) {\n        encoder.writeParentInfo(true);\n        encoder.writeString(parent);\n      } else if (parent.constructor === ID) {\n        encoder.writeParentInfo(false);\n        encoder.writeLeftID(parent);\n      } else {\n        unexpectedCase();\n      }\n      if (parentSub !== null) {\n        encoder.writeString(parentSub);\n      }\n    }\n    this.content.write(encoder, offset);\n  }\n};\nvar readItemContent = (decoder, info) => contentRefs[info & BITS5](decoder);\nvar contentRefs = [\n  () => {\n    unexpectedCase();\n  },\n  // GC is not ItemContent\n  readContentDeleted,\n  // 1\n  readContentJSON,\n  // 2\n  readContentBinary,\n  // 3\n  readContentString,\n  // 4\n  readContentEmbed,\n  // 5\n  readContentFormat,\n  // 6\n  readContentType,\n  // 7\n  readContentAny,\n  // 8\n  readContentDoc,\n  // 9\n  () => {\n    unexpectedCase();\n  }\n  // 10 - Skip is not ItemContent\n];\nvar structSkipRefNumber = 10;\nvar Skip = class extends AbstractStruct {\n  get deleted() {\n    return true;\n  }\n  delete() {\n  }\n  /**\n   * @param {Skip} right\n   * @return {boolean}\n   */\n  mergeWith(right) {\n    if (this.constructor !== right.constructor) {\n      return false;\n    }\n    this.length += right.length;\n    return true;\n  }\n  /**\n   * @param {Transaction} transaction\n   * @param {number} offset\n   */\n  integrate(transaction, offset) {\n    unexpectedCase();\n  }\n  /**\n   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder\n   * @param {number} offset\n   */\n  write(encoder, offset) {\n    encoder.writeInfo(structSkipRefNumber);\n    writeVarUint(encoder.restEncoder, this.length - offset);\n  }\n  /**\n   * @param {Transaction} transaction\n   * @param {StructStore} store\n   * @return {null | number}\n   */\n  getMissing(transaction, store) {\n    return null;\n  }\n};\nvar glo = (\n  /** @type {any} */\n  typeof globalThis !== \"undefined\" ? globalThis : typeof window !== \"undefined\" ? window : typeof global !== \"undefined\" ? global : {}\n);\nvar importIdentifier = \"__ $YJS$ __\";\nif (glo[importIdentifier] === true) {\n  console.error(\"Yjs was already imported. This breaks constructor checks and will lead to issues! - https://github.com/yjs/yjs/issues/438\");\n}\nglo[importIdentifier] = true;\nexport {\n  AbsolutePosition,\n  AbstractConnector,\n  AbstractStruct,\n  AbstractType,\n  YArray as Array,\n  ContentAny,\n  ContentBinary,\n  ContentDeleted,\n  ContentEmbed,\n  ContentFormat,\n  ContentJSON,\n  ContentString,\n  ContentType,\n  Doc,\n  GC,\n  ID,\n  Item,\n  YMap as Map,\n  PermanentUserData,\n  RelativePosition,\n  Snapshot,\n  YText as Text,\n  Transaction,\n  UndoManager,\n  UpdateEncoderV1,\n  YXmlElement as XmlElement,\n  YXmlFragment as XmlFragment,\n  YXmlHook as XmlHook,\n  YXmlText as XmlText,\n  YArrayEvent,\n  YEvent,\n  YMapEvent,\n  YTextEvent,\n  YXmlEvent,\n  applyUpdate,\n  applyUpdateV2,\n  cleanupYTextFormatting,\n  compareIDs,\n  compareRelativePositions,\n  convertUpdateFormatV1ToV2,\n  convertUpdateFormatV2ToV1,\n  createAbsolutePositionFromRelativePosition,\n  createDeleteSet,\n  createDeleteSetFromStructStore,\n  createDocFromSnapshot,\n  createID,\n  createRelativePositionFromJSON,\n  createRelativePositionFromTypeIndex,\n  createSnapshot,\n  decodeRelativePosition,\n  decodeSnapshot,\n  decodeSnapshotV2,\n  decodeStateVector,\n  decodeUpdate,\n  decodeUpdateV2,\n  diffUpdate,\n  diffUpdateV2,\n  emptySnapshot,\n  encodeRelativePosition,\n  encodeSnapshot,\n  encodeSnapshotV2,\n  encodeStateAsUpdate,\n  encodeStateAsUpdateV2,\n  encodeStateVector,\n  encodeStateVectorFromUpdate,\n  encodeStateVectorFromUpdateV2,\n  equalDeleteSets,\n  equalSnapshots,\n  findIndexSS,\n  findRootTypeKey,\n  getItem,\n  getState,\n  getTypeChildren,\n  isDeleted,\n  isParentOf,\n  iterateDeletedStructs,\n  logType,\n  logUpdate,\n  logUpdateV2,\n  mergeUpdates,\n  mergeUpdatesV2,\n  obfuscateUpdate,\n  obfuscateUpdateV2,\n  parseUpdateMeta,\n  parseUpdateMetaV2,\n  readUpdate,\n  readUpdateV2,\n  relativePositionToJSON,\n  snapshot,\n  snapshotContainsUpdate,\n  transact,\n  tryGc,\n  typeListToArraySnapshot,\n  typeMapGetSnapshot\n};\n//# sourceMappingURL=yjs.js.map\n",
      "start": 1699405180683,
      "end": 1699405180688,
      "sourcemaps": null
    },
    {
      "name": "vite:css",
      "start": 1699405180688,
      "end": 1699405180688,
      "order": "normal"
    },
    {
      "name": "vite:esbuild",
      "start": 1699405180688,
      "end": 1699405180688,
      "order": "normal"
    },
    {
      "name": "vite:json",
      "start": 1699405180688,
      "end": 1699405180688,
      "order": "normal"
    },
    {
      "name": "vite:worker",
      "start": 1699405180688,
      "end": 1699405180688,
      "order": "normal"
    },
    {
      "name": "vite:vue",
      "start": 1699405180688,
      "end": 1699405180688,
      "order": "normal"
    },
    {
      "name": "alioth-connector",
      "start": 1699405180688,
      "end": 1699405180688,
      "order": "normal"
    },
    {
      "name": "vite:define",
      "start": 1699405180688,
      "end": 1699405180688,
      "order": "normal"
    },
    {
      "name": "vite:css-post",
      "start": 1699405180688,
      "end": 1699405180688,
      "order": "normal"
    },
    {
      "name": "vite:worker-import-meta-url",
      "start": 1699405180688,
      "end": 1699405180688,
      "order": "normal"
    },
    {
      "name": "vite:asset-import-meta-url",
      "start": 1699405180688,
      "end": 1699405180688,
      "order": "normal"
    },
    {
      "name": "vite:dynamic-import-vars",
      "start": 1699405180688,
      "end": 1699405180688,
      "order": "normal"
    },
    {
      "name": "vite:import-glob",
      "start": 1699405180688,
      "end": 1699405180688,
      "order": "normal"
    },
    {
      "name": "vite:client-inject",
      "start": 1699405180688,
      "end": 1699405180689,
      "order": "normal"
    },
    {
      "name": "vite:import-analysis",
      "result": "import \"/node_modules/.vite/deps/chunk-UXIASGQL.js?v=4de675e4\";\n\n// ../../node_modules/.pnpm/lib0@0.2.80/node_modules/lib0/map.js\nvar create = () => /* @__PURE__ */ new Map();\nvar copy = (m) => {\n  const r = create();\n  m.forEach((v, k) => {\n    r.set(k, v);\n  });\n  return r;\n};\nvar setIfUndefined = (map3, key, createT) => {\n  let set = map3.get(key);\n  if (set === void 0) {\n    map3.set(key, set = createT());\n  }\n  return set;\n};\nvar map = (m, f) => {\n  const res = [];\n  for (const [key, value] of m) {\n    res.push(f(value, key));\n  }\n  return res;\n};\nvar any = (m, f) => {\n  for (const [key, value] of m) {\n    if (f(value, key)) {\n      return true;\n    }\n  }\n  return false;\n};\n\n// ../../node_modules/.pnpm/lib0@0.2.80/node_modules/lib0/set.js\nvar create2 = () => /* @__PURE__ */ new Set();\n\n// ../../node_modules/.pnpm/lib0@0.2.80/node_modules/lib0/array.js\nvar last = (arr) => arr[arr.length - 1];\nvar appendTo = (dest, src) => {\n  for (let i = 0; i < src.length; i++) {\n    dest.push(src[i]);\n  }\n};\nvar from2 = Array.from;\nvar some = (arr, f) => {\n  for (let i = 0; i < arr.length; i++) {\n    if (f(arr[i], i, arr)) {\n      return true;\n    }\n  }\n  return false;\n};\nvar unfold = (len, f) => {\n  const array = new Array(len);\n  for (let i = 0; i < len; i++) {\n    array[i] = f(i, array);\n  }\n  return array;\n};\nvar isArray = Array.isArray;\n\n// ../../node_modules/.pnpm/lib0@0.2.80/node_modules/lib0/observable.js\nvar Observable = class {\n  constructor() {\n    this._observers = create();\n  }\n  /**\n   * @param {N} name\n   * @param {function} f\n   */\n  on(name, f) {\n    setIfUndefined(this._observers, name, create2).add(f);\n  }\n  /**\n   * @param {N} name\n   * @param {function} f\n   */\n  once(name, f) {\n    const _f = (...args2) => {\n      this.off(name, _f);\n      f(...args2);\n    };\n    this.on(name, _f);\n  }\n  /**\n   * @param {N} name\n   * @param {function} f\n   */\n  off(name, f) {\n    const observers = this._observers.get(name);\n    if (observers !== void 0) {\n      observers.delete(f);\n      if (observers.size === 0) {\n        this._observers.delete(name);\n      }\n    }\n  }\n  /**\n   * Emit a named event. All registered event listeners that listen to the\n   * specified name will receive the event.\n   *\n   * @todo This should catch exceptions\n   *\n   * @param {N} name The event name.\n   * @param {Array<any>} args The arguments that are applied to the event listener.\n   */\n  emit(name, args2) {\n    return from2((this._observers.get(name) || create()).values()).forEach((f) => f(...args2));\n  }\n  destroy() {\n    this._observers = create();\n  }\n};\n\n// ../../node_modules/.pnpm/lib0@0.2.80/node_modules/lib0/math.js\nvar floor = Math.floor;\nvar abs = Math.abs;\nvar min = (a, b) => a < b ? a : b;\nvar max = (a, b) => a > b ? a : b;\nvar isNaN = Number.isNaN;\nvar isNegativeZero = (n) => n !== 0 ? n < 0 : 1 / n < 0;\n\n// ../../node_modules/.pnpm/lib0@0.2.80/node_modules/lib0/string.js\nvar fromCharCode = String.fromCharCode;\nvar fromCodePoint = String.fromCodePoint;\nvar MAX_UTF16_CHARACTER = fromCharCode(65535);\nvar toLowerCase = (s) => s.toLowerCase();\nvar trimLeftRegex = /^\\s*/g;\nvar trimLeft = (s) => s.replace(trimLeftRegex, \"\");\nvar fromCamelCaseRegex = /([A-Z])/g;\nvar fromCamelCase = (s, separator) => trimLeft(s.replace(fromCamelCaseRegex, (match) => `${separator}${toLowerCase(match)}`));\nvar _encodeUtf8Polyfill = (str) => {\n  const encodedString = unescape(encodeURIComponent(str));\n  const len = encodedString.length;\n  const buf = new Uint8Array(len);\n  for (let i = 0; i < len; i++) {\n    buf[i] = /** @type {number} */\n    encodedString.codePointAt(i);\n  }\n  return buf;\n};\nvar utf8TextEncoder = (\n  /** @type {TextEncoder} */\n  typeof TextEncoder !== \"undefined\" ? new TextEncoder() : null\n);\nvar _encodeUtf8Native = (str) => utf8TextEncoder.encode(str);\nvar encodeUtf8 = utf8TextEncoder ? _encodeUtf8Native : _encodeUtf8Polyfill;\nvar utf8TextDecoder = typeof TextDecoder === \"undefined\" ? null : new TextDecoder(\"utf-8\", { fatal: true, ignoreBOM: true });\nif (utf8TextDecoder && utf8TextDecoder.decode(new Uint8Array()).length === 1) {\n  utf8TextDecoder = null;\n}\nvar repeat = (source, n) => unfold(n, () => source).join(\"\");\n\n// ../../node_modules/.pnpm/lib0@0.2.80/node_modules/lib0/conditions.js\nvar undefinedToNull = (v) => v === void 0 ? null : v;\n\n// ../../node_modules/.pnpm/lib0@0.2.80/node_modules/lib0/storage.js\nvar VarStoragePolyfill = class {\n  constructor() {\n    this.map = /* @__PURE__ */ new Map();\n  }\n  /**\n   * @param {string} key\n   * @param {any} newValue\n   */\n  setItem(key, newValue) {\n    this.map.set(key, newValue);\n  }\n  /**\n   * @param {string} key\n   */\n  getItem(key) {\n    return this.map.get(key);\n  }\n};\nvar _localStorage = new VarStoragePolyfill();\nvar usePolyfill = true;\ntry {\n  if (typeof localStorage !== \"undefined\") {\n    _localStorage = localStorage;\n    usePolyfill = false;\n  }\n} catch (e) {\n}\nvar varStorage = _localStorage;\n\n// ../../node_modules/.pnpm/lib0@0.2.80/node_modules/lib0/object.js\nvar assign = Object.assign;\nvar keys = Object.keys;\nvar forEach = (obj, f) => {\n  for (const key in obj) {\n    f(obj[key], key);\n  }\n};\nvar length = (obj) => keys(obj).length;\nvar isEmpty = (obj) => {\n  for (const _k in obj) {\n    return false;\n  }\n  return true;\n};\nvar every = (obj, f) => {\n  for (const key in obj) {\n    if (!f(obj[key], key)) {\n      return false;\n    }\n  }\n  return true;\n};\nvar hasProperty = (obj, key) => Object.prototype.hasOwnProperty.call(obj, key);\nvar equalFlat = (a, b) => a === b || length(a) === length(b) && every(a, (val, key) => (val !== void 0 || hasProperty(b, key)) && b[key] === val);\n\n// ../../node_modules/.pnpm/lib0@0.2.80/node_modules/lib0/function.js\nvar callAll = (fs, args2, i = 0) => {\n  try {\n    for (; i < fs.length; i++) {\n      fs[i](...args2);\n    }\n  } finally {\n    if (i < fs.length) {\n      callAll(fs, args2, i + 1);\n    }\n  }\n};\nvar id = (a) => a;\nvar isOneOf = (value, options) => options.includes(value);\n\n// ../../node_modules/.pnpm/lib0@0.2.80/node_modules/lib0/environment.js\nvar isNode = typeof process !== \"undefined\" && process.release && /node|io\\.js/.test(process.release.name);\nvar isMac = typeof navigator !== \"undefined\" ? /Mac/.test(navigator.platform) : false;\nvar params;\nvar args = [];\nvar computeParams = () => {\n  if (params === void 0) {\n    if (isNode) {\n      params = create();\n      const pargs = process.argv;\n      let currParamName = null;\n      for (let i = 0; i < pargs.length; i++) {\n        const parg = pargs[i];\n        if (parg[0] === \"-\") {\n          if (currParamName !== null) {\n            params.set(currParamName, \"\");\n          }\n          currParamName = parg;\n        } else {\n          if (currParamName !== null) {\n            params.set(currParamName, parg);\n            currParamName = null;\n          } else {\n            args.push(parg);\n          }\n        }\n      }\n      if (currParamName !== null) {\n        params.set(currParamName, \"\");\n      }\n    } else if (typeof location === \"object\") {\n      params = create();\n      (location.search || \"?\").slice(1).split(\"&\").forEach((kv) => {\n        if (kv.length !== 0) {\n          const [key, value] = kv.split(\"=\");\n          params.set(`--${fromCamelCase(key, \"-\")}`, value);\n          params.set(`-${fromCamelCase(key, \"-\")}`, value);\n        }\n      });\n    } else {\n      params = create();\n    }\n  }\n  return params;\n};\nvar hasParam = (name) => computeParams().has(name);\nvar getVariable = (name) => isNode ? undefinedToNull(process.env[name.toUpperCase()]) : undefinedToNull(varStorage.getItem(name));\nvar hasConf = (name) => hasParam(\"--\" + name) || getVariable(name) !== null;\nvar production = hasConf(\"production\");\nvar forceColor = isNode && isOneOf(process.env.FORCE_COLOR, [\"true\", \"1\", \"2\"]);\nvar supportsColor = !hasParam(\"no-colors\") && (!isNode || process.stdout.isTTY || forceColor) && (!isNode || hasParam(\"color\") || forceColor || getVariable(\"COLORTERM\") !== null || (getVariable(\"TERM\") || \"\").includes(\"color\"));\n\n// ../../node_modules/.pnpm/lib0@0.2.80/node_modules/lib0/binary.js\nvar BIT1 = 1;\nvar BIT2 = 2;\nvar BIT3 = 4;\nvar BIT4 = 8;\nvar BIT6 = 32;\nvar BIT7 = 64;\nvar BIT8 = 128;\nvar BIT18 = 1 << 17;\nvar BIT19 = 1 << 18;\nvar BIT20 = 1 << 19;\nvar BIT21 = 1 << 20;\nvar BIT22 = 1 << 21;\nvar BIT23 = 1 << 22;\nvar BIT24 = 1 << 23;\nvar BIT25 = 1 << 24;\nvar BIT26 = 1 << 25;\nvar BIT27 = 1 << 26;\nvar BIT28 = 1 << 27;\nvar BIT29 = 1 << 28;\nvar BIT30 = 1 << 29;\nvar BIT31 = 1 << 30;\nvar BIT32 = 1 << 31;\nvar BITS5 = 31;\nvar BITS6 = 63;\nvar BITS7 = 127;\nvar BITS17 = BIT18 - 1;\nvar BITS18 = BIT19 - 1;\nvar BITS19 = BIT20 - 1;\nvar BITS20 = BIT21 - 1;\nvar BITS21 = BIT22 - 1;\nvar BITS22 = BIT23 - 1;\nvar BITS23 = BIT24 - 1;\nvar BITS24 = BIT25 - 1;\nvar BITS25 = BIT26 - 1;\nvar BITS26 = BIT27 - 1;\nvar BITS27 = BIT28 - 1;\nvar BITS28 = BIT29 - 1;\nvar BITS29 = BIT30 - 1;\nvar BITS30 = BIT31 - 1;\nvar BITS31 = 2147483647;\n\n// ../../node_modules/.pnpm/lib0@0.2.80/node_modules/lib0/number.js\nvar MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER;\nvar MIN_SAFE_INTEGER = Number.MIN_SAFE_INTEGER;\nvar LOWEST_INT32 = 1 << 31;\nvar isInteger = Number.isInteger || ((num) => typeof num === \"number\" && isFinite(num) && floor(num) === num);\nvar isNaN2 = Number.isNaN;\nvar parseInt = Number.parseInt;\n\n// ../../node_modules/.pnpm/lib0@0.2.80/node_modules/lib0/error.js\nvar create3 = (s) => new Error(s);\nvar methodUnimplemented = () => {\n  throw create3(\"Method unimplemented\");\n};\nvar unexpectedCase = () => {\n  throw create3(\"Unexpected case\");\n};\n\n// ../../node_modules/.pnpm/lib0@0.2.80/node_modules/lib0/decoding.js\nvar errorUnexpectedEndOfArray = create3(\"Unexpected end of array\");\nvar errorIntegerOutOfRange = create3(\"Integer out of Range\");\nvar Decoder = class {\n  /**\n   * @param {Uint8Array} uint8Array Binary data to decode\n   */\n  constructor(uint8Array) {\n    this.arr = uint8Array;\n    this.pos = 0;\n  }\n};\nvar createDecoder = (uint8Array) => new Decoder(uint8Array);\nvar hasContent = (decoder) => decoder.pos !== decoder.arr.length;\nvar readUint8Array = (decoder, len) => {\n  const view = createUint8ArrayViewFromArrayBuffer(decoder.arr.buffer, decoder.pos + decoder.arr.byteOffset, len);\n  decoder.pos += len;\n  return view;\n};\nvar readVarUint8Array = (decoder) => readUint8Array(decoder, readVarUint(decoder));\nvar readUint8 = (decoder) => decoder.arr[decoder.pos++];\nvar readVarUint = (decoder) => {\n  let num = 0;\n  let mult = 1;\n  const len = decoder.arr.length;\n  while (decoder.pos < len) {\n    const r = decoder.arr[decoder.pos++];\n    num = num + (r & BITS7) * mult;\n    mult *= 128;\n    if (r < BIT8) {\n      return num;\n    }\n    if (num > MAX_SAFE_INTEGER) {\n      throw errorIntegerOutOfRange;\n    }\n  }\n  throw errorUnexpectedEndOfArray;\n};\nvar readVarInt = (decoder) => {\n  let r = decoder.arr[decoder.pos++];\n  let num = r & BITS6;\n  let mult = 64;\n  const sign = (r & BIT7) > 0 ? -1 : 1;\n  if ((r & BIT8) === 0) {\n    return sign * num;\n  }\n  const len = decoder.arr.length;\n  while (decoder.pos < len) {\n    r = decoder.arr[decoder.pos++];\n    num = num + (r & BITS7) * mult;\n    mult *= 128;\n    if (r < BIT8) {\n      return sign * num;\n    }\n    if (num > MAX_SAFE_INTEGER) {\n      throw errorIntegerOutOfRange;\n    }\n  }\n  throw errorUnexpectedEndOfArray;\n};\nvar _readVarStringPolyfill = (decoder) => {\n  let remainingLen = readVarUint(decoder);\n  if (remainingLen === 0) {\n    return \"\";\n  } else {\n    let encodedString = String.fromCodePoint(readUint8(decoder));\n    if (--remainingLen < 100) {\n      while (remainingLen--) {\n        encodedString += String.fromCodePoint(readUint8(decoder));\n      }\n    } else {\n      while (remainingLen > 0) {\n        const nextLen = remainingLen < 1e4 ? remainingLen : 1e4;\n        const bytes = decoder.arr.subarray(decoder.pos, decoder.pos + nextLen);\n        decoder.pos += nextLen;\n        encodedString += String.fromCodePoint.apply(\n          null,\n          /** @type {any} */\n          bytes\n        );\n        remainingLen -= nextLen;\n      }\n    }\n    return decodeURIComponent(escape(encodedString));\n  }\n};\nvar _readVarStringNative = (decoder) => (\n  /** @type any */\n  utf8TextDecoder.decode(readVarUint8Array(decoder))\n);\nvar readVarString = utf8TextDecoder ? _readVarStringNative : _readVarStringPolyfill;\nvar readFromDataView = (decoder, len) => {\n  const dv = new DataView(decoder.arr.buffer, decoder.arr.byteOffset + decoder.pos, len);\n  decoder.pos += len;\n  return dv;\n};\nvar readFloat32 = (decoder) => readFromDataView(decoder, 4).getFloat32(0, false);\nvar readFloat64 = (decoder) => readFromDataView(decoder, 8).getFloat64(0, false);\nvar readBigInt64 = (decoder) => (\n  /** @type {any} */\n  readFromDataView(decoder, 8).getBigInt64(0, false)\n);\nvar readAnyLookupTable = [\n  (decoder) => void 0,\n  // CASE 127: undefined\n  (decoder) => null,\n  // CASE 126: null\n  readVarInt,\n  // CASE 125: integer\n  readFloat32,\n  // CASE 124: float32\n  readFloat64,\n  // CASE 123: float64\n  readBigInt64,\n  // CASE 122: bigint\n  (decoder) => false,\n  // CASE 121: boolean (false)\n  (decoder) => true,\n  // CASE 120: boolean (true)\n  readVarString,\n  // CASE 119: string\n  (decoder) => {\n    const len = readVarUint(decoder);\n    const obj = {};\n    for (let i = 0; i < len; i++) {\n      const key = readVarString(decoder);\n      obj[key] = readAny(decoder);\n    }\n    return obj;\n  },\n  (decoder) => {\n    const len = readVarUint(decoder);\n    const arr = [];\n    for (let i = 0; i < len; i++) {\n      arr.push(readAny(decoder));\n    }\n    return arr;\n  },\n  readVarUint8Array\n  // CASE 116: Uint8Array\n];\nvar readAny = (decoder) => readAnyLookupTable[127 - readUint8(decoder)](decoder);\nvar RleDecoder = class extends Decoder {\n  /**\n   * @param {Uint8Array} uint8Array\n   * @param {function(Decoder):T} reader\n   */\n  constructor(uint8Array, reader) {\n    super(uint8Array);\n    this.reader = reader;\n    this.s = null;\n    this.count = 0;\n  }\n  read() {\n    if (this.count === 0) {\n      this.s = this.reader(this);\n      if (hasContent(this)) {\n        this.count = readVarUint(this) + 1;\n      } else {\n        this.count = -1;\n      }\n    }\n    this.count--;\n    return (\n      /** @type {T} */\n      this.s\n    );\n  }\n};\nvar UintOptRleDecoder = class extends Decoder {\n  /**\n   * @param {Uint8Array} uint8Array\n   */\n  constructor(uint8Array) {\n    super(uint8Array);\n    this.s = 0;\n    this.count = 0;\n  }\n  read() {\n    if (this.count === 0) {\n      this.s = readVarInt(this);\n      const isNegative = isNegativeZero(this.s);\n      this.count = 1;\n      if (isNegative) {\n        this.s = -this.s;\n        this.count = readVarUint(this) + 2;\n      }\n    }\n    this.count--;\n    return (\n      /** @type {number} */\n      this.s\n    );\n  }\n};\nvar IntDiffOptRleDecoder = class extends Decoder {\n  /**\n   * @param {Uint8Array} uint8Array\n   */\n  constructor(uint8Array) {\n    super(uint8Array);\n    this.s = 0;\n    this.count = 0;\n    this.diff = 0;\n  }\n  /**\n   * @return {number}\n   */\n  read() {\n    if (this.count === 0) {\n      const diff = readVarInt(this);\n      const hasCount = diff & 1;\n      this.diff = floor(diff / 2);\n      this.count = 1;\n      if (hasCount) {\n        this.count = readVarUint(this) + 2;\n      }\n    }\n    this.s += this.diff;\n    this.count--;\n    return this.s;\n  }\n};\nvar StringDecoder = class {\n  /**\n   * @param {Uint8Array} uint8Array\n   */\n  constructor(uint8Array) {\n    this.decoder = new UintOptRleDecoder(uint8Array);\n    this.str = readVarString(this.decoder);\n    this.spos = 0;\n  }\n  /**\n   * @return {string}\n   */\n  read() {\n    const end = this.spos + this.decoder.read();\n    const res = this.str.slice(this.spos, end);\n    this.spos = end;\n    return res;\n  }\n};\n\n// ../../node_modules/.pnpm/lib0@0.2.80/node_modules/lib0/buffer.js\nvar createUint8ArrayFromLen = (len) => new Uint8Array(len);\nvar createUint8ArrayViewFromArrayBuffer = (buffer, byteOffset, length3) => new Uint8Array(buffer, byteOffset, length3);\nvar copyUint8Array = (uint8Array) => {\n  const newBuf = createUint8ArrayFromLen(uint8Array.byteLength);\n  newBuf.set(uint8Array);\n  return newBuf;\n};\n\n// ../../node_modules/.pnpm/lib0@0.2.80/node_modules/lib0/encoding.js\nvar Encoder = class {\n  constructor() {\n    this.cpos = 0;\n    this.cbuf = new Uint8Array(100);\n    this.bufs = [];\n  }\n};\nvar createEncoder = () => new Encoder();\nvar length2 = (encoder) => {\n  let len = encoder.cpos;\n  for (let i = 0; i < encoder.bufs.length; i++) {\n    len += encoder.bufs[i].length;\n  }\n  return len;\n};\nvar toUint8Array = (encoder) => {\n  const uint8arr = new Uint8Array(length2(encoder));\n  let curPos = 0;\n  for (let i = 0; i < encoder.bufs.length; i++) {\n    const d = encoder.bufs[i];\n    uint8arr.set(d, curPos);\n    curPos += d.length;\n  }\n  uint8arr.set(createUint8ArrayViewFromArrayBuffer(encoder.cbuf.buffer, 0, encoder.cpos), curPos);\n  return uint8arr;\n};\nvar verifyLen = (encoder, len) => {\n  const bufferLen = encoder.cbuf.length;\n  if (bufferLen - encoder.cpos < len) {\n    encoder.bufs.push(createUint8ArrayViewFromArrayBuffer(encoder.cbuf.buffer, 0, encoder.cpos));\n    encoder.cbuf = new Uint8Array(max(bufferLen, len) * 2);\n    encoder.cpos = 0;\n  }\n};\nvar write = (encoder, num) => {\n  const bufferLen = encoder.cbuf.length;\n  if (encoder.cpos === bufferLen) {\n    encoder.bufs.push(encoder.cbuf);\n    encoder.cbuf = new Uint8Array(bufferLen * 2);\n    encoder.cpos = 0;\n  }\n  encoder.cbuf[encoder.cpos++] = num;\n};\nvar writeUint8 = write;\nvar writeVarUint = (encoder, num) => {\n  while (num > BITS7) {\n    write(encoder, BIT8 | BITS7 & num);\n    num = floor(num / 128);\n  }\n  write(encoder, BITS7 & num);\n};\nvar writeVarInt = (encoder, num) => {\n  const isNegative = isNegativeZero(num);\n  if (isNegative) {\n    num = -num;\n  }\n  write(encoder, (num > BITS6 ? BIT8 : 0) | (isNegative ? BIT7 : 0) | BITS6 & num);\n  num = floor(num / 64);\n  while (num > 0) {\n    write(encoder, (num > BITS7 ? BIT8 : 0) | BITS7 & num);\n    num = floor(num / 128);\n  }\n};\nvar _strBuffer = new Uint8Array(3e4);\nvar _maxStrBSize = _strBuffer.length / 3;\nvar _writeVarStringNative = (encoder, str) => {\n  if (str.length < _maxStrBSize) {\n    const written = utf8TextEncoder.encodeInto(str, _strBuffer).written || 0;\n    writeVarUint(encoder, written);\n    for (let i = 0; i < written; i++) {\n      write(encoder, _strBuffer[i]);\n    }\n  } else {\n    writeVarUint8Array(encoder, encodeUtf8(str));\n  }\n};\nvar _writeVarStringPolyfill = (encoder, str) => {\n  const encodedString = unescape(encodeURIComponent(str));\n  const len = encodedString.length;\n  writeVarUint(encoder, len);\n  for (let i = 0; i < len; i++) {\n    write(\n      encoder,\n      /** @type {number} */\n      encodedString.codePointAt(i)\n    );\n  }\n};\nvar writeVarString = utf8TextEncoder && /** @type {any} */\nutf8TextEncoder.encodeInto ? _writeVarStringNative : _writeVarStringPolyfill;\nvar writeBinaryEncoder = (encoder, append2) => writeUint8Array(encoder, toUint8Array(append2));\nvar writeUint8Array = (encoder, uint8Array) => {\n  const bufferLen = encoder.cbuf.length;\n  const cpos = encoder.cpos;\n  const leftCopyLen = min(bufferLen - cpos, uint8Array.length);\n  const rightCopyLen = uint8Array.length - leftCopyLen;\n  encoder.cbuf.set(uint8Array.subarray(0, leftCopyLen), cpos);\n  encoder.cpos += leftCopyLen;\n  if (rightCopyLen > 0) {\n    encoder.bufs.push(encoder.cbuf);\n    encoder.cbuf = new Uint8Array(max(bufferLen * 2, rightCopyLen));\n    encoder.cbuf.set(uint8Array.subarray(leftCopyLen));\n    encoder.cpos = rightCopyLen;\n  }\n};\nvar writeVarUint8Array = (encoder, uint8Array) => {\n  writeVarUint(encoder, uint8Array.byteLength);\n  writeUint8Array(encoder, uint8Array);\n};\nvar writeOnDataView = (encoder, len) => {\n  verifyLen(encoder, len);\n  const dview = new DataView(encoder.cbuf.buffer, encoder.cpos, len);\n  encoder.cpos += len;\n  return dview;\n};\nvar writeFloat32 = (encoder, num) => writeOnDataView(encoder, 4).setFloat32(0, num, false);\nvar writeFloat64 = (encoder, num) => writeOnDataView(encoder, 8).setFloat64(0, num, false);\nvar writeBigInt64 = (encoder, num) => (\n  /** @type {any} */\n  writeOnDataView(encoder, 8).setBigInt64(0, num, false)\n);\nvar floatTestBed = new DataView(new ArrayBuffer(4));\nvar isFloat32 = (num) => {\n  floatTestBed.setFloat32(0, num);\n  return floatTestBed.getFloat32(0) === num;\n};\nvar writeAny = (encoder, data) => {\n  switch (typeof data) {\n    case \"string\":\n      write(encoder, 119);\n      writeVarString(encoder, data);\n      break;\n    case \"number\":\n      if (isInteger(data) && abs(data) <= BITS31) {\n        write(encoder, 125);\n        writeVarInt(encoder, data);\n      } else if (isFloat32(data)) {\n        write(encoder, 124);\n        writeFloat32(encoder, data);\n      } else {\n        write(encoder, 123);\n        writeFloat64(encoder, data);\n      }\n      break;\n    case \"bigint\":\n      write(encoder, 122);\n      writeBigInt64(encoder, data);\n      break;\n    case \"object\":\n      if (data === null) {\n        write(encoder, 126);\n      } else if (isArray(data)) {\n        write(encoder, 117);\n        writeVarUint(encoder, data.length);\n        for (let i = 0; i < data.length; i++) {\n          writeAny(encoder, data[i]);\n        }\n      } else if (data instanceof Uint8Array) {\n        write(encoder, 116);\n        writeVarUint8Array(encoder, data);\n      } else {\n        write(encoder, 118);\n        const keys2 = Object.keys(data);\n        writeVarUint(encoder, keys2.length);\n        for (let i = 0; i < keys2.length; i++) {\n          const key = keys2[i];\n          writeVarString(encoder, key);\n          writeAny(encoder, data[key]);\n        }\n      }\n      break;\n    case \"boolean\":\n      write(encoder, data ? 120 : 121);\n      break;\n    default:\n      write(encoder, 127);\n  }\n};\nvar RleEncoder = class extends Encoder {\n  /**\n   * @param {function(Encoder, T):void} writer\n   */\n  constructor(writer) {\n    super();\n    this.w = writer;\n    this.s = null;\n    this.count = 0;\n  }\n  /**\n   * @param {T} v\n   */\n  write(v) {\n    if (this.s === v) {\n      this.count++;\n    } else {\n      if (this.count > 0) {\n        writeVarUint(this, this.count - 1);\n      }\n      this.count = 1;\n      this.w(this, v);\n      this.s = v;\n    }\n  }\n};\nvar flushUintOptRleEncoder = (encoder) => {\n  if (encoder.count > 0) {\n    writeVarInt(encoder.encoder, encoder.count === 1 ? encoder.s : -encoder.s);\n    if (encoder.count > 1) {\n      writeVarUint(encoder.encoder, encoder.count - 2);\n    }\n  }\n};\nvar UintOptRleEncoder = class {\n  constructor() {\n    this.encoder = new Encoder();\n    this.s = 0;\n    this.count = 0;\n  }\n  /**\n   * @param {number} v\n   */\n  write(v) {\n    if (this.s === v) {\n      this.count++;\n    } else {\n      flushUintOptRleEncoder(this);\n      this.count = 1;\n      this.s = v;\n    }\n  }\n  toUint8Array() {\n    flushUintOptRleEncoder(this);\n    return toUint8Array(this.encoder);\n  }\n};\nvar flushIntDiffOptRleEncoder = (encoder) => {\n  if (encoder.count > 0) {\n    const encodedDiff = encoder.diff * 2 + (encoder.count === 1 ? 0 : 1);\n    writeVarInt(encoder.encoder, encodedDiff);\n    if (encoder.count > 1) {\n      writeVarUint(encoder.encoder, encoder.count - 2);\n    }\n  }\n};\nvar IntDiffOptRleEncoder = class {\n  constructor() {\n    this.encoder = new Encoder();\n    this.s = 0;\n    this.count = 0;\n    this.diff = 0;\n  }\n  /**\n   * @param {number} v\n   */\n  write(v) {\n    if (this.diff === v - this.s) {\n      this.s = v;\n      this.count++;\n    } else {\n      flushIntDiffOptRleEncoder(this);\n      this.count = 1;\n      this.diff = v - this.s;\n      this.s = v;\n    }\n  }\n  toUint8Array() {\n    flushIntDiffOptRleEncoder(this);\n    return toUint8Array(this.encoder);\n  }\n};\nvar StringEncoder = class {\n  constructor() {\n    this.sarr = [];\n    this.s = \"\";\n    this.lensE = new UintOptRleEncoder();\n  }\n  /**\n   * @param {string} string\n   */\n  write(string) {\n    this.s += string;\n    if (this.s.length > 19) {\n      this.sarr.push(this.s);\n      this.s = \"\";\n    }\n    this.lensE.write(string.length);\n  }\n  toUint8Array() {\n    const encoder = new Encoder();\n    this.sarr.push(this.s);\n    this.s = \"\";\n    writeVarString(encoder, this.sarr.join(\"\"));\n    writeUint8Array(encoder, this.lensE.toUint8Array());\n    return toUint8Array(encoder);\n  }\n};\n\n// ../../node_modules/.pnpm/lib0@0.2.80/node_modules/lib0/webcrypto.js\nvar subtle = crypto.subtle;\nvar getRandomValues = crypto.getRandomValues.bind(crypto);\n\n// ../../node_modules/.pnpm/lib0@0.2.80/node_modules/lib0/random.js\nvar uint32 = () => getRandomValues(new Uint32Array(1))[0];\nvar uuidv4Template = [1e7] + -1e3 + -4e3 + -8e3 + -1e11;\nvar uuidv4 = () => uuidv4Template.replace(\n  /[018]/g,\n  /** @param {number} c */\n  (c) => (c ^ uint32() & 15 >> c / 4).toString(16)\n);\n\n// ../../node_modules/.pnpm/lib0@0.2.80/node_modules/lib0/time.js\nvar getUnixTime = Date.now;\n\n// ../../node_modules/.pnpm/lib0@0.2.80/node_modules/lib0/promise.js\nvar create4 = (f) => (\n  /** @type {Promise<T>} */\n  new Promise(f)\n);\nvar all = Promise.all.bind(Promise);\n\n// ../../node_modules/.pnpm/lib0@0.2.80/node_modules/lib0/pair.js\nvar Pair = class {\n  /**\n   * @param {L} left\n   * @param {R} right\n   */\n  constructor(left, right) {\n    this.left = left;\n    this.right = right;\n  }\n};\nvar create5 = (left, right) => new Pair(left, right);\n\n// ../../node_modules/.pnpm/lib0@0.2.80/node_modules/lib0/dom.js\nvar doc = (\n  /** @type {Document} */\n  typeof document !== \"undefined\" ? document : {}\n);\nvar domParser = (\n  /** @type {DOMParser} */\n  typeof DOMParser !== \"undefined\" ? new DOMParser() : null\n);\nvar mapToStyleString = (m) => map(m, (value, key) => `${key}:${value};`).join(\"\");\nvar ELEMENT_NODE = doc.ELEMENT_NODE;\nvar TEXT_NODE = doc.TEXT_NODE;\nvar CDATA_SECTION_NODE = doc.CDATA_SECTION_NODE;\nvar COMMENT_NODE = doc.COMMENT_NODE;\nvar DOCUMENT_NODE = doc.DOCUMENT_NODE;\nvar DOCUMENT_TYPE_NODE = doc.DOCUMENT_TYPE_NODE;\nvar DOCUMENT_FRAGMENT_NODE = doc.DOCUMENT_FRAGMENT_NODE;\n\n// ../../node_modules/.pnpm/lib0@0.2.80/node_modules/lib0/eventloop.js\nvar createTimeoutClass = (clearFunction) => class TT {\n  /**\n   * @param {number} timeoutId\n   */\n  constructor(timeoutId) {\n    this._ = timeoutId;\n  }\n  destroy() {\n    clearFunction(this._);\n  }\n};\nvar Timeout = createTimeoutClass(clearTimeout);\nvar Interval = createTimeoutClass(clearInterval);\nvar Animation = createTimeoutClass((arg) => typeof requestAnimationFrame !== \"undefined\" && cancelAnimationFrame(arg));\nvar Idle = createTimeoutClass((arg) => typeof cancelIdleCallback !== \"undefined\" && cancelIdleCallback(arg));\n\n// ../../node_modules/.pnpm/lib0@0.2.80/node_modules/lib0/symbol.js\nvar create6 = Symbol;\n\n// ../../node_modules/.pnpm/lib0@0.2.80/node_modules/lib0/logging.common.js\nvar BOLD = create6();\nvar UNBOLD = create6();\nvar BLUE = create6();\nvar GREY = create6();\nvar GREEN = create6();\nvar RED = create6();\nvar PURPLE = create6();\nvar ORANGE = create6();\nvar UNCOLOR = create6();\nvar computeNoColorLoggingArgs = (args2) => {\n  const strBuilder = [];\n  const logArgs = [];\n  let i = 0;\n  for (; i < args2.length; i++) {\n    const arg = args2[i];\n    if (arg.constructor === String || arg.constructor === Number) {\n      strBuilder.push(arg);\n    } else if (arg.constructor === Object) {\n      logArgs.push(JSON.stringify(arg));\n    }\n  }\n  return logArgs;\n};\nvar lastLoggingTime = getUnixTime();\n\n// ../../node_modules/.pnpm/lib0@0.2.80/node_modules/lib0/logging.js\nvar _browserStyleMap = {\n  [BOLD]: create5(\"font-weight\", \"bold\"),\n  [UNBOLD]: create5(\"font-weight\", \"normal\"),\n  [BLUE]: create5(\"color\", \"blue\"),\n  [GREEN]: create5(\"color\", \"green\"),\n  [GREY]: create5(\"color\", \"grey\"),\n  [RED]: create5(\"color\", \"red\"),\n  [PURPLE]: create5(\"color\", \"purple\"),\n  [ORANGE]: create5(\"color\", \"orange\"),\n  // not well supported in chrome when debugging node with inspector - TODO: deprecate\n  [UNCOLOR]: create5(\"color\", \"black\")\n};\nvar computeBrowserLoggingArgs = (args2) => {\n  const strBuilder = [];\n  const styles = [];\n  const currentStyle = create();\n  let logArgs = [];\n  let i = 0;\n  for (; i < args2.length; i++) {\n    const arg = args2[i];\n    const style = _browserStyleMap[arg];\n    if (style !== void 0) {\n      currentStyle.set(style.left, style.right);\n    } else {\n      if (arg.constructor === String || arg.constructor === Number) {\n        const style2 = mapToStyleString(currentStyle);\n        if (i > 0 || style2.length > 0) {\n          strBuilder.push(\"%c\" + arg);\n          styles.push(style2);\n        } else {\n          strBuilder.push(arg);\n        }\n      } else {\n        break;\n      }\n    }\n  }\n  if (i > 0) {\n    logArgs = styles;\n    logArgs.unshift(strBuilder.join(\"\"));\n  }\n  for (; i < args2.length; i++) {\n    const arg = args2[i];\n    if (!(arg instanceof Symbol)) {\n      logArgs.push(arg);\n    }\n  }\n  return logArgs;\n};\nvar computeLoggingArgs = supportsColor ? computeBrowserLoggingArgs : computeNoColorLoggingArgs;\nvar print = (...args2) => {\n  console.log(...computeLoggingArgs(args2));\n  vconsoles.forEach((vc) => vc.print(args2));\n};\nvar vconsoles = create2();\n\n// ../../node_modules/.pnpm/lib0@0.2.80/node_modules/lib0/iterator.js\nvar createIterator = (next) => ({\n  /**\n   * @return {IterableIterator<T>}\n   */\n  [Symbol.iterator]() {\n    return this;\n  },\n  // @ts-ignore\n  next\n});\nvar iteratorFilter = (iterator, filter) => createIterator(() => {\n  let res;\n  do {\n    res = iterator.next();\n  } while (!res.done && !filter(res.value));\n  return res;\n});\nvar iteratorMap = (iterator, fmap) => createIterator(() => {\n  const { done, value } = iterator.next();\n  return { done, value: done ? void 0 : fmap(value) };\n});\n\n// ../../node_modules/.pnpm/yjs@13.6.7/node_modules/yjs/dist/yjs.mjs\nvar AbstractConnector = class extends Observable {\n  /**\n   * @param {Doc} ydoc\n   * @param {any} awareness\n   */\n  constructor(ydoc, awareness) {\n    super();\n    this.doc = ydoc;\n    this.awareness = awareness;\n  }\n};\nvar DeleteItem = class {\n  /**\n   * @param {number} clock\n   * @param {number} len\n   */\n  constructor(clock, len) {\n    this.clock = clock;\n    this.len = len;\n  }\n};\nvar DeleteSet = class {\n  constructor() {\n    this.clients = /* @__PURE__ */ new Map();\n  }\n};\nvar iterateDeletedStructs = (transaction, ds, f) => ds.clients.forEach((deletes, clientid) => {\n  const structs = (\n    /** @type {Array<GC|Item>} */\n    transaction.doc.store.clients.get(clientid)\n  );\n  for (let i = 0; i < deletes.length; i++) {\n    const del = deletes[i];\n    iterateStructs(transaction, structs, del.clock, del.len, f);\n  }\n});\nvar findIndexDS = (dis, clock) => {\n  let left = 0;\n  let right = dis.length - 1;\n  while (left <= right) {\n    const midindex = floor((left + right) / 2);\n    const mid = dis[midindex];\n    const midclock = mid.clock;\n    if (midclock <= clock) {\n      if (clock < midclock + mid.len) {\n        return midindex;\n      }\n      left = midindex + 1;\n    } else {\n      right = midindex - 1;\n    }\n  }\n  return null;\n};\nvar isDeleted = (ds, id2) => {\n  const dis = ds.clients.get(id2.client);\n  return dis !== void 0 && findIndexDS(dis, id2.clock) !== null;\n};\nvar sortAndMergeDeleteSet = (ds) => {\n  ds.clients.forEach((dels) => {\n    dels.sort((a, b) => a.clock - b.clock);\n    let i, j;\n    for (i = 1, j = 1; i < dels.length; i++) {\n      const left = dels[j - 1];\n      const right = dels[i];\n      if (left.clock + left.len >= right.clock) {\n        left.len = max(left.len, right.clock + right.len - left.clock);\n      } else {\n        if (j < i) {\n          dels[j] = right;\n        }\n        j++;\n      }\n    }\n    dels.length = j;\n  });\n};\nvar mergeDeleteSets = (dss) => {\n  const merged = new DeleteSet();\n  for (let dssI = 0; dssI < dss.length; dssI++) {\n    dss[dssI].clients.forEach((delsLeft, client) => {\n      if (!merged.clients.has(client)) {\n        const dels = delsLeft.slice();\n        for (let i = dssI + 1; i < dss.length; i++) {\n          appendTo(dels, dss[i].clients.get(client) || []);\n        }\n        merged.clients.set(client, dels);\n      }\n    });\n  }\n  sortAndMergeDeleteSet(merged);\n  return merged;\n};\nvar addToDeleteSet = (ds, client, clock, length3) => {\n  setIfUndefined(ds.clients, client, () => (\n    /** @type {Array<DeleteItem>} */\n    []\n  )).push(new DeleteItem(clock, length3));\n};\nvar createDeleteSet = () => new DeleteSet();\nvar createDeleteSetFromStructStore = (ss) => {\n  const ds = createDeleteSet();\n  ss.clients.forEach((structs, client) => {\n    const dsitems = [];\n    for (let i = 0; i < structs.length; i++) {\n      const struct = structs[i];\n      if (struct.deleted) {\n        const clock = struct.id.clock;\n        let len = struct.length;\n        if (i + 1 < structs.length) {\n          for (let next = structs[i + 1]; i + 1 < structs.length && next.deleted; next = structs[++i + 1]) {\n            len += next.length;\n          }\n        }\n        dsitems.push(new DeleteItem(clock, len));\n      }\n    }\n    if (dsitems.length > 0) {\n      ds.clients.set(client, dsitems);\n    }\n  });\n  return ds;\n};\nvar writeDeleteSet = (encoder, ds) => {\n  writeVarUint(encoder.restEncoder, ds.clients.size);\n  from2(ds.clients.entries()).sort((a, b) => b[0] - a[0]).forEach(([client, dsitems]) => {\n    encoder.resetDsCurVal();\n    writeVarUint(encoder.restEncoder, client);\n    const len = dsitems.length;\n    writeVarUint(encoder.restEncoder, len);\n    for (let i = 0; i < len; i++) {\n      const item = dsitems[i];\n      encoder.writeDsClock(item.clock);\n      encoder.writeDsLen(item.len);\n    }\n  });\n};\nvar readDeleteSet = (decoder) => {\n  const ds = new DeleteSet();\n  const numClients = readVarUint(decoder.restDecoder);\n  for (let i = 0; i < numClients; i++) {\n    decoder.resetDsCurVal();\n    const client = readVarUint(decoder.restDecoder);\n    const numberOfDeletes = readVarUint(decoder.restDecoder);\n    if (numberOfDeletes > 0) {\n      const dsField = setIfUndefined(ds.clients, client, () => (\n        /** @type {Array<DeleteItem>} */\n        []\n      ));\n      for (let i2 = 0; i2 < numberOfDeletes; i2++) {\n        dsField.push(new DeleteItem(decoder.readDsClock(), decoder.readDsLen()));\n      }\n    }\n  }\n  return ds;\n};\nvar readAndApplyDeleteSet = (decoder, transaction, store) => {\n  const unappliedDS = new DeleteSet();\n  const numClients = readVarUint(decoder.restDecoder);\n  for (let i = 0; i < numClients; i++) {\n    decoder.resetDsCurVal();\n    const client = readVarUint(decoder.restDecoder);\n    const numberOfDeletes = readVarUint(decoder.restDecoder);\n    const structs = store.clients.get(client) || [];\n    const state = getState(store, client);\n    for (let i2 = 0; i2 < numberOfDeletes; i2++) {\n      const clock = decoder.readDsClock();\n      const clockEnd = clock + decoder.readDsLen();\n      if (clock < state) {\n        if (state < clockEnd) {\n          addToDeleteSet(unappliedDS, client, state, clockEnd - state);\n        }\n        let index = findIndexSS(structs, clock);\n        let struct = structs[index];\n        if (!struct.deleted && struct.id.clock < clock) {\n          structs.splice(index + 1, 0, splitItem(transaction, struct, clock - struct.id.clock));\n          index++;\n        }\n        while (index < structs.length) {\n          struct = structs[index++];\n          if (struct.id.clock < clockEnd) {\n            if (!struct.deleted) {\n              if (clockEnd < struct.id.clock + struct.length) {\n                structs.splice(index, 0, splitItem(transaction, struct, clockEnd - struct.id.clock));\n              }\n              struct.delete(transaction);\n            }\n          } else {\n            break;\n          }\n        }\n      } else {\n        addToDeleteSet(unappliedDS, client, clock, clockEnd - clock);\n      }\n    }\n  }\n  if (unappliedDS.clients.size > 0) {\n    const ds = new UpdateEncoderV2();\n    writeVarUint(ds.restEncoder, 0);\n    writeDeleteSet(ds, unappliedDS);\n    return ds.toUint8Array();\n  }\n  return null;\n};\nvar equalDeleteSets = (ds1, ds2) => {\n  if (ds1.clients.size !== ds2.clients.size)\n    return false;\n  for (const [client, deleteItems1] of ds1.clients.entries()) {\n    const deleteItems2 = (\n      /** @type {Array<import('../internals.js').DeleteItem>} */\n      ds2.clients.get(client)\n    );\n    if (deleteItems2 === void 0 || deleteItems1.length !== deleteItems2.length)\n      return false;\n    for (let i = 0; i < deleteItems1.length; i++) {\n      const di1 = deleteItems1[i];\n      const di2 = deleteItems2[i];\n      if (di1.clock !== di2.clock || di1.len !== di2.len) {\n        return false;\n      }\n    }\n  }\n  return true;\n};\nvar generateNewClientId = uint32;\nvar Doc = class _Doc extends Observable {\n  /**\n   * @param {DocOpts} opts configuration\n   */\n  constructor({ guid = uuidv4(), collectionid = null, gc = true, gcFilter = () => true, meta = null, autoLoad = false, shouldLoad = true } = {}) {\n    super();\n    this.gc = gc;\n    this.gcFilter = gcFilter;\n    this.clientID = generateNewClientId();\n    this.guid = guid;\n    this.collectionid = collectionid;\n    this.share = /* @__PURE__ */ new Map();\n    this.store = new StructStore();\n    this._transaction = null;\n    this._transactionCleanups = [];\n    this.subdocs = /* @__PURE__ */ new Set();\n    this._item = null;\n    this.shouldLoad = shouldLoad;\n    this.autoLoad = autoLoad;\n    this.meta = meta;\n    this.isLoaded = false;\n    this.isSynced = false;\n    this.whenLoaded = create4((resolve) => {\n      this.on(\"load\", () => {\n        this.isLoaded = true;\n        resolve(this);\n      });\n    });\n    const provideSyncedPromise = () => create4((resolve) => {\n      const eventHandler = (isSynced) => {\n        if (isSynced === void 0 || isSynced === true) {\n          this.off(\"sync\", eventHandler);\n          resolve();\n        }\n      };\n      this.on(\"sync\", eventHandler);\n    });\n    this.on(\"sync\", (isSynced) => {\n      if (isSynced === false && this.isSynced) {\n        this.whenSynced = provideSyncedPromise();\n      }\n      this.isSynced = isSynced === void 0 || isSynced === true;\n      if (!this.isLoaded) {\n        this.emit(\"load\", []);\n      }\n    });\n    this.whenSynced = provideSyncedPromise();\n  }\n  /**\n   * Notify the parent document that you request to load data into this subdocument (if it is a subdocument).\n   *\n   * `load()` might be used in the future to request any provider to load the most current data.\n   *\n   * It is safe to call `load()` multiple times.\n   */\n  load() {\n    const item = this._item;\n    if (item !== null && !this.shouldLoad) {\n      transact(\n        /** @type {any} */\n        item.parent.doc,\n        (transaction) => {\n          transaction.subdocsLoaded.add(this);\n        },\n        null,\n        true\n      );\n    }\n    this.shouldLoad = true;\n  }\n  getSubdocs() {\n    return this.subdocs;\n  }\n  getSubdocGuids() {\n    return new Set(from2(this.subdocs).map((doc2) => doc2.guid));\n  }\n  /**\n   * Changes that happen inside of a transaction are bundled. This means that\n   * the observer fires _after_ the transaction is finished and that all changes\n   * that happened inside of the transaction are sent as one message to the\n   * other peers.\n   *\n   * @template T\n   * @param {function(Transaction):T} f The function that should be executed as a transaction\n   * @param {any} [origin] Origin of who started the transaction. Will be stored on transaction.origin\n   * @return T\n   *\n   * @public\n   */\n  transact(f, origin = null) {\n    return transact(this, f, origin);\n  }\n  /**\n   * Define a shared data type.\n   *\n   * Multiple calls of `y.get(name, TypeConstructor)` yield the same result\n   * and do not overwrite each other. I.e.\n   * `y.define(name, Y.Array) === y.define(name, Y.Array)`\n   *\n   * After this method is called, the type is also available on `y.share.get(name)`.\n   *\n   * *Best Practices:*\n   * Define all types right after the Yjs instance is created and store them in a separate object.\n   * Also use the typed methods `getText(name)`, `getArray(name)`, ..\n   *\n   * @example\n   *   const y = new Y(..)\n   *   const appState = {\n   *     document: y.getText('document')\n   *     comments: y.getArray('comments')\n   *   }\n   *\n   * @param {string} name\n   * @param {Function} TypeConstructor The constructor of the type definition. E.g. Y.Text, Y.Array, Y.Map, ...\n   * @return {AbstractType<any>} The created type. Constructed with TypeConstructor\n   *\n   * @public\n   */\n  get(name, TypeConstructor = AbstractType) {\n    const type = setIfUndefined(this.share, name, () => {\n      const t = new TypeConstructor();\n      t._integrate(this, null);\n      return t;\n    });\n    const Constr = type.constructor;\n    if (TypeConstructor !== AbstractType && Constr !== TypeConstructor) {\n      if (Constr === AbstractType) {\n        const t = new TypeConstructor();\n        t._map = type._map;\n        type._map.forEach(\n          /** @param {Item?} n */\n          (n) => {\n            for (; n !== null; n = n.left) {\n              n.parent = t;\n            }\n          }\n        );\n        t._start = type._start;\n        for (let n = t._start; n !== null; n = n.right) {\n          n.parent = t;\n        }\n        t._length = type._length;\n        this.share.set(name, t);\n        t._integrate(this, null);\n        return t;\n      } else {\n        throw new Error(`Type with the name ${name} has already been defined with a different constructor`);\n      }\n    }\n    return type;\n  }\n  /**\n   * @template T\n   * @param {string} [name]\n   * @return {YArray<T>}\n   *\n   * @public\n   */\n  getArray(name = \"\") {\n    return this.get(name, YArray);\n  }\n  /**\n   * @param {string} [name]\n   * @return {YText}\n   *\n   * @public\n   */\n  getText(name = \"\") {\n    return this.get(name, YText);\n  }\n  /**\n   * @template T\n   * @param {string} [name]\n   * @return {YMap<T>}\n   *\n   * @public\n   */\n  getMap(name = \"\") {\n    return this.get(name, YMap);\n  }\n  /**\n   * @param {string} [name]\n   * @return {YXmlFragment}\n   *\n   * @public\n   */\n  getXmlFragment(name = \"\") {\n    return this.get(name, YXmlFragment);\n  }\n  /**\n   * Converts the entire document into a js object, recursively traversing each yjs type\n   * Doesn't log types that have not been defined (using ydoc.getType(..)).\n   *\n   * @deprecated Do not use this method and rather call toJSON directly on the shared types.\n   *\n   * @return {Object<string, any>}\n   */\n  toJSON() {\n    const doc2 = {};\n    this.share.forEach((value, key) => {\n      doc2[key] = value.toJSON();\n    });\n    return doc2;\n  }\n  /**\n   * Emit `destroy` event and unregister all event handlers.\n   */\n  destroy() {\n    from2(this.subdocs).forEach((subdoc) => subdoc.destroy());\n    const item = this._item;\n    if (item !== null) {\n      this._item = null;\n      const content = (\n        /** @type {ContentDoc} */\n        item.content\n      );\n      content.doc = new _Doc({ guid: this.guid, ...content.opts, shouldLoad: false });\n      content.doc._item = item;\n      transact(\n        /** @type {any} */\n        item.parent.doc,\n        (transaction) => {\n          const doc2 = content.doc;\n          if (!item.deleted) {\n            transaction.subdocsAdded.add(doc2);\n          }\n          transaction.subdocsRemoved.add(this);\n        },\n        null,\n        true\n      );\n    }\n    this.emit(\"destroyed\", [true]);\n    this.emit(\"destroy\", [this]);\n    super.destroy();\n  }\n  /**\n   * @param {string} eventName\n   * @param {function(...any):any} f\n   */\n  on(eventName, f) {\n    super.on(eventName, f);\n  }\n  /**\n   * @param {string} eventName\n   * @param {function} f\n   */\n  off(eventName, f) {\n    super.off(eventName, f);\n  }\n};\nvar DSDecoderV1 = class {\n  /**\n   * @param {decoding.Decoder} decoder\n   */\n  constructor(decoder) {\n    this.restDecoder = decoder;\n  }\n  resetDsCurVal() {\n  }\n  /**\n   * @return {number}\n   */\n  readDsClock() {\n    return readVarUint(this.restDecoder);\n  }\n  /**\n   * @return {number}\n   */\n  readDsLen() {\n    return readVarUint(this.restDecoder);\n  }\n};\nvar UpdateDecoderV1 = class extends DSDecoderV1 {\n  /**\n   * @return {ID}\n   */\n  readLeftID() {\n    return createID(readVarUint(this.restDecoder), readVarUint(this.restDecoder));\n  }\n  /**\n   * @return {ID}\n   */\n  readRightID() {\n    return createID(readVarUint(this.restDecoder), readVarUint(this.restDecoder));\n  }\n  /**\n   * Read the next client id.\n   * Use this in favor of readID whenever possible to reduce the number of objects created.\n   */\n  readClient() {\n    return readVarUint(this.restDecoder);\n  }\n  /**\n   * @return {number} info An unsigned 8-bit integer\n   */\n  readInfo() {\n    return readUint8(this.restDecoder);\n  }\n  /**\n   * @return {string}\n   */\n  readString() {\n    return readVarString(this.restDecoder);\n  }\n  /**\n   * @return {boolean} isKey\n   */\n  readParentInfo() {\n    return readVarUint(this.restDecoder) === 1;\n  }\n  /**\n   * @return {number} info An unsigned 8-bit integer\n   */\n  readTypeRef() {\n    return readVarUint(this.restDecoder);\n  }\n  /**\n   * Write len of a struct - well suited for Opt RLE encoder.\n   *\n   * @return {number} len\n   */\n  readLen() {\n    return readVarUint(this.restDecoder);\n  }\n  /**\n   * @return {any}\n   */\n  readAny() {\n    return readAny(this.restDecoder);\n  }\n  /**\n   * @return {Uint8Array}\n   */\n  readBuf() {\n    return copyUint8Array(readVarUint8Array(this.restDecoder));\n  }\n  /**\n   * Legacy implementation uses JSON parse. We use any-decoding in v2.\n   *\n   * @return {any}\n   */\n  readJSON() {\n    return JSON.parse(readVarString(this.restDecoder));\n  }\n  /**\n   * @return {string}\n   */\n  readKey() {\n    return readVarString(this.restDecoder);\n  }\n};\nvar DSDecoderV2 = class {\n  /**\n   * @param {decoding.Decoder} decoder\n   */\n  constructor(decoder) {\n    this.dsCurrVal = 0;\n    this.restDecoder = decoder;\n  }\n  resetDsCurVal() {\n    this.dsCurrVal = 0;\n  }\n  /**\n   * @return {number}\n   */\n  readDsClock() {\n    this.dsCurrVal += readVarUint(this.restDecoder);\n    return this.dsCurrVal;\n  }\n  /**\n   * @return {number}\n   */\n  readDsLen() {\n    const diff = readVarUint(this.restDecoder) + 1;\n    this.dsCurrVal += diff;\n    return diff;\n  }\n};\nvar UpdateDecoderV2 = class extends DSDecoderV2 {\n  /**\n   * @param {decoding.Decoder} decoder\n   */\n  constructor(decoder) {\n    super(decoder);\n    this.keys = [];\n    readVarUint(decoder);\n    this.keyClockDecoder = new IntDiffOptRleDecoder(readVarUint8Array(decoder));\n    this.clientDecoder = new UintOptRleDecoder(readVarUint8Array(decoder));\n    this.leftClockDecoder = new IntDiffOptRleDecoder(readVarUint8Array(decoder));\n    this.rightClockDecoder = new IntDiffOptRleDecoder(readVarUint8Array(decoder));\n    this.infoDecoder = new RleDecoder(readVarUint8Array(decoder), readUint8);\n    this.stringDecoder = new StringDecoder(readVarUint8Array(decoder));\n    this.parentInfoDecoder = new RleDecoder(readVarUint8Array(decoder), readUint8);\n    this.typeRefDecoder = new UintOptRleDecoder(readVarUint8Array(decoder));\n    this.lenDecoder = new UintOptRleDecoder(readVarUint8Array(decoder));\n  }\n  /**\n   * @return {ID}\n   */\n  readLeftID() {\n    return new ID(this.clientDecoder.read(), this.leftClockDecoder.read());\n  }\n  /**\n   * @return {ID}\n   */\n  readRightID() {\n    return new ID(this.clientDecoder.read(), this.rightClockDecoder.read());\n  }\n  /**\n   * Read the next client id.\n   * Use this in favor of readID whenever possible to reduce the number of objects created.\n   */\n  readClient() {\n    return this.clientDecoder.read();\n  }\n  /**\n   * @return {number} info An unsigned 8-bit integer\n   */\n  readInfo() {\n    return (\n      /** @type {number} */\n      this.infoDecoder.read()\n    );\n  }\n  /**\n   * @return {string}\n   */\n  readString() {\n    return this.stringDecoder.read();\n  }\n  /**\n   * @return {boolean}\n   */\n  readParentInfo() {\n    return this.parentInfoDecoder.read() === 1;\n  }\n  /**\n   * @return {number} An unsigned 8-bit integer\n   */\n  readTypeRef() {\n    return this.typeRefDecoder.read();\n  }\n  /**\n   * Write len of a struct - well suited for Opt RLE encoder.\n   *\n   * @return {number}\n   */\n  readLen() {\n    return this.lenDecoder.read();\n  }\n  /**\n   * @return {any}\n   */\n  readAny() {\n    return readAny(this.restDecoder);\n  }\n  /**\n   * @return {Uint8Array}\n   */\n  readBuf() {\n    return readVarUint8Array(this.restDecoder);\n  }\n  /**\n   * This is mainly here for legacy purposes.\n   *\n   * Initial we incoded objects using JSON. Now we use the much faster lib0/any-encoder. This method mainly exists for legacy purposes for the v1 encoder.\n   *\n   * @return {any}\n   */\n  readJSON() {\n    return readAny(this.restDecoder);\n  }\n  /**\n   * @return {string}\n   */\n  readKey() {\n    const keyClock = this.keyClockDecoder.read();\n    if (keyClock < this.keys.length) {\n      return this.keys[keyClock];\n    } else {\n      const key = this.stringDecoder.read();\n      this.keys.push(key);\n      return key;\n    }\n  }\n};\nvar DSEncoderV1 = class {\n  constructor() {\n    this.restEncoder = createEncoder();\n  }\n  toUint8Array() {\n    return toUint8Array(this.restEncoder);\n  }\n  resetDsCurVal() {\n  }\n  /**\n   * @param {number} clock\n   */\n  writeDsClock(clock) {\n    writeVarUint(this.restEncoder, clock);\n  }\n  /**\n   * @param {number} len\n   */\n  writeDsLen(len) {\n    writeVarUint(this.restEncoder, len);\n  }\n};\nvar UpdateEncoderV1 = class extends DSEncoderV1 {\n  /**\n   * @param {ID} id\n   */\n  writeLeftID(id2) {\n    writeVarUint(this.restEncoder, id2.client);\n    writeVarUint(this.restEncoder, id2.clock);\n  }\n  /**\n   * @param {ID} id\n   */\n  writeRightID(id2) {\n    writeVarUint(this.restEncoder, id2.client);\n    writeVarUint(this.restEncoder, id2.clock);\n  }\n  /**\n   * Use writeClient and writeClock instead of writeID if possible.\n   * @param {number} client\n   */\n  writeClient(client) {\n    writeVarUint(this.restEncoder, client);\n  }\n  /**\n   * @param {number} info An unsigned 8-bit integer\n   */\n  writeInfo(info) {\n    writeUint8(this.restEncoder, info);\n  }\n  /**\n   * @param {string} s\n   */\n  writeString(s) {\n    writeVarString(this.restEncoder, s);\n  }\n  /**\n   * @param {boolean} isYKey\n   */\n  writeParentInfo(isYKey) {\n    writeVarUint(this.restEncoder, isYKey ? 1 : 0);\n  }\n  /**\n   * @param {number} info An unsigned 8-bit integer\n   */\n  writeTypeRef(info) {\n    writeVarUint(this.restEncoder, info);\n  }\n  /**\n   * Write len of a struct - well suited for Opt RLE encoder.\n   *\n   * @param {number} len\n   */\n  writeLen(len) {\n    writeVarUint(this.restEncoder, len);\n  }\n  /**\n   * @param {any} any\n   */\n  writeAny(any2) {\n    writeAny(this.restEncoder, any2);\n  }\n  /**\n   * @param {Uint8Array} buf\n   */\n  writeBuf(buf) {\n    writeVarUint8Array(this.restEncoder, buf);\n  }\n  /**\n   * @param {any} embed\n   */\n  writeJSON(embed) {\n    writeVarString(this.restEncoder, JSON.stringify(embed));\n  }\n  /**\n   * @param {string} key\n   */\n  writeKey(key) {\n    writeVarString(this.restEncoder, key);\n  }\n};\nvar DSEncoderV2 = class {\n  constructor() {\n    this.restEncoder = createEncoder();\n    this.dsCurrVal = 0;\n  }\n  toUint8Array() {\n    return toUint8Array(this.restEncoder);\n  }\n  resetDsCurVal() {\n    this.dsCurrVal = 0;\n  }\n  /**\n   * @param {number} clock\n   */\n  writeDsClock(clock) {\n    const diff = clock - this.dsCurrVal;\n    this.dsCurrVal = clock;\n    writeVarUint(this.restEncoder, diff);\n  }\n  /**\n   * @param {number} len\n   */\n  writeDsLen(len) {\n    if (len === 0) {\n      unexpectedCase();\n    }\n    writeVarUint(this.restEncoder, len - 1);\n    this.dsCurrVal += len;\n  }\n};\nvar UpdateEncoderV2 = class extends DSEncoderV2 {\n  constructor() {\n    super();\n    this.keyMap = /* @__PURE__ */ new Map();\n    this.keyClock = 0;\n    this.keyClockEncoder = new IntDiffOptRleEncoder();\n    this.clientEncoder = new UintOptRleEncoder();\n    this.leftClockEncoder = new IntDiffOptRleEncoder();\n    this.rightClockEncoder = new IntDiffOptRleEncoder();\n    this.infoEncoder = new RleEncoder(writeUint8);\n    this.stringEncoder = new StringEncoder();\n    this.parentInfoEncoder = new RleEncoder(writeUint8);\n    this.typeRefEncoder = new UintOptRleEncoder();\n    this.lenEncoder = new UintOptRleEncoder();\n  }\n  toUint8Array() {\n    const encoder = createEncoder();\n    writeVarUint(encoder, 0);\n    writeVarUint8Array(encoder, this.keyClockEncoder.toUint8Array());\n    writeVarUint8Array(encoder, this.clientEncoder.toUint8Array());\n    writeVarUint8Array(encoder, this.leftClockEncoder.toUint8Array());\n    writeVarUint8Array(encoder, this.rightClockEncoder.toUint8Array());\n    writeVarUint8Array(encoder, toUint8Array(this.infoEncoder));\n    writeVarUint8Array(encoder, this.stringEncoder.toUint8Array());\n    writeVarUint8Array(encoder, toUint8Array(this.parentInfoEncoder));\n    writeVarUint8Array(encoder, this.typeRefEncoder.toUint8Array());\n    writeVarUint8Array(encoder, this.lenEncoder.toUint8Array());\n    writeUint8Array(encoder, toUint8Array(this.restEncoder));\n    return toUint8Array(encoder);\n  }\n  /**\n   * @param {ID} id\n   */\n  writeLeftID(id2) {\n    this.clientEncoder.write(id2.client);\n    this.leftClockEncoder.write(id2.clock);\n  }\n  /**\n   * @param {ID} id\n   */\n  writeRightID(id2) {\n    this.clientEncoder.write(id2.client);\n    this.rightClockEncoder.write(id2.clock);\n  }\n  /**\n   * @param {number} client\n   */\n  writeClient(client) {\n    this.clientEncoder.write(client);\n  }\n  /**\n   * @param {number} info An unsigned 8-bit integer\n   */\n  writeInfo(info) {\n    this.infoEncoder.write(info);\n  }\n  /**\n   * @param {string} s\n   */\n  writeString(s) {\n    this.stringEncoder.write(s);\n  }\n  /**\n   * @param {boolean} isYKey\n   */\n  writeParentInfo(isYKey) {\n    this.parentInfoEncoder.write(isYKey ? 1 : 0);\n  }\n  /**\n   * @param {number} info An unsigned 8-bit integer\n   */\n  writeTypeRef(info) {\n    this.typeRefEncoder.write(info);\n  }\n  /**\n   * Write len of a struct - well suited for Opt RLE encoder.\n   *\n   * @param {number} len\n   */\n  writeLen(len) {\n    this.lenEncoder.write(len);\n  }\n  /**\n   * @param {any} any\n   */\n  writeAny(any2) {\n    writeAny(this.restEncoder, any2);\n  }\n  /**\n   * @param {Uint8Array} buf\n   */\n  writeBuf(buf) {\n    writeVarUint8Array(this.restEncoder, buf);\n  }\n  /**\n   * This is mainly here for legacy purposes.\n   *\n   * Initial we incoded objects using JSON. Now we use the much faster lib0/any-encoder. This method mainly exists for legacy purposes for the v1 encoder.\n   *\n   * @param {any} embed\n   */\n  writeJSON(embed) {\n    writeAny(this.restEncoder, embed);\n  }\n  /**\n   * Property keys are often reused. For example, in y-prosemirror the key `bold` might\n   * occur very often. For a 3d application, the key `position` might occur very often.\n   *\n   * We cache these keys in a Map and refer to them via a unique number.\n   *\n   * @param {string} key\n   */\n  writeKey(key) {\n    const clock = this.keyMap.get(key);\n    if (clock === void 0) {\n      this.keyClockEncoder.write(this.keyClock++);\n      this.stringEncoder.write(key);\n    } else {\n      this.keyClockEncoder.write(clock);\n    }\n  }\n};\nvar writeStructs = (encoder, structs, client, clock) => {\n  clock = max(clock, structs[0].id.clock);\n  const startNewStructs = findIndexSS(structs, clock);\n  writeVarUint(encoder.restEncoder, structs.length - startNewStructs);\n  encoder.writeClient(client);\n  writeVarUint(encoder.restEncoder, clock);\n  const firstStruct = structs[startNewStructs];\n  firstStruct.write(encoder, clock - firstStruct.id.clock);\n  for (let i = startNewStructs + 1; i < structs.length; i++) {\n    structs[i].write(encoder, 0);\n  }\n};\nvar writeClientsStructs = (encoder, store, _sm) => {\n  const sm = /* @__PURE__ */ new Map();\n  _sm.forEach((clock, client) => {\n    if (getState(store, client) > clock) {\n      sm.set(client, clock);\n    }\n  });\n  getStateVector(store).forEach((_clock, client) => {\n    if (!_sm.has(client)) {\n      sm.set(client, 0);\n    }\n  });\n  writeVarUint(encoder.restEncoder, sm.size);\n  from2(sm.entries()).sort((a, b) => b[0] - a[0]).forEach(([client, clock]) => {\n    writeStructs(\n      encoder,\n      /** @type {Array<GC|Item>} */\n      store.clients.get(client),\n      client,\n      clock\n    );\n  });\n};\nvar readClientsStructRefs = (decoder, doc2) => {\n  const clientRefs = create();\n  const numOfStateUpdates = readVarUint(decoder.restDecoder);\n  for (let i = 0; i < numOfStateUpdates; i++) {\n    const numberOfStructs = readVarUint(decoder.restDecoder);\n    const refs = new Array(numberOfStructs);\n    const client = decoder.readClient();\n    let clock = readVarUint(decoder.restDecoder);\n    clientRefs.set(client, { i: 0, refs });\n    for (let i2 = 0; i2 < numberOfStructs; i2++) {\n      const info = decoder.readInfo();\n      switch (BITS5 & info) {\n        case 0: {\n          const len = decoder.readLen();\n          refs[i2] = new GC(createID(client, clock), len);\n          clock += len;\n          break;\n        }\n        case 10: {\n          const len = readVarUint(decoder.restDecoder);\n          refs[i2] = new Skip(createID(client, clock), len);\n          clock += len;\n          break;\n        }\n        default: {\n          const cantCopyParentInfo = (info & (BIT7 | BIT8)) === 0;\n          const struct = new Item(\n            createID(client, clock),\n            null,\n            // leftd\n            (info & BIT8) === BIT8 ? decoder.readLeftID() : null,\n            // origin\n            null,\n            // right\n            (info & BIT7) === BIT7 ? decoder.readRightID() : null,\n            // right origin\n            cantCopyParentInfo ? decoder.readParentInfo() ? doc2.get(decoder.readString()) : decoder.readLeftID() : null,\n            // parent\n            cantCopyParentInfo && (info & BIT6) === BIT6 ? decoder.readString() : null,\n            // parentSub\n            readItemContent(decoder, info)\n            // item content\n          );\n          refs[i2] = struct;\n          clock += struct.length;\n        }\n      }\n    }\n  }\n  return clientRefs;\n};\nvar integrateStructs = (transaction, store, clientsStructRefs) => {\n  const stack = [];\n  let clientsStructRefsIds = from2(clientsStructRefs.keys()).sort((a, b) => a - b);\n  if (clientsStructRefsIds.length === 0) {\n    return null;\n  }\n  const getNextStructTarget = () => {\n    if (clientsStructRefsIds.length === 0) {\n      return null;\n    }\n    let nextStructsTarget = (\n      /** @type {{i:number,refs:Array<GC|Item>}} */\n      clientsStructRefs.get(clientsStructRefsIds[clientsStructRefsIds.length - 1])\n    );\n    while (nextStructsTarget.refs.length === nextStructsTarget.i) {\n      clientsStructRefsIds.pop();\n      if (clientsStructRefsIds.length > 0) {\n        nextStructsTarget = /** @type {{i:number,refs:Array<GC|Item>}} */\n        clientsStructRefs.get(clientsStructRefsIds[clientsStructRefsIds.length - 1]);\n      } else {\n        return null;\n      }\n    }\n    return nextStructsTarget;\n  };\n  let curStructsTarget = getNextStructTarget();\n  if (curStructsTarget === null && stack.length === 0) {\n    return null;\n  }\n  const restStructs = new StructStore();\n  const missingSV = /* @__PURE__ */ new Map();\n  const updateMissingSv = (client, clock) => {\n    const mclock = missingSV.get(client);\n    if (mclock == null || mclock > clock) {\n      missingSV.set(client, clock);\n    }\n  };\n  let stackHead = (\n    /** @type {any} */\n    curStructsTarget.refs[\n      /** @type {any} */\n      curStructsTarget.i++\n    ]\n  );\n  const state = /* @__PURE__ */ new Map();\n  const addStackToRestSS = () => {\n    for (const item of stack) {\n      const client = item.id.client;\n      const unapplicableItems = clientsStructRefs.get(client);\n      if (unapplicableItems) {\n        unapplicableItems.i--;\n        restStructs.clients.set(client, unapplicableItems.refs.slice(unapplicableItems.i));\n        clientsStructRefs.delete(client);\n        unapplicableItems.i = 0;\n        unapplicableItems.refs = [];\n      } else {\n        restStructs.clients.set(client, [item]);\n      }\n      clientsStructRefsIds = clientsStructRefsIds.filter((c) => c !== client);\n    }\n    stack.length = 0;\n  };\n  while (true) {\n    if (stackHead.constructor !== Skip) {\n      const localClock = setIfUndefined(state, stackHead.id.client, () => getState(store, stackHead.id.client));\n      const offset = localClock - stackHead.id.clock;\n      if (offset < 0) {\n        stack.push(stackHead);\n        updateMissingSv(stackHead.id.client, stackHead.id.clock - 1);\n        addStackToRestSS();\n      } else {\n        const missing = stackHead.getMissing(transaction, store);\n        if (missing !== null) {\n          stack.push(stackHead);\n          const structRefs = clientsStructRefs.get(\n            /** @type {number} */\n            missing\n          ) || { refs: [], i: 0 };\n          if (structRefs.refs.length === structRefs.i) {\n            updateMissingSv(\n              /** @type {number} */\n              missing,\n              getState(store, missing)\n            );\n            addStackToRestSS();\n          } else {\n            stackHead = structRefs.refs[structRefs.i++];\n            continue;\n          }\n        } else if (offset === 0 || offset < stackHead.length) {\n          stackHead.integrate(transaction, offset);\n          state.set(stackHead.id.client, stackHead.id.clock + stackHead.length);\n        }\n      }\n    }\n    if (stack.length > 0) {\n      stackHead = /** @type {GC|Item} */\n      stack.pop();\n    } else if (curStructsTarget !== null && curStructsTarget.i < curStructsTarget.refs.length) {\n      stackHead = /** @type {GC|Item} */\n      curStructsTarget.refs[curStructsTarget.i++];\n    } else {\n      curStructsTarget = getNextStructTarget();\n      if (curStructsTarget === null) {\n        break;\n      } else {\n        stackHead = /** @type {GC|Item} */\n        curStructsTarget.refs[curStructsTarget.i++];\n      }\n    }\n  }\n  if (restStructs.clients.size > 0) {\n    const encoder = new UpdateEncoderV2();\n    writeClientsStructs(encoder, restStructs, /* @__PURE__ */ new Map());\n    writeVarUint(encoder.restEncoder, 0);\n    return { missing: missingSV, update: encoder.toUint8Array() };\n  }\n  return null;\n};\nvar writeStructsFromTransaction = (encoder, transaction) => writeClientsStructs(encoder, transaction.doc.store, transaction.beforeState);\nvar readUpdateV2 = (decoder, ydoc, transactionOrigin, structDecoder = new UpdateDecoderV2(decoder)) => transact(ydoc, (transaction) => {\n  transaction.local = false;\n  let retry = false;\n  const doc2 = transaction.doc;\n  const store = doc2.store;\n  const ss = readClientsStructRefs(structDecoder, doc2);\n  const restStructs = integrateStructs(transaction, store, ss);\n  const pending = store.pendingStructs;\n  if (pending) {\n    for (const [client, clock] of pending.missing) {\n      if (clock < getState(store, client)) {\n        retry = true;\n        break;\n      }\n    }\n    if (restStructs) {\n      for (const [client, clock] of restStructs.missing) {\n        const mclock = pending.missing.get(client);\n        if (mclock == null || mclock > clock) {\n          pending.missing.set(client, clock);\n        }\n      }\n      pending.update = mergeUpdatesV2([pending.update, restStructs.update]);\n    }\n  } else {\n    store.pendingStructs = restStructs;\n  }\n  const dsRest = readAndApplyDeleteSet(structDecoder, transaction, store);\n  if (store.pendingDs) {\n    const pendingDSUpdate = new UpdateDecoderV2(createDecoder(store.pendingDs));\n    readVarUint(pendingDSUpdate.restDecoder);\n    const dsRest2 = readAndApplyDeleteSet(pendingDSUpdate, transaction, store);\n    if (dsRest && dsRest2) {\n      store.pendingDs = mergeUpdatesV2([dsRest, dsRest2]);\n    } else {\n      store.pendingDs = dsRest || dsRest2;\n    }\n  } else {\n    store.pendingDs = dsRest;\n  }\n  if (retry) {\n    const update = (\n      /** @type {{update: Uint8Array}} */\n      store.pendingStructs.update\n    );\n    store.pendingStructs = null;\n    applyUpdateV2(transaction.doc, update);\n  }\n}, transactionOrigin, false);\nvar readUpdate = (decoder, ydoc, transactionOrigin) => readUpdateV2(decoder, ydoc, transactionOrigin, new UpdateDecoderV1(decoder));\nvar applyUpdateV2 = (ydoc, update, transactionOrigin, YDecoder = UpdateDecoderV2) => {\n  const decoder = createDecoder(update);\n  readUpdateV2(decoder, ydoc, transactionOrigin, new YDecoder(decoder));\n};\nvar applyUpdate = (ydoc, update, transactionOrigin) => applyUpdateV2(ydoc, update, transactionOrigin, UpdateDecoderV1);\nvar writeStateAsUpdate = (encoder, doc2, targetStateVector = /* @__PURE__ */ new Map()) => {\n  writeClientsStructs(encoder, doc2.store, targetStateVector);\n  writeDeleteSet(encoder, createDeleteSetFromStructStore(doc2.store));\n};\nvar encodeStateAsUpdateV2 = (doc2, encodedTargetStateVector = new Uint8Array([0]), encoder = new UpdateEncoderV2()) => {\n  const targetStateVector = decodeStateVector(encodedTargetStateVector);\n  writeStateAsUpdate(encoder, doc2, targetStateVector);\n  const updates = [encoder.toUint8Array()];\n  if (doc2.store.pendingDs) {\n    updates.push(doc2.store.pendingDs);\n  }\n  if (doc2.store.pendingStructs) {\n    updates.push(diffUpdateV2(doc2.store.pendingStructs.update, encodedTargetStateVector));\n  }\n  if (updates.length > 1) {\n    if (encoder.constructor === UpdateEncoderV1) {\n      return mergeUpdates(updates.map((update, i) => i === 0 ? update : convertUpdateFormatV2ToV1(update)));\n    } else if (encoder.constructor === UpdateEncoderV2) {\n      return mergeUpdatesV2(updates);\n    }\n  }\n  return updates[0];\n};\nvar encodeStateAsUpdate = (doc2, encodedTargetStateVector) => encodeStateAsUpdateV2(doc2, encodedTargetStateVector, new UpdateEncoderV1());\nvar readStateVector = (decoder) => {\n  const ss = /* @__PURE__ */ new Map();\n  const ssLength = readVarUint(decoder.restDecoder);\n  for (let i = 0; i < ssLength; i++) {\n    const client = readVarUint(decoder.restDecoder);\n    const clock = readVarUint(decoder.restDecoder);\n    ss.set(client, clock);\n  }\n  return ss;\n};\nvar decodeStateVector = (decodedState) => readStateVector(new DSDecoderV1(createDecoder(decodedState)));\nvar writeStateVector = (encoder, sv) => {\n  writeVarUint(encoder.restEncoder, sv.size);\n  from2(sv.entries()).sort((a, b) => b[0] - a[0]).forEach(([client, clock]) => {\n    writeVarUint(encoder.restEncoder, client);\n    writeVarUint(encoder.restEncoder, clock);\n  });\n  return encoder;\n};\nvar writeDocumentStateVector = (encoder, doc2) => writeStateVector(encoder, getStateVector(doc2.store));\nvar encodeStateVectorV2 = (doc2, encoder = new DSEncoderV2()) => {\n  if (doc2 instanceof Map) {\n    writeStateVector(encoder, doc2);\n  } else {\n    writeDocumentStateVector(encoder, doc2);\n  }\n  return encoder.toUint8Array();\n};\nvar encodeStateVector = (doc2) => encodeStateVectorV2(doc2, new DSEncoderV1());\nvar EventHandler = class {\n  constructor() {\n    this.l = [];\n  }\n};\nvar createEventHandler = () => new EventHandler();\nvar addEventHandlerListener = (eventHandler, f) => eventHandler.l.push(f);\nvar removeEventHandlerListener = (eventHandler, f) => {\n  const l = eventHandler.l;\n  const len = l.length;\n  eventHandler.l = l.filter((g) => f !== g);\n  if (len === eventHandler.l.length) {\n    console.error(\"[yjs] Tried to remove event handler that doesn't exist.\");\n  }\n};\nvar callEventHandlerListeners = (eventHandler, arg0, arg1) => callAll(eventHandler.l, [arg0, arg1]);\nvar ID = class {\n  /**\n   * @param {number} client client id\n   * @param {number} clock unique per client id, continuous number\n   */\n  constructor(client, clock) {\n    this.client = client;\n    this.clock = clock;\n  }\n};\nvar compareIDs = (a, b) => a === b || a !== null && b !== null && a.client === b.client && a.clock === b.clock;\nvar createID = (client, clock) => new ID(client, clock);\nvar writeID = (encoder, id2) => {\n  writeVarUint(encoder, id2.client);\n  writeVarUint(encoder, id2.clock);\n};\nvar readID = (decoder) => createID(readVarUint(decoder), readVarUint(decoder));\nvar findRootTypeKey = (type) => {\n  for (const [key, value] of type.doc.share.entries()) {\n    if (value === type) {\n      return key;\n    }\n  }\n  throw unexpectedCase();\n};\nvar isParentOf = (parent, child) => {\n  while (child !== null) {\n    if (child.parent === parent) {\n      return true;\n    }\n    child = /** @type {AbstractType<any>} */\n    child.parent._item;\n  }\n  return false;\n};\nvar logType = (type) => {\n  const res = [];\n  let n = type._start;\n  while (n) {\n    res.push(n);\n    n = n.right;\n  }\n  console.log(\"Children: \", res);\n  console.log(\"Children content: \", res.filter((m) => !m.deleted).map((m) => m.content));\n};\nvar PermanentUserData = class {\n  /**\n   * @param {Doc} doc\n   * @param {YMap<any>} [storeType]\n   */\n  constructor(doc2, storeType = doc2.getMap(\"users\")) {\n    const dss = /* @__PURE__ */ new Map();\n    this.yusers = storeType;\n    this.doc = doc2;\n    this.clients = /* @__PURE__ */ new Map();\n    this.dss = dss;\n    const initUser = (user, userDescription) => {\n      const ds = user.get(\"ds\");\n      const ids = user.get(\"ids\");\n      const addClientId = (\n        /** @param {number} clientid */\n        (clientid) => this.clients.set(clientid, userDescription)\n      );\n      ds.observe(\n        /** @param {YArrayEvent<any>} event */\n        (event) => {\n          event.changes.added.forEach((item) => {\n            item.content.getContent().forEach((encodedDs) => {\n              if (encodedDs instanceof Uint8Array) {\n                this.dss.set(userDescription, mergeDeleteSets([this.dss.get(userDescription) || createDeleteSet(), readDeleteSet(new DSDecoderV1(createDecoder(encodedDs)))]));\n              }\n            });\n          });\n        }\n      );\n      this.dss.set(userDescription, mergeDeleteSets(ds.map((encodedDs) => readDeleteSet(new DSDecoderV1(createDecoder(encodedDs))))));\n      ids.observe(\n        /** @param {YArrayEvent<any>} event */\n        (event) => event.changes.added.forEach((item) => item.content.getContent().forEach(addClientId))\n      );\n      ids.forEach(addClientId);\n    };\n    storeType.observe((event) => {\n      event.keysChanged.forEach(\n        (userDescription) => initUser(storeType.get(userDescription), userDescription)\n      );\n    });\n    storeType.forEach(initUser);\n  }\n  /**\n   * @param {Doc} doc\n   * @param {number} clientid\n   * @param {string} userDescription\n   * @param {Object} conf\n   * @param {function(Transaction, DeleteSet):boolean} [conf.filter]\n   */\n  setUserMapping(doc2, clientid, userDescription, { filter = () => true } = {}) {\n    const users = this.yusers;\n    let user = users.get(userDescription);\n    if (!user) {\n      user = new YMap();\n      user.set(\"ids\", new YArray());\n      user.set(\"ds\", new YArray());\n      users.set(userDescription, user);\n    }\n    user.get(\"ids\").push([clientid]);\n    users.observe((_event) => {\n      setTimeout(() => {\n        const userOverwrite = users.get(userDescription);\n        if (userOverwrite !== user) {\n          user = userOverwrite;\n          this.clients.forEach((_userDescription, clientid2) => {\n            if (userDescription === _userDescription) {\n              user.get(\"ids\").push([clientid2]);\n            }\n          });\n          const encoder = new DSEncoderV1();\n          const ds = this.dss.get(userDescription);\n          if (ds) {\n            writeDeleteSet(encoder, ds);\n            user.get(\"ds\").push([encoder.toUint8Array()]);\n          }\n        }\n      }, 0);\n    });\n    doc2.on(\n      \"afterTransaction\",\n      /** @param {Transaction} transaction */\n      (transaction) => {\n        setTimeout(() => {\n          const yds = user.get(\"ds\");\n          const ds = transaction.deleteSet;\n          if (transaction.local && ds.clients.size > 0 && filter(transaction, ds)) {\n            const encoder = new DSEncoderV1();\n            writeDeleteSet(encoder, ds);\n            yds.push([encoder.toUint8Array()]);\n          }\n        });\n      }\n    );\n  }\n  /**\n   * @param {number} clientid\n   * @return {any}\n   */\n  getUserByClientId(clientid) {\n    return this.clients.get(clientid) || null;\n  }\n  /**\n   * @param {ID} id\n   * @return {string | null}\n   */\n  getUserByDeletedId(id2) {\n    for (const [userDescription, ds] of this.dss.entries()) {\n      if (isDeleted(ds, id2)) {\n        return userDescription;\n      }\n    }\n    return null;\n  }\n};\nvar RelativePosition = class {\n  /**\n   * @param {ID|null} type\n   * @param {string|null} tname\n   * @param {ID|null} item\n   * @param {number} assoc\n   */\n  constructor(type, tname, item, assoc = 0) {\n    this.type = type;\n    this.tname = tname;\n    this.item = item;\n    this.assoc = assoc;\n  }\n};\nvar relativePositionToJSON = (rpos) => {\n  const json = {};\n  if (rpos.type) {\n    json.type = rpos.type;\n  }\n  if (rpos.tname) {\n    json.tname = rpos.tname;\n  }\n  if (rpos.item) {\n    json.item = rpos.item;\n  }\n  if (rpos.assoc != null) {\n    json.assoc = rpos.assoc;\n  }\n  return json;\n};\nvar createRelativePositionFromJSON = (json) => new RelativePosition(json.type == null ? null : createID(json.type.client, json.type.clock), json.tname || null, json.item == null ? null : createID(json.item.client, json.item.clock), json.assoc == null ? 0 : json.assoc);\nvar AbsolutePosition = class {\n  /**\n   * @param {AbstractType<any>} type\n   * @param {number} index\n   * @param {number} [assoc]\n   */\n  constructor(type, index, assoc = 0) {\n    this.type = type;\n    this.index = index;\n    this.assoc = assoc;\n  }\n};\nvar createAbsolutePosition = (type, index, assoc = 0) => new AbsolutePosition(type, index, assoc);\nvar createRelativePosition = (type, item, assoc) => {\n  let typeid = null;\n  let tname = null;\n  if (type._item === null) {\n    tname = findRootTypeKey(type);\n  } else {\n    typeid = createID(type._item.id.client, type._item.id.clock);\n  }\n  return new RelativePosition(typeid, tname, item, assoc);\n};\nvar createRelativePositionFromTypeIndex = (type, index, assoc = 0) => {\n  let t = type._start;\n  if (assoc < 0) {\n    if (index === 0) {\n      return createRelativePosition(type, null, assoc);\n    }\n    index--;\n  }\n  while (t !== null) {\n    if (!t.deleted && t.countable) {\n      if (t.length > index) {\n        return createRelativePosition(type, createID(t.id.client, t.id.clock + index), assoc);\n      }\n      index -= t.length;\n    }\n    if (t.right === null && assoc < 0) {\n      return createRelativePosition(type, t.lastId, assoc);\n    }\n    t = t.right;\n  }\n  return createRelativePosition(type, null, assoc);\n};\nvar writeRelativePosition = (encoder, rpos) => {\n  const { type, tname, item, assoc } = rpos;\n  if (item !== null) {\n    writeVarUint(encoder, 0);\n    writeID(encoder, item);\n  } else if (tname !== null) {\n    writeUint8(encoder, 1);\n    writeVarString(encoder, tname);\n  } else if (type !== null) {\n    writeUint8(encoder, 2);\n    writeID(encoder, type);\n  } else {\n    throw unexpectedCase();\n  }\n  writeVarInt(encoder, assoc);\n  return encoder;\n};\nvar encodeRelativePosition = (rpos) => {\n  const encoder = createEncoder();\n  writeRelativePosition(encoder, rpos);\n  return toUint8Array(encoder);\n};\nvar readRelativePosition = (decoder) => {\n  let type = null;\n  let tname = null;\n  let itemID = null;\n  switch (readVarUint(decoder)) {\n    case 0:\n      itemID = readID(decoder);\n      break;\n    case 1:\n      tname = readVarString(decoder);\n      break;\n    case 2: {\n      type = readID(decoder);\n    }\n  }\n  const assoc = hasContent(decoder) ? readVarInt(decoder) : 0;\n  return new RelativePosition(type, tname, itemID, assoc);\n};\nvar decodeRelativePosition = (uint8Array) => readRelativePosition(createDecoder(uint8Array));\nvar createAbsolutePositionFromRelativePosition = (rpos, doc2) => {\n  const store = doc2.store;\n  const rightID = rpos.item;\n  const typeID = rpos.type;\n  const tname = rpos.tname;\n  const assoc = rpos.assoc;\n  let type = null;\n  let index = 0;\n  if (rightID !== null) {\n    if (getState(store, rightID.client) <= rightID.clock) {\n      return null;\n    }\n    const res = followRedone(store, rightID);\n    const right = res.item;\n    if (!(right instanceof Item)) {\n      return null;\n    }\n    type = /** @type {AbstractType<any>} */\n    right.parent;\n    if (type._item === null || !type._item.deleted) {\n      index = right.deleted || !right.countable ? 0 : res.diff + (assoc >= 0 ? 0 : 1);\n      let n = right.left;\n      while (n !== null) {\n        if (!n.deleted && n.countable) {\n          index += n.length;\n        }\n        n = n.left;\n      }\n    }\n  } else {\n    if (tname !== null) {\n      type = doc2.get(tname);\n    } else if (typeID !== null) {\n      if (getState(store, typeID.client) <= typeID.clock) {\n        return null;\n      }\n      const { item } = followRedone(store, typeID);\n      if (item instanceof Item && item.content instanceof ContentType) {\n        type = item.content.type;\n      } else {\n        return null;\n      }\n    } else {\n      throw unexpectedCase();\n    }\n    if (assoc >= 0) {\n      index = type._length;\n    } else {\n      index = 0;\n    }\n  }\n  return createAbsolutePosition(type, index, rpos.assoc);\n};\nvar compareRelativePositions = (a, b) => a === b || a !== null && b !== null && a.tname === b.tname && compareIDs(a.item, b.item) && compareIDs(a.type, b.type) && a.assoc === b.assoc;\nvar Snapshot = class {\n  /**\n   * @param {DeleteSet} ds\n   * @param {Map<number,number>} sv state map\n   */\n  constructor(ds, sv) {\n    this.ds = ds;\n    this.sv = sv;\n  }\n};\nvar equalSnapshots = (snap1, snap2) => {\n  const ds1 = snap1.ds.clients;\n  const ds2 = snap2.ds.clients;\n  const sv1 = snap1.sv;\n  const sv2 = snap2.sv;\n  if (sv1.size !== sv2.size || ds1.size !== ds2.size) {\n    return false;\n  }\n  for (const [key, value] of sv1.entries()) {\n    if (sv2.get(key) !== value) {\n      return false;\n    }\n  }\n  for (const [client, dsitems1] of ds1.entries()) {\n    const dsitems2 = ds2.get(client) || [];\n    if (dsitems1.length !== dsitems2.length) {\n      return false;\n    }\n    for (let i = 0; i < dsitems1.length; i++) {\n      const dsitem1 = dsitems1[i];\n      const dsitem2 = dsitems2[i];\n      if (dsitem1.clock !== dsitem2.clock || dsitem1.len !== dsitem2.len) {\n        return false;\n      }\n    }\n  }\n  return true;\n};\nvar encodeSnapshotV2 = (snapshot2, encoder = new DSEncoderV2()) => {\n  writeDeleteSet(encoder, snapshot2.ds);\n  writeStateVector(encoder, snapshot2.sv);\n  return encoder.toUint8Array();\n};\nvar encodeSnapshot = (snapshot2) => encodeSnapshotV2(snapshot2, new DSEncoderV1());\nvar decodeSnapshotV2 = (buf, decoder = new DSDecoderV2(createDecoder(buf))) => {\n  return new Snapshot(readDeleteSet(decoder), readStateVector(decoder));\n};\nvar decodeSnapshot = (buf) => decodeSnapshotV2(buf, new DSDecoderV1(createDecoder(buf)));\nvar createSnapshot = (ds, sm) => new Snapshot(ds, sm);\nvar emptySnapshot = createSnapshot(createDeleteSet(), /* @__PURE__ */ new Map());\nvar snapshot = (doc2) => createSnapshot(createDeleteSetFromStructStore(doc2.store), getStateVector(doc2.store));\nvar isVisible = (item, snapshot2) => snapshot2 === void 0 ? !item.deleted : snapshot2.sv.has(item.id.client) && (snapshot2.sv.get(item.id.client) || 0) > item.id.clock && !isDeleted(snapshot2.ds, item.id);\nvar splitSnapshotAffectedStructs = (transaction, snapshot2) => {\n  const meta = setIfUndefined(transaction.meta, splitSnapshotAffectedStructs, create2);\n  const store = transaction.doc.store;\n  if (!meta.has(snapshot2)) {\n    snapshot2.sv.forEach((clock, client) => {\n      if (clock < getState(store, client)) {\n        getItemCleanStart(transaction, createID(client, clock));\n      }\n    });\n    iterateDeletedStructs(transaction, snapshot2.ds, (_item) => {\n    });\n    meta.add(snapshot2);\n  }\n};\nvar createDocFromSnapshot = (originDoc, snapshot2, newDoc = new Doc()) => {\n  if (originDoc.gc) {\n    throw new Error(\"Garbage-collection must be disabled in `originDoc`!\");\n  }\n  const { sv, ds } = snapshot2;\n  const encoder = new UpdateEncoderV2();\n  originDoc.transact((transaction) => {\n    let size = 0;\n    sv.forEach((clock) => {\n      if (clock > 0) {\n        size++;\n      }\n    });\n    writeVarUint(encoder.restEncoder, size);\n    for (const [client, clock] of sv) {\n      if (clock === 0) {\n        continue;\n      }\n      if (clock < getState(originDoc.store, client)) {\n        getItemCleanStart(transaction, createID(client, clock));\n      }\n      const structs = originDoc.store.clients.get(client) || [];\n      const lastStructIndex = findIndexSS(structs, clock - 1);\n      writeVarUint(encoder.restEncoder, lastStructIndex + 1);\n      encoder.writeClient(client);\n      writeVarUint(encoder.restEncoder, 0);\n      for (let i = 0; i <= lastStructIndex; i++) {\n        structs[i].write(encoder, 0);\n      }\n    }\n    writeDeleteSet(encoder, ds);\n  });\n  applyUpdateV2(newDoc, encoder.toUint8Array(), \"snapshot\");\n  return newDoc;\n};\nvar snapshotContainsUpdateV2 = (snapshot2, update, YDecoder = UpdateDecoderV2) => {\n  const updateDecoder = new YDecoder(createDecoder(update));\n  const lazyDecoder = new LazyStructReader(updateDecoder, false);\n  for (let curr = lazyDecoder.curr; curr !== null; curr = lazyDecoder.next()) {\n    if ((snapshot2.sv.get(curr.id.client) || 0) < curr.id.clock + curr.length) {\n      return false;\n    }\n  }\n  const mergedDS = mergeDeleteSets([snapshot2.ds, readDeleteSet(updateDecoder)]);\n  return equalDeleteSets(snapshot2.ds, mergedDS);\n};\nvar snapshotContainsUpdate = (snapshot2, update) => snapshotContainsUpdateV2(snapshot2, update, UpdateDecoderV1);\nvar StructStore = class {\n  constructor() {\n    this.clients = /* @__PURE__ */ new Map();\n    this.pendingStructs = null;\n    this.pendingDs = null;\n  }\n};\nvar getStateVector = (store) => {\n  const sm = /* @__PURE__ */ new Map();\n  store.clients.forEach((structs, client) => {\n    const struct = structs[structs.length - 1];\n    sm.set(client, struct.id.clock + struct.length);\n  });\n  return sm;\n};\nvar getState = (store, client) => {\n  const structs = store.clients.get(client);\n  if (structs === void 0) {\n    return 0;\n  }\n  const lastStruct = structs[structs.length - 1];\n  return lastStruct.id.clock + lastStruct.length;\n};\nvar addStruct = (store, struct) => {\n  let structs = store.clients.get(struct.id.client);\n  if (structs === void 0) {\n    structs = [];\n    store.clients.set(struct.id.client, structs);\n  } else {\n    const lastStruct = structs[structs.length - 1];\n    if (lastStruct.id.clock + lastStruct.length !== struct.id.clock) {\n      throw unexpectedCase();\n    }\n  }\n  structs.push(struct);\n};\nvar findIndexSS = (structs, clock) => {\n  let left = 0;\n  let right = structs.length - 1;\n  let mid = structs[right];\n  let midclock = mid.id.clock;\n  if (midclock === clock) {\n    return right;\n  }\n  let midindex = floor(clock / (midclock + mid.length - 1) * right);\n  while (left <= right) {\n    mid = structs[midindex];\n    midclock = mid.id.clock;\n    if (midclock <= clock) {\n      if (clock < midclock + mid.length) {\n        return midindex;\n      }\n      left = midindex + 1;\n    } else {\n      right = midindex - 1;\n    }\n    midindex = floor((left + right) / 2);\n  }\n  throw unexpectedCase();\n};\nvar find = (store, id2) => {\n  const structs = store.clients.get(id2.client);\n  return structs[findIndexSS(structs, id2.clock)];\n};\nvar getItem = (\n  /** @type {function(StructStore,ID):Item} */\n  find\n);\nvar findIndexCleanStart = (transaction, structs, clock) => {\n  const index = findIndexSS(structs, clock);\n  const struct = structs[index];\n  if (struct.id.clock < clock && struct instanceof Item) {\n    structs.splice(index + 1, 0, splitItem(transaction, struct, clock - struct.id.clock));\n    return index + 1;\n  }\n  return index;\n};\nvar getItemCleanStart = (transaction, id2) => {\n  const structs = (\n    /** @type {Array<Item>} */\n    transaction.doc.store.clients.get(id2.client)\n  );\n  return structs[findIndexCleanStart(transaction, structs, id2.clock)];\n};\nvar getItemCleanEnd = (transaction, store, id2) => {\n  const structs = store.clients.get(id2.client);\n  const index = findIndexSS(structs, id2.clock);\n  const struct = structs[index];\n  if (id2.clock !== struct.id.clock + struct.length - 1 && struct.constructor !== GC) {\n    structs.splice(index + 1, 0, splitItem(transaction, struct, id2.clock - struct.id.clock + 1));\n  }\n  return struct;\n};\nvar replaceStruct = (store, struct, newStruct) => {\n  const structs = (\n    /** @type {Array<GC|Item>} */\n    store.clients.get(struct.id.client)\n  );\n  structs[findIndexSS(structs, struct.id.clock)] = newStruct;\n};\nvar iterateStructs = (transaction, structs, clockStart, len, f) => {\n  if (len === 0) {\n    return;\n  }\n  const clockEnd = clockStart + len;\n  let index = findIndexCleanStart(transaction, structs, clockStart);\n  let struct;\n  do {\n    struct = structs[index++];\n    if (clockEnd < struct.id.clock + struct.length) {\n      findIndexCleanStart(transaction, structs, clockEnd);\n    }\n    f(struct);\n  } while (index < structs.length && structs[index].id.clock < clockEnd);\n};\nvar Transaction = class {\n  /**\n   * @param {Doc} doc\n   * @param {any} origin\n   * @param {boolean} local\n   */\n  constructor(doc2, origin, local) {\n    this.doc = doc2;\n    this.deleteSet = new DeleteSet();\n    this.beforeState = getStateVector(doc2.store);\n    this.afterState = /* @__PURE__ */ new Map();\n    this.changed = /* @__PURE__ */ new Map();\n    this.changedParentTypes = /* @__PURE__ */ new Map();\n    this._mergeStructs = [];\n    this.origin = origin;\n    this.meta = /* @__PURE__ */ new Map();\n    this.local = local;\n    this.subdocsAdded = /* @__PURE__ */ new Set();\n    this.subdocsRemoved = /* @__PURE__ */ new Set();\n    this.subdocsLoaded = /* @__PURE__ */ new Set();\n    this._needFormattingCleanup = false;\n  }\n};\nvar writeUpdateMessageFromTransaction = (encoder, transaction) => {\n  if (transaction.deleteSet.clients.size === 0 && !any(transaction.afterState, (clock, client) => transaction.beforeState.get(client) !== clock)) {\n    return false;\n  }\n  sortAndMergeDeleteSet(transaction.deleteSet);\n  writeStructsFromTransaction(encoder, transaction);\n  writeDeleteSet(encoder, transaction.deleteSet);\n  return true;\n};\nvar addChangedTypeToTransaction = (transaction, type, parentSub) => {\n  const item = type._item;\n  if (item === null || item.id.clock < (transaction.beforeState.get(item.id.client) || 0) && !item.deleted) {\n    setIfUndefined(transaction.changed, type, create2).add(parentSub);\n  }\n};\nvar tryToMergeWithLefts = (structs, pos) => {\n  let right = structs[pos];\n  let left = structs[pos - 1];\n  let i = pos;\n  for (; i > 0; right = left, left = structs[--i - 1]) {\n    if (left.deleted === right.deleted && left.constructor === right.constructor) {\n      if (left.mergeWith(right)) {\n        if (right instanceof Item && right.parentSub !== null && /** @type {AbstractType<any>} */\n        right.parent._map.get(right.parentSub) === right) {\n          right.parent._map.set(\n            right.parentSub,\n            /** @type {Item} */\n            left\n          );\n        }\n        continue;\n      }\n    }\n    break;\n  }\n  const merged = pos - i;\n  if (merged) {\n    structs.splice(pos + 1 - merged, merged);\n  }\n  return merged;\n};\nvar tryGcDeleteSet = (ds, store, gcFilter) => {\n  for (const [client, deleteItems] of ds.clients.entries()) {\n    const structs = (\n      /** @type {Array<GC|Item>} */\n      store.clients.get(client)\n    );\n    for (let di = deleteItems.length - 1; di >= 0; di--) {\n      const deleteItem = deleteItems[di];\n      const endDeleteItemClock = deleteItem.clock + deleteItem.len;\n      for (let si = findIndexSS(structs, deleteItem.clock), struct = structs[si]; si < structs.length && struct.id.clock < endDeleteItemClock; struct = structs[++si]) {\n        const struct2 = structs[si];\n        if (deleteItem.clock + deleteItem.len <= struct2.id.clock) {\n          break;\n        }\n        if (struct2 instanceof Item && struct2.deleted && !struct2.keep && gcFilter(struct2)) {\n          struct2.gc(store, false);\n        }\n      }\n    }\n  }\n};\nvar tryMergeDeleteSet = (ds, store) => {\n  ds.clients.forEach((deleteItems, client) => {\n    const structs = (\n      /** @type {Array<GC|Item>} */\n      store.clients.get(client)\n    );\n    for (let di = deleteItems.length - 1; di >= 0; di--) {\n      const deleteItem = deleteItems[di];\n      const mostRightIndexToCheck = min(structs.length - 1, 1 + findIndexSS(structs, deleteItem.clock + deleteItem.len - 1));\n      for (let si = mostRightIndexToCheck, struct = structs[si]; si > 0 && struct.id.clock >= deleteItem.clock; struct = structs[si]) {\n        si -= 1 + tryToMergeWithLefts(structs, si);\n      }\n    }\n  });\n};\nvar tryGc = (ds, store, gcFilter) => {\n  tryGcDeleteSet(ds, store, gcFilter);\n  tryMergeDeleteSet(ds, store);\n};\nvar cleanupTransactions = (transactionCleanups, i) => {\n  if (i < transactionCleanups.length) {\n    const transaction = transactionCleanups[i];\n    const doc2 = transaction.doc;\n    const store = doc2.store;\n    const ds = transaction.deleteSet;\n    const mergeStructs = transaction._mergeStructs;\n    try {\n      sortAndMergeDeleteSet(ds);\n      transaction.afterState = getStateVector(transaction.doc.store);\n      doc2.emit(\"beforeObserverCalls\", [transaction, doc2]);\n      const fs = [];\n      transaction.changed.forEach(\n        (subs, itemtype) => fs.push(() => {\n          if (itemtype._item === null || !itemtype._item.deleted) {\n            itemtype._callObserver(transaction, subs);\n          }\n        })\n      );\n      fs.push(() => {\n        transaction.changedParentTypes.forEach((events, type) => {\n          if (type._dEH.l.length > 0 && (type._item === null || !type._item.deleted)) {\n            events = events.filter(\n              (event) => event.target._item === null || !event.target._item.deleted\n            );\n            events.forEach((event) => {\n              event.currentTarget = type;\n              event._path = null;\n            });\n            events.sort((event1, event2) => event1.path.length - event2.path.length);\n            callEventHandlerListeners(type._dEH, events, transaction);\n          }\n        });\n      });\n      fs.push(() => doc2.emit(\"afterTransaction\", [transaction, doc2]));\n      callAll(fs, []);\n      if (transaction._needFormattingCleanup) {\n        cleanupYTextAfterTransaction(transaction);\n      }\n    } finally {\n      if (doc2.gc) {\n        tryGcDeleteSet(ds, store, doc2.gcFilter);\n      }\n      tryMergeDeleteSet(ds, store);\n      transaction.afterState.forEach((clock, client) => {\n        const beforeClock = transaction.beforeState.get(client) || 0;\n        if (beforeClock !== clock) {\n          const structs = (\n            /** @type {Array<GC|Item>} */\n            store.clients.get(client)\n          );\n          const firstChangePos = max(findIndexSS(structs, beforeClock), 1);\n          for (let i2 = structs.length - 1; i2 >= firstChangePos; ) {\n            i2 -= 1 + tryToMergeWithLefts(structs, i2);\n          }\n        }\n      });\n      for (let i2 = mergeStructs.length - 1; i2 >= 0; i2--) {\n        const { client, clock } = mergeStructs[i2].id;\n        const structs = (\n          /** @type {Array<GC|Item>} */\n          store.clients.get(client)\n        );\n        const replacedStructPos = findIndexSS(structs, clock);\n        if (replacedStructPos + 1 < structs.length) {\n          if (tryToMergeWithLefts(structs, replacedStructPos + 1) > 1) {\n            continue;\n          }\n        }\n        if (replacedStructPos > 0) {\n          tryToMergeWithLefts(structs, replacedStructPos);\n        }\n      }\n      if (!transaction.local && transaction.afterState.get(doc2.clientID) !== transaction.beforeState.get(doc2.clientID)) {\n        print(ORANGE, BOLD, \"[yjs] \", UNBOLD, RED, \"Changed the client-id because another client seems to be using it.\");\n        doc2.clientID = generateNewClientId();\n      }\n      doc2.emit(\"afterTransactionCleanup\", [transaction, doc2]);\n      if (doc2._observers.has(\"update\")) {\n        const encoder = new UpdateEncoderV1();\n        const hasContent2 = writeUpdateMessageFromTransaction(encoder, transaction);\n        if (hasContent2) {\n          doc2.emit(\"update\", [encoder.toUint8Array(), transaction.origin, doc2, transaction]);\n        }\n      }\n      if (doc2._observers.has(\"updateV2\")) {\n        const encoder = new UpdateEncoderV2();\n        const hasContent2 = writeUpdateMessageFromTransaction(encoder, transaction);\n        if (hasContent2) {\n          doc2.emit(\"updateV2\", [encoder.toUint8Array(), transaction.origin, doc2, transaction]);\n        }\n      }\n      const { subdocsAdded, subdocsLoaded, subdocsRemoved } = transaction;\n      if (subdocsAdded.size > 0 || subdocsRemoved.size > 0 || subdocsLoaded.size > 0) {\n        subdocsAdded.forEach((subdoc) => {\n          subdoc.clientID = doc2.clientID;\n          if (subdoc.collectionid == null) {\n            subdoc.collectionid = doc2.collectionid;\n          }\n          doc2.subdocs.add(subdoc);\n        });\n        subdocsRemoved.forEach((subdoc) => doc2.subdocs.delete(subdoc));\n        doc2.emit(\"subdocs\", [{ loaded: subdocsLoaded, added: subdocsAdded, removed: subdocsRemoved }, doc2, transaction]);\n        subdocsRemoved.forEach((subdoc) => subdoc.destroy());\n      }\n      if (transactionCleanups.length <= i + 1) {\n        doc2._transactionCleanups = [];\n        doc2.emit(\"afterAllTransactions\", [doc2, transactionCleanups]);\n      } else {\n        cleanupTransactions(transactionCleanups, i + 1);\n      }\n    }\n  }\n};\nvar transact = (doc2, f, origin = null, local = true) => {\n  const transactionCleanups = doc2._transactionCleanups;\n  let initialCall = false;\n  let result = null;\n  if (doc2._transaction === null) {\n    initialCall = true;\n    doc2._transaction = new Transaction(doc2, origin, local);\n    transactionCleanups.push(doc2._transaction);\n    if (transactionCleanups.length === 1) {\n      doc2.emit(\"beforeAllTransactions\", [doc2]);\n    }\n    doc2.emit(\"beforeTransaction\", [doc2._transaction, doc2]);\n  }\n  try {\n    result = f(doc2._transaction);\n  } finally {\n    if (initialCall) {\n      const finishCleanup = doc2._transaction === transactionCleanups[0];\n      doc2._transaction = null;\n      if (finishCleanup) {\n        cleanupTransactions(transactionCleanups, 0);\n      }\n    }\n  }\n  return result;\n};\nvar StackItem = class {\n  /**\n   * @param {DeleteSet} deletions\n   * @param {DeleteSet} insertions\n   */\n  constructor(deletions, insertions) {\n    this.insertions = insertions;\n    this.deletions = deletions;\n    this.meta = /* @__PURE__ */ new Map();\n  }\n};\nvar clearUndoManagerStackItem = (tr, um, stackItem) => {\n  iterateDeletedStructs(tr, stackItem.deletions, (item) => {\n    if (item instanceof Item && um.scope.some((type) => isParentOf(type, item))) {\n      keepItem(item, false);\n    }\n  });\n};\nvar popStackItem = (undoManager, stack, eventType) => {\n  let result = null;\n  let _tr = null;\n  const doc2 = undoManager.doc;\n  const scope = undoManager.scope;\n  transact(doc2, (transaction) => {\n    while (stack.length > 0 && result === null) {\n      const store = doc2.store;\n      const stackItem = (\n        /** @type {StackItem} */\n        stack.pop()\n      );\n      const itemsToRedo = /* @__PURE__ */ new Set();\n      const itemsToDelete = [];\n      let performedChange = false;\n      iterateDeletedStructs(transaction, stackItem.insertions, (struct) => {\n        if (struct instanceof Item) {\n          if (struct.redone !== null) {\n            let { item, diff } = followRedone(store, struct.id);\n            if (diff > 0) {\n              item = getItemCleanStart(transaction, createID(item.id.client, item.id.clock + diff));\n            }\n            struct = item;\n          }\n          if (!struct.deleted && scope.some((type) => isParentOf(\n            type,\n            /** @type {Item} */\n            struct\n          ))) {\n            itemsToDelete.push(struct);\n          }\n        }\n      });\n      iterateDeletedStructs(transaction, stackItem.deletions, (struct) => {\n        if (struct instanceof Item && scope.some((type) => isParentOf(type, struct)) && // Never redo structs in stackItem.insertions because they were created and deleted in the same capture interval.\n        !isDeleted(stackItem.insertions, struct.id)) {\n          itemsToRedo.add(struct);\n        }\n      });\n      itemsToRedo.forEach((struct) => {\n        performedChange = redoItem(transaction, struct, itemsToRedo, stackItem.insertions, undoManager.ignoreRemoteMapChanges, undoManager) !== null || performedChange;\n      });\n      for (let i = itemsToDelete.length - 1; i >= 0; i--) {\n        const item = itemsToDelete[i];\n        if (undoManager.deleteFilter(item)) {\n          item.delete(transaction);\n          performedChange = true;\n        }\n      }\n      result = performedChange ? stackItem : null;\n    }\n    transaction.changed.forEach((subProps, type) => {\n      if (subProps.has(null) && type._searchMarker) {\n        type._searchMarker.length = 0;\n      }\n    });\n    _tr = transaction;\n  }, undoManager);\n  if (result != null) {\n    const changedParentTypes = _tr.changedParentTypes;\n    undoManager.emit(\"stack-item-popped\", [{ stackItem: result, type: eventType, changedParentTypes }, undoManager]);\n  }\n  return result;\n};\nvar UndoManager = class extends Observable {\n  /**\n   * @param {AbstractType<any>|Array<AbstractType<any>>} typeScope Accepts either a single type, or an array of types\n   * @param {UndoManagerOptions} options\n   */\n  constructor(typeScope, {\n    captureTimeout = 500,\n    captureTransaction = (_tr) => true,\n    deleteFilter = () => true,\n    trackedOrigins = /* @__PURE__ */ new Set([null]),\n    ignoreRemoteMapChanges = false,\n    doc: doc2 = (\n      /** @type {Doc} */\n      isArray(typeScope) ? typeScope[0].doc : typeScope.doc\n    )\n  } = {}) {\n    super();\n    this.scope = [];\n    this.addToScope(typeScope);\n    this.deleteFilter = deleteFilter;\n    trackedOrigins.add(this);\n    this.trackedOrigins = trackedOrigins;\n    this.captureTransaction = captureTransaction;\n    this.undoStack = [];\n    this.redoStack = [];\n    this.undoing = false;\n    this.redoing = false;\n    this.doc = doc2;\n    this.lastChange = 0;\n    this.ignoreRemoteMapChanges = ignoreRemoteMapChanges;\n    this.captureTimeout = captureTimeout;\n    this.afterTransactionHandler = (transaction) => {\n      if (!this.captureTransaction(transaction) || !this.scope.some((type) => transaction.changedParentTypes.has(type)) || !this.trackedOrigins.has(transaction.origin) && (!transaction.origin || !this.trackedOrigins.has(transaction.origin.constructor))) {\n        return;\n      }\n      const undoing = this.undoing;\n      const redoing = this.redoing;\n      const stack = undoing ? this.redoStack : this.undoStack;\n      if (undoing) {\n        this.stopCapturing();\n      } else if (!redoing) {\n        this.clear(false, true);\n      }\n      const insertions = new DeleteSet();\n      transaction.afterState.forEach((endClock, client) => {\n        const startClock = transaction.beforeState.get(client) || 0;\n        const len = endClock - startClock;\n        if (len > 0) {\n          addToDeleteSet(insertions, client, startClock, len);\n        }\n      });\n      const now = getUnixTime();\n      let didAdd = false;\n      if (this.lastChange > 0 && now - this.lastChange < this.captureTimeout && stack.length > 0 && !undoing && !redoing) {\n        const lastOp = stack[stack.length - 1];\n        lastOp.deletions = mergeDeleteSets([lastOp.deletions, transaction.deleteSet]);\n        lastOp.insertions = mergeDeleteSets([lastOp.insertions, insertions]);\n      } else {\n        stack.push(new StackItem(transaction.deleteSet, insertions));\n        didAdd = true;\n      }\n      if (!undoing && !redoing) {\n        this.lastChange = now;\n      }\n      iterateDeletedStructs(\n        transaction,\n        transaction.deleteSet,\n        /** @param {Item|GC} item */\n        (item) => {\n          if (item instanceof Item && this.scope.some((type) => isParentOf(type, item))) {\n            keepItem(item, true);\n          }\n        }\n      );\n      const changeEvent = [{ stackItem: stack[stack.length - 1], origin: transaction.origin, type: undoing ? \"redo\" : \"undo\", changedParentTypes: transaction.changedParentTypes }, this];\n      if (didAdd) {\n        this.emit(\"stack-item-added\", changeEvent);\n      } else {\n        this.emit(\"stack-item-updated\", changeEvent);\n      }\n    };\n    this.doc.on(\"afterTransaction\", this.afterTransactionHandler);\n    this.doc.on(\"destroy\", () => {\n      this.destroy();\n    });\n  }\n  /**\n   * @param {Array<AbstractType<any>> | AbstractType<any>} ytypes\n   */\n  addToScope(ytypes) {\n    ytypes = isArray(ytypes) ? ytypes : [ytypes];\n    ytypes.forEach((ytype) => {\n      if (this.scope.every((yt) => yt !== ytype)) {\n        this.scope.push(ytype);\n      }\n    });\n  }\n  /**\n   * @param {any} origin\n   */\n  addTrackedOrigin(origin) {\n    this.trackedOrigins.add(origin);\n  }\n  /**\n   * @param {any} origin\n   */\n  removeTrackedOrigin(origin) {\n    this.trackedOrigins.delete(origin);\n  }\n  clear(clearUndoStack = true, clearRedoStack = true) {\n    if (clearUndoStack && this.canUndo() || clearRedoStack && this.canRedo()) {\n      this.doc.transact((tr) => {\n        if (clearUndoStack) {\n          this.undoStack.forEach((item) => clearUndoManagerStackItem(tr, this, item));\n          this.undoStack = [];\n        }\n        if (clearRedoStack) {\n          this.redoStack.forEach((item) => clearUndoManagerStackItem(tr, this, item));\n          this.redoStack = [];\n        }\n        this.emit(\"stack-cleared\", [{ undoStackCleared: clearUndoStack, redoStackCleared: clearRedoStack }]);\n      });\n    }\n  }\n  /**\n   * UndoManager merges Undo-StackItem if they are created within time-gap\n   * smaller than `options.captureTimeout`. Call `um.stopCapturing()` so that the next\n   * StackItem won't be merged.\n   *\n   *\n   * @example\n   *     // without stopCapturing\n   *     ytext.insert(0, 'a')\n   *     ytext.insert(1, 'b')\n   *     um.undo()\n   *     ytext.toString() // => '' (note that 'ab' was removed)\n   *     // with stopCapturing\n   *     ytext.insert(0, 'a')\n   *     um.stopCapturing()\n   *     ytext.insert(0, 'b')\n   *     um.undo()\n   *     ytext.toString() // => 'a' (note that only 'b' was removed)\n   *\n   */\n  stopCapturing() {\n    this.lastChange = 0;\n  }\n  /**\n   * Undo last changes on type.\n   *\n   * @return {StackItem?} Returns StackItem if a change was applied\n   */\n  undo() {\n    this.undoing = true;\n    let res;\n    try {\n      res = popStackItem(this, this.undoStack, \"undo\");\n    } finally {\n      this.undoing = false;\n    }\n    return res;\n  }\n  /**\n   * Redo last undo operation.\n   *\n   * @return {StackItem?} Returns StackItem if a change was applied\n   */\n  redo() {\n    this.redoing = true;\n    let res;\n    try {\n      res = popStackItem(this, this.redoStack, \"redo\");\n    } finally {\n      this.redoing = false;\n    }\n    return res;\n  }\n  /**\n   * Are undo steps available?\n   *\n   * @return {boolean} `true` if undo is possible\n   */\n  canUndo() {\n    return this.undoStack.length > 0;\n  }\n  /**\n   * Are redo steps available?\n   *\n   * @return {boolean} `true` if redo is possible\n   */\n  canRedo() {\n    return this.redoStack.length > 0;\n  }\n  destroy() {\n    this.trackedOrigins.delete(this);\n    this.doc.off(\"afterTransaction\", this.afterTransactionHandler);\n    super.destroy();\n  }\n};\nfunction* lazyStructReaderGenerator(decoder) {\n  const numOfStateUpdates = readVarUint(decoder.restDecoder);\n  for (let i = 0; i < numOfStateUpdates; i++) {\n    const numberOfStructs = readVarUint(decoder.restDecoder);\n    const client = decoder.readClient();\n    let clock = readVarUint(decoder.restDecoder);\n    for (let i2 = 0; i2 < numberOfStructs; i2++) {\n      const info = decoder.readInfo();\n      if (info === 10) {\n        const len = readVarUint(decoder.restDecoder);\n        yield new Skip(createID(client, clock), len);\n        clock += len;\n      } else if ((BITS5 & info) !== 0) {\n        const cantCopyParentInfo = (info & (BIT7 | BIT8)) === 0;\n        const struct = new Item(\n          createID(client, clock),\n          null,\n          // left\n          (info & BIT8) === BIT8 ? decoder.readLeftID() : null,\n          // origin\n          null,\n          // right\n          (info & BIT7) === BIT7 ? decoder.readRightID() : null,\n          // right origin\n          // @ts-ignore Force writing a string here.\n          cantCopyParentInfo ? decoder.readParentInfo() ? decoder.readString() : decoder.readLeftID() : null,\n          // parent\n          cantCopyParentInfo && (info & BIT6) === BIT6 ? decoder.readString() : null,\n          // parentSub\n          readItemContent(decoder, info)\n          // item content\n        );\n        yield struct;\n        clock += struct.length;\n      } else {\n        const len = decoder.readLen();\n        yield new GC(createID(client, clock), len);\n        clock += len;\n      }\n    }\n  }\n}\nvar LazyStructReader = class {\n  /**\n   * @param {UpdateDecoderV1 | UpdateDecoderV2} decoder\n   * @param {boolean} filterSkips\n   */\n  constructor(decoder, filterSkips) {\n    this.gen = lazyStructReaderGenerator(decoder);\n    this.curr = null;\n    this.done = false;\n    this.filterSkips = filterSkips;\n    this.next();\n  }\n  /**\n   * @return {Item | GC | Skip |null}\n   */\n  next() {\n    do {\n      this.curr = this.gen.next().value || null;\n    } while (this.filterSkips && this.curr !== null && this.curr.constructor === Skip);\n    return this.curr;\n  }\n};\nvar logUpdate = (update) => logUpdateV2(update, UpdateDecoderV1);\nvar logUpdateV2 = (update, YDecoder = UpdateDecoderV2) => {\n  const structs = [];\n  const updateDecoder = new YDecoder(createDecoder(update));\n  const lazyDecoder = new LazyStructReader(updateDecoder, false);\n  for (let curr = lazyDecoder.curr; curr !== null; curr = lazyDecoder.next()) {\n    structs.push(curr);\n  }\n  print(\"Structs: \", structs);\n  const ds = readDeleteSet(updateDecoder);\n  print(\"DeleteSet: \", ds);\n};\nvar decodeUpdate = (update) => decodeUpdateV2(update, UpdateDecoderV1);\nvar decodeUpdateV2 = (update, YDecoder = UpdateDecoderV2) => {\n  const structs = [];\n  const updateDecoder = new YDecoder(createDecoder(update));\n  const lazyDecoder = new LazyStructReader(updateDecoder, false);\n  for (let curr = lazyDecoder.curr; curr !== null; curr = lazyDecoder.next()) {\n    structs.push(curr);\n  }\n  return {\n    structs,\n    ds: readDeleteSet(updateDecoder)\n  };\n};\nvar LazyStructWriter = class {\n  /**\n   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder\n   */\n  constructor(encoder) {\n    this.currClient = 0;\n    this.startClock = 0;\n    this.written = 0;\n    this.encoder = encoder;\n    this.clientStructs = [];\n  }\n};\nvar mergeUpdates = (updates) => mergeUpdatesV2(updates, UpdateDecoderV1, UpdateEncoderV1);\nvar encodeStateVectorFromUpdateV2 = (update, YEncoder = DSEncoderV2, YDecoder = UpdateDecoderV2) => {\n  const encoder = new YEncoder();\n  const updateDecoder = new LazyStructReader(new YDecoder(createDecoder(update)), false);\n  let curr = updateDecoder.curr;\n  if (curr !== null) {\n    let size = 0;\n    let currClient = curr.id.client;\n    let stopCounting = curr.id.clock !== 0;\n    let currClock = stopCounting ? 0 : curr.id.clock + curr.length;\n    for (; curr !== null; curr = updateDecoder.next()) {\n      if (currClient !== curr.id.client) {\n        if (currClock !== 0) {\n          size++;\n          writeVarUint(encoder.restEncoder, currClient);\n          writeVarUint(encoder.restEncoder, currClock);\n        }\n        currClient = curr.id.client;\n        currClock = 0;\n        stopCounting = curr.id.clock !== 0;\n      }\n      if (curr.constructor === Skip) {\n        stopCounting = true;\n      }\n      if (!stopCounting) {\n        currClock = curr.id.clock + curr.length;\n      }\n    }\n    if (currClock !== 0) {\n      size++;\n      writeVarUint(encoder.restEncoder, currClient);\n      writeVarUint(encoder.restEncoder, currClock);\n    }\n    const enc = createEncoder();\n    writeVarUint(enc, size);\n    writeBinaryEncoder(enc, encoder.restEncoder);\n    encoder.restEncoder = enc;\n    return encoder.toUint8Array();\n  } else {\n    writeVarUint(encoder.restEncoder, 0);\n    return encoder.toUint8Array();\n  }\n};\nvar encodeStateVectorFromUpdate = (update) => encodeStateVectorFromUpdateV2(update, DSEncoderV1, UpdateDecoderV1);\nvar parseUpdateMetaV2 = (update, YDecoder = UpdateDecoderV2) => {\n  const from3 = /* @__PURE__ */ new Map();\n  const to = /* @__PURE__ */ new Map();\n  const updateDecoder = new LazyStructReader(new YDecoder(createDecoder(update)), false);\n  let curr = updateDecoder.curr;\n  if (curr !== null) {\n    let currClient = curr.id.client;\n    let currClock = curr.id.clock;\n    from3.set(currClient, currClock);\n    for (; curr !== null; curr = updateDecoder.next()) {\n      if (currClient !== curr.id.client) {\n        to.set(currClient, currClock);\n        from3.set(curr.id.client, curr.id.clock);\n        currClient = curr.id.client;\n      }\n      currClock = curr.id.clock + curr.length;\n    }\n    to.set(currClient, currClock);\n  }\n  return { from: from3, to };\n};\nvar parseUpdateMeta = (update) => parseUpdateMetaV2(update, UpdateDecoderV1);\nvar sliceStruct = (left, diff) => {\n  if (left.constructor === GC) {\n    const { client, clock } = left.id;\n    return new GC(createID(client, clock + diff), left.length - diff);\n  } else if (left.constructor === Skip) {\n    const { client, clock } = left.id;\n    return new Skip(createID(client, clock + diff), left.length - diff);\n  } else {\n    const leftItem = (\n      /** @type {Item} */\n      left\n    );\n    const { client, clock } = leftItem.id;\n    return new Item(\n      createID(client, clock + diff),\n      null,\n      createID(client, clock + diff - 1),\n      null,\n      leftItem.rightOrigin,\n      leftItem.parent,\n      leftItem.parentSub,\n      leftItem.content.splice(diff)\n    );\n  }\n};\nvar mergeUpdatesV2 = (updates, YDecoder = UpdateDecoderV2, YEncoder = UpdateEncoderV2) => {\n  if (updates.length === 1) {\n    return updates[0];\n  }\n  const updateDecoders = updates.map((update) => new YDecoder(createDecoder(update)));\n  let lazyStructDecoders = updateDecoders.map((decoder) => new LazyStructReader(decoder, true));\n  let currWrite = null;\n  const updateEncoder = new YEncoder();\n  const lazyStructEncoder = new LazyStructWriter(updateEncoder);\n  while (true) {\n    lazyStructDecoders = lazyStructDecoders.filter((dec) => dec.curr !== null);\n    lazyStructDecoders.sort(\n      /** @type {function(any,any):number} */\n      (dec1, dec2) => {\n        if (dec1.curr.id.client === dec2.curr.id.client) {\n          const clockDiff = dec1.curr.id.clock - dec2.curr.id.clock;\n          if (clockDiff === 0) {\n            return dec1.curr.constructor === dec2.curr.constructor ? 0 : dec1.curr.constructor === Skip ? 1 : -1;\n          } else {\n            return clockDiff;\n          }\n        } else {\n          return dec2.curr.id.client - dec1.curr.id.client;\n        }\n      }\n    );\n    if (lazyStructDecoders.length === 0) {\n      break;\n    }\n    const currDecoder = lazyStructDecoders[0];\n    const firstClient = (\n      /** @type {Item | GC} */\n      currDecoder.curr.id.client\n    );\n    if (currWrite !== null) {\n      let curr = (\n        /** @type {Item | GC | null} */\n        currDecoder.curr\n      );\n      let iterated = false;\n      while (curr !== null && curr.id.clock + curr.length <= currWrite.struct.id.clock + currWrite.struct.length && curr.id.client >= currWrite.struct.id.client) {\n        curr = currDecoder.next();\n        iterated = true;\n      }\n      if (curr === null || // current decoder is empty\n      curr.id.client !== firstClient || // check whether there is another decoder that has has updates from `firstClient`\n      iterated && curr.id.clock > currWrite.struct.id.clock + currWrite.struct.length) {\n        continue;\n      }\n      if (firstClient !== currWrite.struct.id.client) {\n        writeStructToLazyStructWriter(lazyStructEncoder, currWrite.struct, currWrite.offset);\n        currWrite = { struct: curr, offset: 0 };\n        currDecoder.next();\n      } else {\n        if (currWrite.struct.id.clock + currWrite.struct.length < curr.id.clock) {\n          if (currWrite.struct.constructor === Skip) {\n            currWrite.struct.length = curr.id.clock + curr.length - currWrite.struct.id.clock;\n          } else {\n            writeStructToLazyStructWriter(lazyStructEncoder, currWrite.struct, currWrite.offset);\n            const diff = curr.id.clock - currWrite.struct.id.clock - currWrite.struct.length;\n            const struct = new Skip(createID(firstClient, currWrite.struct.id.clock + currWrite.struct.length), diff);\n            currWrite = { struct, offset: 0 };\n          }\n        } else {\n          const diff = currWrite.struct.id.clock + currWrite.struct.length - curr.id.clock;\n          if (diff > 0) {\n            if (currWrite.struct.constructor === Skip) {\n              currWrite.struct.length -= diff;\n            } else {\n              curr = sliceStruct(curr, diff);\n            }\n          }\n          if (!currWrite.struct.mergeWith(\n            /** @type {any} */\n            curr\n          )) {\n            writeStructToLazyStructWriter(lazyStructEncoder, currWrite.struct, currWrite.offset);\n            currWrite = { struct: curr, offset: 0 };\n            currDecoder.next();\n          }\n        }\n      }\n    } else {\n      currWrite = { struct: (\n        /** @type {Item | GC} */\n        currDecoder.curr\n      ), offset: 0 };\n      currDecoder.next();\n    }\n    for (let next = currDecoder.curr; next !== null && next.id.client === firstClient && next.id.clock === currWrite.struct.id.clock + currWrite.struct.length && next.constructor !== Skip; next = currDecoder.next()) {\n      writeStructToLazyStructWriter(lazyStructEncoder, currWrite.struct, currWrite.offset);\n      currWrite = { struct: next, offset: 0 };\n    }\n  }\n  if (currWrite !== null) {\n    writeStructToLazyStructWriter(lazyStructEncoder, currWrite.struct, currWrite.offset);\n    currWrite = null;\n  }\n  finishLazyStructWriting(lazyStructEncoder);\n  const dss = updateDecoders.map((decoder) => readDeleteSet(decoder));\n  const ds = mergeDeleteSets(dss);\n  writeDeleteSet(updateEncoder, ds);\n  return updateEncoder.toUint8Array();\n};\nvar diffUpdateV2 = (update, sv, YDecoder = UpdateDecoderV2, YEncoder = UpdateEncoderV2) => {\n  const state = decodeStateVector(sv);\n  const encoder = new YEncoder();\n  const lazyStructWriter = new LazyStructWriter(encoder);\n  const decoder = new YDecoder(createDecoder(update));\n  const reader = new LazyStructReader(decoder, false);\n  while (reader.curr) {\n    const curr = reader.curr;\n    const currClient = curr.id.client;\n    const svClock = state.get(currClient) || 0;\n    if (reader.curr.constructor === Skip) {\n      reader.next();\n      continue;\n    }\n    if (curr.id.clock + curr.length > svClock) {\n      writeStructToLazyStructWriter(lazyStructWriter, curr, max(svClock - curr.id.clock, 0));\n      reader.next();\n      while (reader.curr && reader.curr.id.client === currClient) {\n        writeStructToLazyStructWriter(lazyStructWriter, reader.curr, 0);\n        reader.next();\n      }\n    } else {\n      while (reader.curr && reader.curr.id.client === currClient && reader.curr.id.clock + reader.curr.length <= svClock) {\n        reader.next();\n      }\n    }\n  }\n  finishLazyStructWriting(lazyStructWriter);\n  const ds = readDeleteSet(decoder);\n  writeDeleteSet(encoder, ds);\n  return encoder.toUint8Array();\n};\nvar diffUpdate = (update, sv) => diffUpdateV2(update, sv, UpdateDecoderV1, UpdateEncoderV1);\nvar flushLazyStructWriter = (lazyWriter) => {\n  if (lazyWriter.written > 0) {\n    lazyWriter.clientStructs.push({ written: lazyWriter.written, restEncoder: toUint8Array(lazyWriter.encoder.restEncoder) });\n    lazyWriter.encoder.restEncoder = createEncoder();\n    lazyWriter.written = 0;\n  }\n};\nvar writeStructToLazyStructWriter = (lazyWriter, struct, offset) => {\n  if (lazyWriter.written > 0 && lazyWriter.currClient !== struct.id.client) {\n    flushLazyStructWriter(lazyWriter);\n  }\n  if (lazyWriter.written === 0) {\n    lazyWriter.currClient = struct.id.client;\n    lazyWriter.encoder.writeClient(struct.id.client);\n    writeVarUint(lazyWriter.encoder.restEncoder, struct.id.clock + offset);\n  }\n  struct.write(lazyWriter.encoder, offset);\n  lazyWriter.written++;\n};\nvar finishLazyStructWriting = (lazyWriter) => {\n  flushLazyStructWriter(lazyWriter);\n  const restEncoder = lazyWriter.encoder.restEncoder;\n  writeVarUint(restEncoder, lazyWriter.clientStructs.length);\n  for (let i = 0; i < lazyWriter.clientStructs.length; i++) {\n    const partStructs = lazyWriter.clientStructs[i];\n    writeVarUint(restEncoder, partStructs.written);\n    writeUint8Array(restEncoder, partStructs.restEncoder);\n  }\n};\nvar convertUpdateFormat = (update, blockTransformer, YDecoder, YEncoder) => {\n  const updateDecoder = new YDecoder(createDecoder(update));\n  const lazyDecoder = new LazyStructReader(updateDecoder, false);\n  const updateEncoder = new YEncoder();\n  const lazyWriter = new LazyStructWriter(updateEncoder);\n  for (let curr = lazyDecoder.curr; curr !== null; curr = lazyDecoder.next()) {\n    writeStructToLazyStructWriter(lazyWriter, blockTransformer(curr), 0);\n  }\n  finishLazyStructWriting(lazyWriter);\n  const ds = readDeleteSet(updateDecoder);\n  writeDeleteSet(updateEncoder, ds);\n  return updateEncoder.toUint8Array();\n};\nvar createObfuscator = ({ formatting = true, subdocs = true, yxml = true } = {}) => {\n  let i = 0;\n  const mapKeyCache = create();\n  const nodeNameCache = create();\n  const formattingKeyCache = create();\n  const formattingValueCache = create();\n  formattingValueCache.set(null, null);\n  return (block) => {\n    switch (block.constructor) {\n      case GC:\n      case Skip:\n        return block;\n      case Item: {\n        const item = (\n          /** @type {Item} */\n          block\n        );\n        const content = item.content;\n        switch (content.constructor) {\n          case ContentDeleted:\n            break;\n          case ContentType: {\n            if (yxml) {\n              const type = (\n                /** @type {ContentType} */\n                content.type\n              );\n              if (type instanceof YXmlElement) {\n                type.nodeName = setIfUndefined(nodeNameCache, type.nodeName, () => \"node-\" + i);\n              }\n              if (type instanceof YXmlHook) {\n                type.hookName = setIfUndefined(nodeNameCache, type.hookName, () => \"hook-\" + i);\n              }\n            }\n            break;\n          }\n          case ContentAny: {\n            const c = (\n              /** @type {ContentAny} */\n              content\n            );\n            c.arr = c.arr.map(() => i);\n            break;\n          }\n          case ContentBinary: {\n            const c = (\n              /** @type {ContentBinary} */\n              content\n            );\n            c.content = new Uint8Array([i]);\n            break;\n          }\n          case ContentDoc: {\n            const c = (\n              /** @type {ContentDoc} */\n              content\n            );\n            if (subdocs) {\n              c.opts = {};\n              c.doc.guid = i + \"\";\n            }\n            break;\n          }\n          case ContentEmbed: {\n            const c = (\n              /** @type {ContentEmbed} */\n              content\n            );\n            c.embed = {};\n            break;\n          }\n          case ContentFormat: {\n            const c = (\n              /** @type {ContentFormat} */\n              content\n            );\n            if (formatting) {\n              c.key = setIfUndefined(formattingKeyCache, c.key, () => i + \"\");\n              c.value = setIfUndefined(formattingValueCache, c.value, () => ({ i }));\n            }\n            break;\n          }\n          case ContentJSON: {\n            const c = (\n              /** @type {ContentJSON} */\n              content\n            );\n            c.arr = c.arr.map(() => i);\n            break;\n          }\n          case ContentString: {\n            const c = (\n              /** @type {ContentString} */\n              content\n            );\n            c.str = repeat(i % 10 + \"\", c.str.length);\n            break;\n          }\n          default:\n            unexpectedCase();\n        }\n        if (item.parentSub) {\n          item.parentSub = setIfUndefined(mapKeyCache, item.parentSub, () => i + \"\");\n        }\n        i++;\n        return block;\n      }\n      default:\n        unexpectedCase();\n    }\n  };\n};\nvar obfuscateUpdate = (update, opts) => convertUpdateFormat(update, createObfuscator(opts), UpdateDecoderV1, UpdateEncoderV1);\nvar obfuscateUpdateV2 = (update, opts) => convertUpdateFormat(update, createObfuscator(opts), UpdateDecoderV2, UpdateEncoderV2);\nvar convertUpdateFormatV1ToV2 = (update) => convertUpdateFormat(update, id, UpdateDecoderV1, UpdateEncoderV2);\nvar convertUpdateFormatV2ToV1 = (update) => convertUpdateFormat(update, id, UpdateDecoderV2, UpdateEncoderV1);\nvar errorComputeChanges = \"You must not compute changes after the event-handler fired.\";\nvar YEvent = class {\n  /**\n   * @param {T} target The changed type.\n   * @param {Transaction} transaction\n   */\n  constructor(target, transaction) {\n    this.target = target;\n    this.currentTarget = target;\n    this.transaction = transaction;\n    this._changes = null;\n    this._keys = null;\n    this._delta = null;\n    this._path = null;\n  }\n  /**\n   * Computes the path from `y` to the changed type.\n   *\n   * @todo v14 should standardize on path: Array<{parent, index}> because that is easier to work with.\n   *\n   * The following property holds:\n   * @example\n   *   let type = y\n   *   event.path.forEach(dir => {\n   *     type = type.get(dir)\n   *   })\n   *   type === event.target // => true\n   */\n  get path() {\n    return this._path || (this._path = getPathTo(this.currentTarget, this.target));\n  }\n  /**\n   * Check if a struct is deleted by this event.\n   *\n   * In contrast to change.deleted, this method also returns true if the struct was added and then deleted.\n   *\n   * @param {AbstractStruct} struct\n   * @return {boolean}\n   */\n  deletes(struct) {\n    return isDeleted(this.transaction.deleteSet, struct.id);\n  }\n  /**\n   * @type {Map<string, { action: 'add' | 'update' | 'delete', oldValue: any, newValue: any }>}\n   */\n  get keys() {\n    if (this._keys === null) {\n      if (this.transaction.doc._transactionCleanups.length === 0) {\n        throw create3(errorComputeChanges);\n      }\n      const keys2 = /* @__PURE__ */ new Map();\n      const target = this.target;\n      const changed = (\n        /** @type Set<string|null> */\n        this.transaction.changed.get(target)\n      );\n      changed.forEach((key) => {\n        if (key !== null) {\n          const item = (\n            /** @type {Item} */\n            target._map.get(key)\n          );\n          let action;\n          let oldValue;\n          if (this.adds(item)) {\n            let prev = item.left;\n            while (prev !== null && this.adds(prev)) {\n              prev = prev.left;\n            }\n            if (this.deletes(item)) {\n              if (prev !== null && this.deletes(prev)) {\n                action = \"delete\";\n                oldValue = last(prev.content.getContent());\n              } else {\n                return;\n              }\n            } else {\n              if (prev !== null && this.deletes(prev)) {\n                action = \"update\";\n                oldValue = last(prev.content.getContent());\n              } else {\n                action = \"add\";\n                oldValue = void 0;\n              }\n            }\n          } else {\n            if (this.deletes(item)) {\n              action = \"delete\";\n              oldValue = last(\n                /** @type {Item} */\n                item.content.getContent()\n              );\n            } else {\n              return;\n            }\n          }\n          keys2.set(key, { action, oldValue });\n        }\n      });\n      this._keys = keys2;\n    }\n    return this._keys;\n  }\n  /**\n   * This is a computed property. Note that this can only be safely computed during the\n   * event call. Computing this property after other changes happened might result in\n   * unexpected behavior (incorrect computation of deltas). A safe way to collect changes\n   * is to store the `changes` or the `delta` object. Avoid storing the `transaction` object.\n   *\n   * @type {Array<{insert?: string | Array<any> | object | AbstractType<any>, retain?: number, delete?: number, attributes?: Object<string, any>}>}\n   */\n  get delta() {\n    return this.changes.delta;\n  }\n  /**\n   * Check if a struct is added by this event.\n   *\n   * In contrast to change.deleted, this method also returns true if the struct was added and then deleted.\n   *\n   * @param {AbstractStruct} struct\n   * @return {boolean}\n   */\n  adds(struct) {\n    return struct.id.clock >= (this.transaction.beforeState.get(struct.id.client) || 0);\n  }\n  /**\n   * This is a computed property. Note that this can only be safely computed during the\n   * event call. Computing this property after other changes happened might result in\n   * unexpected behavior (incorrect computation of deltas). A safe way to collect changes\n   * is to store the `changes` or the `delta` object. Avoid storing the `transaction` object.\n   *\n   * @type {{added:Set<Item>,deleted:Set<Item>,keys:Map<string,{action:'add'|'update'|'delete',oldValue:any}>,delta:Array<{insert?:Array<any>|string, delete?:number, retain?:number}>}}\n   */\n  get changes() {\n    let changes = this._changes;\n    if (changes === null) {\n      if (this.transaction.doc._transactionCleanups.length === 0) {\n        throw create3(errorComputeChanges);\n      }\n      const target = this.target;\n      const added = create2();\n      const deleted = create2();\n      const delta = [];\n      changes = {\n        added,\n        deleted,\n        delta,\n        keys: this.keys\n      };\n      const changed = (\n        /** @type Set<string|null> */\n        this.transaction.changed.get(target)\n      );\n      if (changed.has(null)) {\n        let lastOp = null;\n        const packOp = () => {\n          if (lastOp) {\n            delta.push(lastOp);\n          }\n        };\n        for (let item = target._start; item !== null; item = item.right) {\n          if (item.deleted) {\n            if (this.deletes(item) && !this.adds(item)) {\n              if (lastOp === null || lastOp.delete === void 0) {\n                packOp();\n                lastOp = { delete: 0 };\n              }\n              lastOp.delete += item.length;\n              deleted.add(item);\n            }\n          } else {\n            if (this.adds(item)) {\n              if (lastOp === null || lastOp.insert === void 0) {\n                packOp();\n                lastOp = { insert: [] };\n              }\n              lastOp.insert = lastOp.insert.concat(item.content.getContent());\n              added.add(item);\n            } else {\n              if (lastOp === null || lastOp.retain === void 0) {\n                packOp();\n                lastOp = { retain: 0 };\n              }\n              lastOp.retain += item.length;\n            }\n          }\n        }\n        if (lastOp !== null && lastOp.retain === void 0) {\n          packOp();\n        }\n      }\n      this._changes = changes;\n    }\n    return (\n      /** @type {any} */\n      changes\n    );\n  }\n};\nvar getPathTo = (parent, child) => {\n  const path = [];\n  while (child._item !== null && child !== parent) {\n    if (child._item.parentSub !== null) {\n      path.unshift(child._item.parentSub);\n    } else {\n      let i = 0;\n      let c = (\n        /** @type {AbstractType<any>} */\n        child._item.parent._start\n      );\n      while (c !== child._item && c !== null) {\n        if (!c.deleted) {\n          i++;\n        }\n        c = c.right;\n      }\n      path.unshift(i);\n    }\n    child = /** @type {AbstractType<any>} */\n    child._item.parent;\n  }\n  return path;\n};\nvar maxSearchMarker = 80;\nvar globalSearchMarkerTimestamp = 0;\nvar ArraySearchMarker = class {\n  /**\n   * @param {Item} p\n   * @param {number} index\n   */\n  constructor(p, index) {\n    p.marker = true;\n    this.p = p;\n    this.index = index;\n    this.timestamp = globalSearchMarkerTimestamp++;\n  }\n};\nvar refreshMarkerTimestamp = (marker) => {\n  marker.timestamp = globalSearchMarkerTimestamp++;\n};\nvar overwriteMarker = (marker, p, index) => {\n  marker.p.marker = false;\n  marker.p = p;\n  p.marker = true;\n  marker.index = index;\n  marker.timestamp = globalSearchMarkerTimestamp++;\n};\nvar markPosition = (searchMarker, p, index) => {\n  if (searchMarker.length >= maxSearchMarker) {\n    const marker = searchMarker.reduce((a, b) => a.timestamp < b.timestamp ? a : b);\n    overwriteMarker(marker, p, index);\n    return marker;\n  } else {\n    const pm = new ArraySearchMarker(p, index);\n    searchMarker.push(pm);\n    return pm;\n  }\n};\nvar findMarker = (yarray, index) => {\n  if (yarray._start === null || index === 0 || yarray._searchMarker === null) {\n    return null;\n  }\n  const marker = yarray._searchMarker.length === 0 ? null : yarray._searchMarker.reduce((a, b) => abs(index - a.index) < abs(index - b.index) ? a : b);\n  let p = yarray._start;\n  let pindex = 0;\n  if (marker !== null) {\n    p = marker.p;\n    pindex = marker.index;\n    refreshMarkerTimestamp(marker);\n  }\n  while (p.right !== null && pindex < index) {\n    if (!p.deleted && p.countable) {\n      if (index < pindex + p.length) {\n        break;\n      }\n      pindex += p.length;\n    }\n    p = p.right;\n  }\n  while (p.left !== null && pindex > index) {\n    p = p.left;\n    if (!p.deleted && p.countable) {\n      pindex -= p.length;\n    }\n  }\n  while (p.left !== null && p.left.id.client === p.id.client && p.left.id.clock + p.left.length === p.id.clock) {\n    p = p.left;\n    if (!p.deleted && p.countable) {\n      pindex -= p.length;\n    }\n  }\n  if (marker !== null && abs(marker.index - pindex) < /** @type {YText|YArray<any>} */\n  p.parent.length / maxSearchMarker) {\n    overwriteMarker(marker, p, pindex);\n    return marker;\n  } else {\n    return markPosition(yarray._searchMarker, p, pindex);\n  }\n};\nvar updateMarkerChanges = (searchMarker, index, len) => {\n  for (let i = searchMarker.length - 1; i >= 0; i--) {\n    const m = searchMarker[i];\n    if (len > 0) {\n      let p = m.p;\n      p.marker = false;\n      while (p && (p.deleted || !p.countable)) {\n        p = p.left;\n        if (p && !p.deleted && p.countable) {\n          m.index -= p.length;\n        }\n      }\n      if (p === null || p.marker === true) {\n        searchMarker.splice(i, 1);\n        continue;\n      }\n      m.p = p;\n      p.marker = true;\n    }\n    if (index < m.index || len > 0 && index === m.index) {\n      m.index = max(index, m.index + len);\n    }\n  }\n};\nvar getTypeChildren = (t) => {\n  let s = t._start;\n  const arr = [];\n  while (s) {\n    arr.push(s);\n    s = s.right;\n  }\n  return arr;\n};\nvar callTypeObservers = (type, transaction, event) => {\n  const changedType = type;\n  const changedParentTypes = transaction.changedParentTypes;\n  while (true) {\n    setIfUndefined(changedParentTypes, type, () => []).push(event);\n    if (type._item === null) {\n      break;\n    }\n    type = /** @type {AbstractType<any>} */\n    type._item.parent;\n  }\n  callEventHandlerListeners(changedType._eH, event, transaction);\n};\nvar AbstractType = class {\n  constructor() {\n    this._item = null;\n    this._map = /* @__PURE__ */ new Map();\n    this._start = null;\n    this.doc = null;\n    this._length = 0;\n    this._eH = createEventHandler();\n    this._dEH = createEventHandler();\n    this._searchMarker = null;\n  }\n  /**\n   * @return {AbstractType<any>|null}\n   */\n  get parent() {\n    return this._item ? (\n      /** @type {AbstractType<any>} */\n      this._item.parent\n    ) : null;\n  }\n  /**\n   * Integrate this type into the Yjs instance.\n   *\n   * * Save this struct in the os\n   * * This type is sent to other client\n   * * Observer functions are fired\n   *\n   * @param {Doc} y The Yjs instance\n   * @param {Item|null} item\n   */\n  _integrate(y, item) {\n    this.doc = y;\n    this._item = item;\n  }\n  /**\n   * @return {AbstractType<EventType>}\n   */\n  _copy() {\n    throw methodUnimplemented();\n  }\n  /**\n   * @return {AbstractType<EventType>}\n   */\n  clone() {\n    throw methodUnimplemented();\n  }\n  /**\n   * @param {UpdateEncoderV1 | UpdateEncoderV2} _encoder\n   */\n  _write(_encoder) {\n  }\n  /**\n   * The first non-deleted item\n   */\n  get _first() {\n    let n = this._start;\n    while (n !== null && n.deleted) {\n      n = n.right;\n    }\n    return n;\n  }\n  /**\n   * Creates YEvent and calls all type observers.\n   * Must be implemented by each type.\n   *\n   * @param {Transaction} transaction\n   * @param {Set<null|string>} _parentSubs Keys changed on this type. `null` if list was modified.\n   */\n  _callObserver(transaction, _parentSubs) {\n    if (!transaction.local && this._searchMarker) {\n      this._searchMarker.length = 0;\n    }\n  }\n  /**\n   * Observe all events that are created on this type.\n   *\n   * @param {function(EventType, Transaction):void} f Observer function\n   */\n  observe(f) {\n    addEventHandlerListener(this._eH, f);\n  }\n  /**\n   * Observe all events that are created by this type and its children.\n   *\n   * @param {function(Array<YEvent<any>>,Transaction):void} f Observer function\n   */\n  observeDeep(f) {\n    addEventHandlerListener(this._dEH, f);\n  }\n  /**\n   * Unregister an observer function.\n   *\n   * @param {function(EventType,Transaction):void} f Observer function\n   */\n  unobserve(f) {\n    removeEventHandlerListener(this._eH, f);\n  }\n  /**\n   * Unregister an observer function.\n   *\n   * @param {function(Array<YEvent<any>>,Transaction):void} f Observer function\n   */\n  unobserveDeep(f) {\n    removeEventHandlerListener(this._dEH, f);\n  }\n  /**\n   * @abstract\n   * @return {any}\n   */\n  toJSON() {\n  }\n};\nvar typeListSlice = (type, start, end) => {\n  if (start < 0) {\n    start = type._length + start;\n  }\n  if (end < 0) {\n    end = type._length + end;\n  }\n  let len = end - start;\n  const cs = [];\n  let n = type._start;\n  while (n !== null && len > 0) {\n    if (n.countable && !n.deleted) {\n      const c = n.content.getContent();\n      if (c.length <= start) {\n        start -= c.length;\n      } else {\n        for (let i = start; i < c.length && len > 0; i++) {\n          cs.push(c[i]);\n          len--;\n        }\n        start = 0;\n      }\n    }\n    n = n.right;\n  }\n  return cs;\n};\nvar typeListToArray = (type) => {\n  const cs = [];\n  let n = type._start;\n  while (n !== null) {\n    if (n.countable && !n.deleted) {\n      const c = n.content.getContent();\n      for (let i = 0; i < c.length; i++) {\n        cs.push(c[i]);\n      }\n    }\n    n = n.right;\n  }\n  return cs;\n};\nvar typeListToArraySnapshot = (type, snapshot2) => {\n  const cs = [];\n  let n = type._start;\n  while (n !== null) {\n    if (n.countable && isVisible(n, snapshot2)) {\n      const c = n.content.getContent();\n      for (let i = 0; i < c.length; i++) {\n        cs.push(c[i]);\n      }\n    }\n    n = n.right;\n  }\n  return cs;\n};\nvar typeListForEach = (type, f) => {\n  let index = 0;\n  let n = type._start;\n  while (n !== null) {\n    if (n.countable && !n.deleted) {\n      const c = n.content.getContent();\n      for (let i = 0; i < c.length; i++) {\n        f(c[i], index++, type);\n      }\n    }\n    n = n.right;\n  }\n};\nvar typeListMap = (type, f) => {\n  const result = [];\n  typeListForEach(type, (c, i) => {\n    result.push(f(c, i, type));\n  });\n  return result;\n};\nvar typeListCreateIterator = (type) => {\n  let n = type._start;\n  let currentContent = null;\n  let currentContentIndex = 0;\n  return {\n    [Symbol.iterator]() {\n      return this;\n    },\n    next: () => {\n      if (currentContent === null) {\n        while (n !== null && n.deleted) {\n          n = n.right;\n        }\n        if (n === null) {\n          return {\n            done: true,\n            value: void 0\n          };\n        }\n        currentContent = n.content.getContent();\n        currentContentIndex = 0;\n        n = n.right;\n      }\n      const value = currentContent[currentContentIndex++];\n      if (currentContent.length <= currentContentIndex) {\n        currentContent = null;\n      }\n      return {\n        done: false,\n        value\n      };\n    }\n  };\n};\nvar typeListGet = (type, index) => {\n  const marker = findMarker(type, index);\n  let n = type._start;\n  if (marker !== null) {\n    n = marker.p;\n    index -= marker.index;\n  }\n  for (; n !== null; n = n.right) {\n    if (!n.deleted && n.countable) {\n      if (index < n.length) {\n        return n.content.getContent()[index];\n      }\n      index -= n.length;\n    }\n  }\n};\nvar typeListInsertGenericsAfter = (transaction, parent, referenceItem, content) => {\n  let left = referenceItem;\n  const doc2 = transaction.doc;\n  const ownClientId = doc2.clientID;\n  const store = doc2.store;\n  const right = referenceItem === null ? parent._start : referenceItem.right;\n  let jsonContent = [];\n  const packJsonContent = () => {\n    if (jsonContent.length > 0) {\n      left = new Item(createID(ownClientId, getState(store, ownClientId)), left, left && left.lastId, right, right && right.id, parent, null, new ContentAny(jsonContent));\n      left.integrate(transaction, 0);\n      jsonContent = [];\n    }\n  };\n  content.forEach((c) => {\n    if (c === null) {\n      jsonContent.push(c);\n    } else {\n      switch (c.constructor) {\n        case Number:\n        case Object:\n        case Boolean:\n        case Array:\n        case String:\n          jsonContent.push(c);\n          break;\n        default:\n          packJsonContent();\n          switch (c.constructor) {\n            case Uint8Array:\n            case ArrayBuffer:\n              left = new Item(createID(ownClientId, getState(store, ownClientId)), left, left && left.lastId, right, right && right.id, parent, null, new ContentBinary(new Uint8Array(\n                /** @type {Uint8Array} */\n                c\n              )));\n              left.integrate(transaction, 0);\n              break;\n            case Doc:\n              left = new Item(createID(ownClientId, getState(store, ownClientId)), left, left && left.lastId, right, right && right.id, parent, null, new ContentDoc(\n                /** @type {Doc} */\n                c\n              ));\n              left.integrate(transaction, 0);\n              break;\n            default:\n              if (c instanceof AbstractType) {\n                left = new Item(createID(ownClientId, getState(store, ownClientId)), left, left && left.lastId, right, right && right.id, parent, null, new ContentType(c));\n                left.integrate(transaction, 0);\n              } else {\n                throw new Error(\"Unexpected content type in insert operation\");\n              }\n          }\n      }\n    }\n  });\n  packJsonContent();\n};\nvar lengthExceeded = create3(\"Length exceeded!\");\nvar typeListInsertGenerics = (transaction, parent, index, content) => {\n  if (index > parent._length) {\n    throw lengthExceeded;\n  }\n  if (index === 0) {\n    if (parent._searchMarker) {\n      updateMarkerChanges(parent._searchMarker, index, content.length);\n    }\n    return typeListInsertGenericsAfter(transaction, parent, null, content);\n  }\n  const startIndex = index;\n  const marker = findMarker(parent, index);\n  let n = parent._start;\n  if (marker !== null) {\n    n = marker.p;\n    index -= marker.index;\n    if (index === 0) {\n      n = n.prev;\n      index += n && n.countable && !n.deleted ? n.length : 0;\n    }\n  }\n  for (; n !== null; n = n.right) {\n    if (!n.deleted && n.countable) {\n      if (index <= n.length) {\n        if (index < n.length) {\n          getItemCleanStart(transaction, createID(n.id.client, n.id.clock + index));\n        }\n        break;\n      }\n      index -= n.length;\n    }\n  }\n  if (parent._searchMarker) {\n    updateMarkerChanges(parent._searchMarker, startIndex, content.length);\n  }\n  return typeListInsertGenericsAfter(transaction, parent, n, content);\n};\nvar typeListPushGenerics = (transaction, parent, content) => {\n  const marker = (parent._searchMarker || []).reduce((maxMarker, currMarker) => currMarker.index > maxMarker.index ? currMarker : maxMarker, { index: 0, p: parent._start });\n  let n = marker.p;\n  if (n) {\n    while (n.right) {\n      n = n.right;\n    }\n  }\n  return typeListInsertGenericsAfter(transaction, parent, n, content);\n};\nvar typeListDelete = (transaction, parent, index, length3) => {\n  if (length3 === 0) {\n    return;\n  }\n  const startIndex = index;\n  const startLength = length3;\n  const marker = findMarker(parent, index);\n  let n = parent._start;\n  if (marker !== null) {\n    n = marker.p;\n    index -= marker.index;\n  }\n  for (; n !== null && index > 0; n = n.right) {\n    if (!n.deleted && n.countable) {\n      if (index < n.length) {\n        getItemCleanStart(transaction, createID(n.id.client, n.id.clock + index));\n      }\n      index -= n.length;\n    }\n  }\n  while (length3 > 0 && n !== null) {\n    if (!n.deleted) {\n      if (length3 < n.length) {\n        getItemCleanStart(transaction, createID(n.id.client, n.id.clock + length3));\n      }\n      n.delete(transaction);\n      length3 -= n.length;\n    }\n    n = n.right;\n  }\n  if (length3 > 0) {\n    throw lengthExceeded;\n  }\n  if (parent._searchMarker) {\n    updateMarkerChanges(\n      parent._searchMarker,\n      startIndex,\n      -startLength + length3\n      /* in case we remove the above exception */\n    );\n  }\n};\nvar typeMapDelete = (transaction, parent, key) => {\n  const c = parent._map.get(key);\n  if (c !== void 0) {\n    c.delete(transaction);\n  }\n};\nvar typeMapSet = (transaction, parent, key, value) => {\n  const left = parent._map.get(key) || null;\n  const doc2 = transaction.doc;\n  const ownClientId = doc2.clientID;\n  let content;\n  if (value == null) {\n    content = new ContentAny([value]);\n  } else {\n    switch (value.constructor) {\n      case Number:\n      case Object:\n      case Boolean:\n      case Array:\n      case String:\n        content = new ContentAny([value]);\n        break;\n      case Uint8Array:\n        content = new ContentBinary(\n          /** @type {Uint8Array} */\n          value\n        );\n        break;\n      case Doc:\n        content = new ContentDoc(\n          /** @type {Doc} */\n          value\n        );\n        break;\n      default:\n        if (value instanceof AbstractType) {\n          content = new ContentType(value);\n        } else {\n          throw new Error(\"Unexpected content type\");\n        }\n    }\n  }\n  new Item(createID(ownClientId, getState(doc2.store, ownClientId)), left, left && left.lastId, null, null, parent, key, content).integrate(transaction, 0);\n};\nvar typeMapGet = (parent, key) => {\n  const val = parent._map.get(key);\n  return val !== void 0 && !val.deleted ? val.content.getContent()[val.length - 1] : void 0;\n};\nvar typeMapGetAll = (parent) => {\n  const res = {};\n  parent._map.forEach((value, key) => {\n    if (!value.deleted) {\n      res[key] = value.content.getContent()[value.length - 1];\n    }\n  });\n  return res;\n};\nvar typeMapHas = (parent, key) => {\n  const val = parent._map.get(key);\n  return val !== void 0 && !val.deleted;\n};\nvar typeMapGetSnapshot = (parent, key, snapshot2) => {\n  let v = parent._map.get(key) || null;\n  while (v !== null && (!snapshot2.sv.has(v.id.client) || v.id.clock >= (snapshot2.sv.get(v.id.client) || 0))) {\n    v = v.left;\n  }\n  return v !== null && isVisible(v, snapshot2) ? v.content.getContent()[v.length - 1] : void 0;\n};\nvar createMapIterator = (map3) => iteratorFilter(\n  map3.entries(),\n  /** @param {any} entry */\n  (entry) => !entry[1].deleted\n);\nvar YArrayEvent = class extends YEvent {\n  /**\n   * @param {YArray<T>} yarray The changed type\n   * @param {Transaction} transaction The transaction object\n   */\n  constructor(yarray, transaction) {\n    super(yarray, transaction);\n    this._transaction = transaction;\n  }\n};\nvar YArray = class _YArray extends AbstractType {\n  constructor() {\n    super();\n    this._prelimContent = [];\n    this._searchMarker = [];\n  }\n  /**\n   * Construct a new YArray containing the specified items.\n   * @template {Object<string,any>|Array<any>|number|null|string|Uint8Array} T\n   * @param {Array<T>} items\n   * @return {YArray<T>}\n   */\n  static from(items) {\n    const a = new _YArray();\n    a.push(items);\n    return a;\n  }\n  /**\n   * Integrate this type into the Yjs instance.\n   *\n   * * Save this struct in the os\n   * * This type is sent to other client\n   * * Observer functions are fired\n   *\n   * @param {Doc} y The Yjs instance\n   * @param {Item} item\n   */\n  _integrate(y, item) {\n    super._integrate(y, item);\n    this.insert(\n      0,\n      /** @type {Array<any>} */\n      this._prelimContent\n    );\n    this._prelimContent = null;\n  }\n  /**\n   * @return {YArray<T>}\n   */\n  _copy() {\n    return new _YArray();\n  }\n  /**\n   * @return {YArray<T>}\n   */\n  clone() {\n    const arr = new _YArray();\n    arr.insert(0, this.toArray().map(\n      (el) => el instanceof AbstractType ? (\n        /** @type {typeof el} */\n        el.clone()\n      ) : el\n    ));\n    return arr;\n  }\n  get length() {\n    return this._prelimContent === null ? this._length : this._prelimContent.length;\n  }\n  /**\n   * Creates YArrayEvent and calls observers.\n   *\n   * @param {Transaction} transaction\n   * @param {Set<null|string>} parentSubs Keys changed on this type. `null` if list was modified.\n   */\n  _callObserver(transaction, parentSubs) {\n    super._callObserver(transaction, parentSubs);\n    callTypeObservers(this, transaction, new YArrayEvent(this, transaction));\n  }\n  /**\n   * Inserts new content at an index.\n   *\n   * Important: This function expects an array of content. Not just a content\n   * object. The reason for this \"weirdness\" is that inserting several elements\n   * is very efficient when it is done as a single operation.\n   *\n   * @example\n   *  // Insert character 'a' at position 0\n   *  yarray.insert(0, ['a'])\n   *  // Insert numbers 1, 2 at position 1\n   *  yarray.insert(1, [1, 2])\n   *\n   * @param {number} index The index to insert content at.\n   * @param {Array<T>} content The array of content\n   */\n  insert(index, content) {\n    if (this.doc !== null) {\n      transact(this.doc, (transaction) => {\n        typeListInsertGenerics(\n          transaction,\n          this,\n          index,\n          /** @type {any} */\n          content\n        );\n      });\n    } else {\n      this._prelimContent.splice(index, 0, ...content);\n    }\n  }\n  /**\n   * Appends content to this YArray.\n   *\n   * @param {Array<T>} content Array of content to append.\n   *\n   * @todo Use the following implementation in all types.\n   */\n  push(content) {\n    if (this.doc !== null) {\n      transact(this.doc, (transaction) => {\n        typeListPushGenerics(\n          transaction,\n          this,\n          /** @type {any} */\n          content\n        );\n      });\n    } else {\n      this._prelimContent.push(...content);\n    }\n  }\n  /**\n   * Preppends content to this YArray.\n   *\n   * @param {Array<T>} content Array of content to preppend.\n   */\n  unshift(content) {\n    this.insert(0, content);\n  }\n  /**\n   * Deletes elements starting from an index.\n   *\n   * @param {number} index Index at which to start deleting elements\n   * @param {number} length The number of elements to remove. Defaults to 1.\n   */\n  delete(index, length3 = 1) {\n    if (this.doc !== null) {\n      transact(this.doc, (transaction) => {\n        typeListDelete(transaction, this, index, length3);\n      });\n    } else {\n      this._prelimContent.splice(index, length3);\n    }\n  }\n  /**\n   * Returns the i-th element from a YArray.\n   *\n   * @param {number} index The index of the element to return from the YArray\n   * @return {T}\n   */\n  get(index) {\n    return typeListGet(this, index);\n  }\n  /**\n   * Transforms this YArray to a JavaScript Array.\n   *\n   * @return {Array<T>}\n   */\n  toArray() {\n    return typeListToArray(this);\n  }\n  /**\n   * Transforms this YArray to a JavaScript Array.\n   *\n   * @param {number} [start]\n   * @param {number} [end]\n   * @return {Array<T>}\n   */\n  slice(start = 0, end = this.length) {\n    return typeListSlice(this, start, end);\n  }\n  /**\n   * Transforms this Shared Type to a JSON object.\n   *\n   * @return {Array<any>}\n   */\n  toJSON() {\n    return this.map((c) => c instanceof AbstractType ? c.toJSON() : c);\n  }\n  /**\n   * Returns an Array with the result of calling a provided function on every\n   * element of this YArray.\n   *\n   * @template M\n   * @param {function(T,number,YArray<T>):M} f Function that produces an element of the new Array\n   * @return {Array<M>} A new array with each element being the result of the\n   *                 callback function\n   */\n  map(f) {\n    return typeListMap(\n      this,\n      /** @type {any} */\n      f\n    );\n  }\n  /**\n   * Executes a provided function once on overy element of this YArray.\n   *\n   * @param {function(T,number,YArray<T>):void} f A function to execute on every element of this YArray.\n   */\n  forEach(f) {\n    typeListForEach(this, f);\n  }\n  /**\n   * @return {IterableIterator<T>}\n   */\n  [Symbol.iterator]() {\n    return typeListCreateIterator(this);\n  }\n  /**\n   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder\n   */\n  _write(encoder) {\n    encoder.writeTypeRef(YArrayRefID);\n  }\n};\nvar readYArray = (_decoder) => new YArray();\nvar YMapEvent = class extends YEvent {\n  /**\n   * @param {YMap<T>} ymap The YArray that changed.\n   * @param {Transaction} transaction\n   * @param {Set<any>} subs The keys that changed.\n   */\n  constructor(ymap, transaction, subs) {\n    super(ymap, transaction);\n    this.keysChanged = subs;\n  }\n};\nvar YMap = class _YMap extends AbstractType {\n  /**\n   *\n   * @param {Iterable<readonly [string, any]>=} entries - an optional iterable to initialize the YMap\n   */\n  constructor(entries) {\n    super();\n    this._prelimContent = null;\n    if (entries === void 0) {\n      this._prelimContent = /* @__PURE__ */ new Map();\n    } else {\n      this._prelimContent = new Map(entries);\n    }\n  }\n  /**\n   * Integrate this type into the Yjs instance.\n   *\n   * * Save this struct in the os\n   * * This type is sent to other client\n   * * Observer functions are fired\n   *\n   * @param {Doc} y The Yjs instance\n   * @param {Item} item\n   */\n  _integrate(y, item) {\n    super._integrate(y, item);\n    this._prelimContent.forEach((value, key) => {\n      this.set(key, value);\n    });\n    this._prelimContent = null;\n  }\n  /**\n   * @return {YMap<MapType>}\n   */\n  _copy() {\n    return new _YMap();\n  }\n  /**\n   * @return {YMap<MapType>}\n   */\n  clone() {\n    const map3 = new _YMap();\n    this.forEach((value, key) => {\n      map3.set(key, value instanceof AbstractType ? (\n        /** @type {typeof value} */\n        value.clone()\n      ) : value);\n    });\n    return map3;\n  }\n  /**\n   * Creates YMapEvent and calls observers.\n   *\n   * @param {Transaction} transaction\n   * @param {Set<null|string>} parentSubs Keys changed on this type. `null` if list was modified.\n   */\n  _callObserver(transaction, parentSubs) {\n    callTypeObservers(this, transaction, new YMapEvent(this, transaction, parentSubs));\n  }\n  /**\n   * Transforms this Shared Type to a JSON object.\n   *\n   * @return {Object<string,any>}\n   */\n  toJSON() {\n    const map3 = {};\n    this._map.forEach((item, key) => {\n      if (!item.deleted) {\n        const v = item.content.getContent()[item.length - 1];\n        map3[key] = v instanceof AbstractType ? v.toJSON() : v;\n      }\n    });\n    return map3;\n  }\n  /**\n   * Returns the size of the YMap (count of key/value pairs)\n   *\n   * @return {number}\n   */\n  get size() {\n    return [...createMapIterator(this._map)].length;\n  }\n  /**\n   * Returns the keys for each element in the YMap Type.\n   *\n   * @return {IterableIterator<string>}\n   */\n  keys() {\n    return iteratorMap(\n      createMapIterator(this._map),\n      /** @param {any} v */\n      (v) => v[0]\n    );\n  }\n  /**\n   * Returns the values for each element in the YMap Type.\n   *\n   * @return {IterableIterator<any>}\n   */\n  values() {\n    return iteratorMap(\n      createMapIterator(this._map),\n      /** @param {any} v */\n      (v) => v[1].content.getContent()[v[1].length - 1]\n    );\n  }\n  /**\n   * Returns an Iterator of [key, value] pairs\n   *\n   * @return {IterableIterator<any>}\n   */\n  entries() {\n    return iteratorMap(\n      createMapIterator(this._map),\n      /** @param {any} v */\n      (v) => [v[0], v[1].content.getContent()[v[1].length - 1]]\n    );\n  }\n  /**\n   * Executes a provided function on once on every key-value pair.\n   *\n   * @param {function(MapType,string,YMap<MapType>):void} f A function to execute on every element of this YArray.\n   */\n  forEach(f) {\n    this._map.forEach((item, key) => {\n      if (!item.deleted) {\n        f(item.content.getContent()[item.length - 1], key, this);\n      }\n    });\n  }\n  /**\n   * Returns an Iterator of [key, value] pairs\n   *\n   * @return {IterableIterator<any>}\n   */\n  [Symbol.iterator]() {\n    return this.entries();\n  }\n  /**\n   * Remove a specified element from this YMap.\n   *\n   * @param {string} key The key of the element to remove.\n   */\n  delete(key) {\n    if (this.doc !== null) {\n      transact(this.doc, (transaction) => {\n        typeMapDelete(transaction, this, key);\n      });\n    } else {\n      this._prelimContent.delete(key);\n    }\n  }\n  /**\n   * Adds or updates an element with a specified key and value.\n   * @template {MapType} VAL\n   *\n   * @param {string} key The key of the element to add to this YMap\n   * @param {VAL} value The value of the element to add\n   * @return {VAL}\n   */\n  set(key, value) {\n    if (this.doc !== null) {\n      transact(this.doc, (transaction) => {\n        typeMapSet(\n          transaction,\n          this,\n          key,\n          /** @type {any} */\n          value\n        );\n      });\n    } else {\n      this._prelimContent.set(key, value);\n    }\n    return value;\n  }\n  /**\n   * Returns a specified element from this YMap.\n   *\n   * @param {string} key\n   * @return {MapType|undefined}\n   */\n  get(key) {\n    return (\n      /** @type {any} */\n      typeMapGet(this, key)\n    );\n  }\n  /**\n   * Returns a boolean indicating whether the specified key exists or not.\n   *\n   * @param {string} key The key to test.\n   * @return {boolean}\n   */\n  has(key) {\n    return typeMapHas(this, key);\n  }\n  /**\n   * Removes all elements from this YMap.\n   */\n  clear() {\n    if (this.doc !== null) {\n      transact(this.doc, (transaction) => {\n        this.forEach(function(_value, key, map3) {\n          typeMapDelete(transaction, map3, key);\n        });\n      });\n    } else {\n      this._prelimContent.clear();\n    }\n  }\n  /**\n   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder\n   */\n  _write(encoder) {\n    encoder.writeTypeRef(YMapRefID);\n  }\n};\nvar readYMap = (_decoder) => new YMap();\nvar equalAttrs = (a, b) => a === b || typeof a === \"object\" && typeof b === \"object\" && a && b && equalFlat(a, b);\nvar ItemTextListPosition = class {\n  /**\n   * @param {Item|null} left\n   * @param {Item|null} right\n   * @param {number} index\n   * @param {Map<string,any>} currentAttributes\n   */\n  constructor(left, right, index, currentAttributes) {\n    this.left = left;\n    this.right = right;\n    this.index = index;\n    this.currentAttributes = currentAttributes;\n  }\n  /**\n   * Only call this if you know that this.right is defined\n   */\n  forward() {\n    if (this.right === null) {\n      unexpectedCase();\n    }\n    switch (this.right.content.constructor) {\n      case ContentFormat:\n        if (!this.right.deleted) {\n          updateCurrentAttributes(\n            this.currentAttributes,\n            /** @type {ContentFormat} */\n            this.right.content\n          );\n        }\n        break;\n      default:\n        if (!this.right.deleted) {\n          this.index += this.right.length;\n        }\n        break;\n    }\n    this.left = this.right;\n    this.right = this.right.right;\n  }\n};\nvar findNextPosition = (transaction, pos, count) => {\n  while (pos.right !== null && count > 0) {\n    switch (pos.right.content.constructor) {\n      case ContentFormat:\n        if (!pos.right.deleted) {\n          updateCurrentAttributes(\n            pos.currentAttributes,\n            /** @type {ContentFormat} */\n            pos.right.content\n          );\n        }\n        break;\n      default:\n        if (!pos.right.deleted) {\n          if (count < pos.right.length) {\n            getItemCleanStart(transaction, createID(pos.right.id.client, pos.right.id.clock + count));\n          }\n          pos.index += pos.right.length;\n          count -= pos.right.length;\n        }\n        break;\n    }\n    pos.left = pos.right;\n    pos.right = pos.right.right;\n  }\n  return pos;\n};\nvar findPosition = (transaction, parent, index) => {\n  const currentAttributes = /* @__PURE__ */ new Map();\n  const marker = findMarker(parent, index);\n  if (marker) {\n    const pos = new ItemTextListPosition(marker.p.left, marker.p, marker.index, currentAttributes);\n    return findNextPosition(transaction, pos, index - marker.index);\n  } else {\n    const pos = new ItemTextListPosition(null, parent._start, 0, currentAttributes);\n    return findNextPosition(transaction, pos, index);\n  }\n};\nvar insertNegatedAttributes = (transaction, parent, currPos, negatedAttributes) => {\n  while (currPos.right !== null && (currPos.right.deleted === true || currPos.right.content.constructor === ContentFormat && equalAttrs(\n    negatedAttributes.get(\n      /** @type {ContentFormat} */\n      currPos.right.content.key\n    ),\n    /** @type {ContentFormat} */\n    currPos.right.content.value\n  ))) {\n    if (!currPos.right.deleted) {\n      negatedAttributes.delete(\n        /** @type {ContentFormat} */\n        currPos.right.content.key\n      );\n    }\n    currPos.forward();\n  }\n  const doc2 = transaction.doc;\n  const ownClientId = doc2.clientID;\n  negatedAttributes.forEach((val, key) => {\n    const left = currPos.left;\n    const right = currPos.right;\n    const nextFormat = new Item(createID(ownClientId, getState(doc2.store, ownClientId)), left, left && left.lastId, right, right && right.id, parent, null, new ContentFormat(key, val));\n    nextFormat.integrate(transaction, 0);\n    currPos.right = nextFormat;\n    currPos.forward();\n  });\n};\nvar updateCurrentAttributes = (currentAttributes, format) => {\n  const { key, value } = format;\n  if (value === null) {\n    currentAttributes.delete(key);\n  } else {\n    currentAttributes.set(key, value);\n  }\n};\nvar minimizeAttributeChanges = (currPos, attributes) => {\n  while (true) {\n    if (currPos.right === null) {\n      break;\n    } else if (currPos.right.deleted || currPos.right.content.constructor === ContentFormat && equalAttrs(\n      attributes[\n        /** @type {ContentFormat} */\n        currPos.right.content.key\n      ] || null,\n      /** @type {ContentFormat} */\n      currPos.right.content.value\n    ))\n      ;\n    else {\n      break;\n    }\n    currPos.forward();\n  }\n};\nvar insertAttributes = (transaction, parent, currPos, attributes) => {\n  const doc2 = transaction.doc;\n  const ownClientId = doc2.clientID;\n  const negatedAttributes = /* @__PURE__ */ new Map();\n  for (const key in attributes) {\n    const val = attributes[key];\n    const currentVal = currPos.currentAttributes.get(key) || null;\n    if (!equalAttrs(currentVal, val)) {\n      negatedAttributes.set(key, currentVal);\n      const { left, right } = currPos;\n      currPos.right = new Item(createID(ownClientId, getState(doc2.store, ownClientId)), left, left && left.lastId, right, right && right.id, parent, null, new ContentFormat(key, val));\n      currPos.right.integrate(transaction, 0);\n      currPos.forward();\n    }\n  }\n  return negatedAttributes;\n};\nvar insertText = (transaction, parent, currPos, text2, attributes) => {\n  currPos.currentAttributes.forEach((_val, key) => {\n    if (attributes[key] === void 0) {\n      attributes[key] = null;\n    }\n  });\n  const doc2 = transaction.doc;\n  const ownClientId = doc2.clientID;\n  minimizeAttributeChanges(currPos, attributes);\n  const negatedAttributes = insertAttributes(transaction, parent, currPos, attributes);\n  const content = text2.constructor === String ? new ContentString(\n    /** @type {string} */\n    text2\n  ) : text2 instanceof AbstractType ? new ContentType(text2) : new ContentEmbed(text2);\n  let { left, right, index } = currPos;\n  if (parent._searchMarker) {\n    updateMarkerChanges(parent._searchMarker, currPos.index, content.getLength());\n  }\n  right = new Item(createID(ownClientId, getState(doc2.store, ownClientId)), left, left && left.lastId, right, right && right.id, parent, null, content);\n  right.integrate(transaction, 0);\n  currPos.right = right;\n  currPos.index = index;\n  currPos.forward();\n  insertNegatedAttributes(transaction, parent, currPos, negatedAttributes);\n};\nvar formatText = (transaction, parent, currPos, length3, attributes) => {\n  const doc2 = transaction.doc;\n  const ownClientId = doc2.clientID;\n  minimizeAttributeChanges(currPos, attributes);\n  const negatedAttributes = insertAttributes(transaction, parent, currPos, attributes);\n  iterationLoop:\n    while (currPos.right !== null && (length3 > 0 || negatedAttributes.size > 0 && (currPos.right.deleted || currPos.right.content.constructor === ContentFormat))) {\n      if (!currPos.right.deleted) {\n        switch (currPos.right.content.constructor) {\n          case ContentFormat: {\n            const { key, value } = (\n              /** @type {ContentFormat} */\n              currPos.right.content\n            );\n            const attr = attributes[key];\n            if (attr !== void 0) {\n              if (equalAttrs(attr, value)) {\n                negatedAttributes.delete(key);\n              } else {\n                if (length3 === 0) {\n                  break iterationLoop;\n                }\n                negatedAttributes.set(key, value);\n              }\n              currPos.right.delete(transaction);\n            } else {\n              currPos.currentAttributes.set(key, value);\n            }\n            break;\n          }\n          default:\n            if (length3 < currPos.right.length) {\n              getItemCleanStart(transaction, createID(currPos.right.id.client, currPos.right.id.clock + length3));\n            }\n            length3 -= currPos.right.length;\n            break;\n        }\n      }\n      currPos.forward();\n    }\n  if (length3 > 0) {\n    let newlines = \"\";\n    for (; length3 > 0; length3--) {\n      newlines += \"\\n\";\n    }\n    currPos.right = new Item(createID(ownClientId, getState(doc2.store, ownClientId)), currPos.left, currPos.left && currPos.left.lastId, currPos.right, currPos.right && currPos.right.id, parent, null, new ContentString(newlines));\n    currPos.right.integrate(transaction, 0);\n    currPos.forward();\n  }\n  insertNegatedAttributes(transaction, parent, currPos, negatedAttributes);\n};\nvar cleanupFormattingGap = (transaction, start, curr, startAttributes, currAttributes) => {\n  let end = start;\n  const endFormats = create();\n  while (end && (!end.countable || end.deleted)) {\n    if (!end.deleted && end.content.constructor === ContentFormat) {\n      const cf = (\n        /** @type {ContentFormat} */\n        end.content\n      );\n      endFormats.set(cf.key, cf);\n    }\n    end = end.right;\n  }\n  let cleanups = 0;\n  let reachedCurr = false;\n  while (start !== end) {\n    if (curr === start) {\n      reachedCurr = true;\n    }\n    if (!start.deleted) {\n      const content = start.content;\n      switch (content.constructor) {\n        case ContentFormat: {\n          const { key, value } = (\n            /** @type {ContentFormat} */\n            content\n          );\n          const startAttrValue = startAttributes.get(key) || null;\n          if (endFormats.get(key) !== content || startAttrValue === value) {\n            start.delete(transaction);\n            cleanups++;\n            if (!reachedCurr && (currAttributes.get(key) || null) === value && startAttrValue !== value) {\n              if (startAttrValue === null) {\n                currAttributes.delete(key);\n              } else {\n                currAttributes.set(key, startAttrValue);\n              }\n            }\n          }\n          if (!reachedCurr && !start.deleted) {\n            updateCurrentAttributes(\n              currAttributes,\n              /** @type {ContentFormat} */\n              content\n            );\n          }\n          break;\n        }\n      }\n    }\n    start = /** @type {Item} */\n    start.right;\n  }\n  return cleanups;\n};\nvar cleanupContextlessFormattingGap = (transaction, item) => {\n  while (item && item.right && (item.right.deleted || !item.right.countable)) {\n    item = item.right;\n  }\n  const attrs = /* @__PURE__ */ new Set();\n  while (item && (item.deleted || !item.countable)) {\n    if (!item.deleted && item.content.constructor === ContentFormat) {\n      const key = (\n        /** @type {ContentFormat} */\n        item.content.key\n      );\n      if (attrs.has(key)) {\n        item.delete(transaction);\n      } else {\n        attrs.add(key);\n      }\n    }\n    item = item.left;\n  }\n};\nvar cleanupYTextFormatting = (type) => {\n  let res = 0;\n  transact(\n    /** @type {Doc} */\n    type.doc,\n    (transaction) => {\n      let start = (\n        /** @type {Item} */\n        type._start\n      );\n      let end = type._start;\n      let startAttributes = create();\n      const currentAttributes = copy(startAttributes);\n      while (end) {\n        if (end.deleted === false) {\n          switch (end.content.constructor) {\n            case ContentFormat:\n              updateCurrentAttributes(\n                currentAttributes,\n                /** @type {ContentFormat} */\n                end.content\n              );\n              break;\n            default:\n              res += cleanupFormattingGap(transaction, start, end, startAttributes, currentAttributes);\n              startAttributes = copy(currentAttributes);\n              start = end;\n              break;\n          }\n        }\n        end = end.right;\n      }\n    }\n  );\n  return res;\n};\nvar cleanupYTextAfterTransaction = (transaction) => {\n  const needFullCleanup = /* @__PURE__ */ new Set();\n  const doc2 = transaction.doc;\n  for (const [client, afterClock] of transaction.afterState.entries()) {\n    const clock = transaction.beforeState.get(client) || 0;\n    if (afterClock === clock) {\n      continue;\n    }\n    iterateStructs(\n      transaction,\n      /** @type {Array<Item|GC>} */\n      doc2.store.clients.get(client),\n      clock,\n      afterClock,\n      (item) => {\n        if (!item.deleted && /** @type {Item} */\n        item.content.constructor === ContentFormat && item.constructor !== GC) {\n          needFullCleanup.add(\n            /** @type {any} */\n            item.parent\n          );\n        }\n      }\n    );\n  }\n  transact(doc2, (t) => {\n    iterateDeletedStructs(transaction, transaction.deleteSet, (item) => {\n      if (item instanceof GC || !/** @type {YText} */\n      item.parent._hasFormatting || needFullCleanup.has(\n        /** @type {YText} */\n        item.parent\n      )) {\n        return;\n      }\n      const parent = (\n        /** @type {YText} */\n        item.parent\n      );\n      if (item.content.constructor === ContentFormat) {\n        needFullCleanup.add(parent);\n      } else {\n        cleanupContextlessFormattingGap(t, item);\n      }\n    });\n    for (const yText of needFullCleanup) {\n      cleanupYTextFormatting(yText);\n    }\n  });\n};\nvar deleteText = (transaction, currPos, length3) => {\n  const startLength = length3;\n  const startAttrs = copy(currPos.currentAttributes);\n  const start = currPos.right;\n  while (length3 > 0 && currPos.right !== null) {\n    if (currPos.right.deleted === false) {\n      switch (currPos.right.content.constructor) {\n        case ContentType:\n        case ContentEmbed:\n        case ContentString:\n          if (length3 < currPos.right.length) {\n            getItemCleanStart(transaction, createID(currPos.right.id.client, currPos.right.id.clock + length3));\n          }\n          length3 -= currPos.right.length;\n          currPos.right.delete(transaction);\n          break;\n      }\n    }\n    currPos.forward();\n  }\n  if (start) {\n    cleanupFormattingGap(transaction, start, currPos.right, startAttrs, currPos.currentAttributes);\n  }\n  const parent = (\n    /** @type {AbstractType<any>} */\n    /** @type {Item} */\n    (currPos.left || currPos.right).parent\n  );\n  if (parent._searchMarker) {\n    updateMarkerChanges(parent._searchMarker, currPos.index, -startLength + length3);\n  }\n  return currPos;\n};\nvar YTextEvent = class extends YEvent {\n  /**\n   * @param {YText} ytext\n   * @param {Transaction} transaction\n   * @param {Set<any>} subs The keys that changed\n   */\n  constructor(ytext, transaction, subs) {\n    super(ytext, transaction);\n    this.childListChanged = false;\n    this.keysChanged = /* @__PURE__ */ new Set();\n    subs.forEach((sub) => {\n      if (sub === null) {\n        this.childListChanged = true;\n      } else {\n        this.keysChanged.add(sub);\n      }\n    });\n  }\n  /**\n   * @type {{added:Set<Item>,deleted:Set<Item>,keys:Map<string,{action:'add'|'update'|'delete',oldValue:any}>,delta:Array<{insert?:Array<any>|string, delete?:number, retain?:number}>}}\n   */\n  get changes() {\n    if (this._changes === null) {\n      const changes = {\n        keys: this.keys,\n        delta: this.delta,\n        added: /* @__PURE__ */ new Set(),\n        deleted: /* @__PURE__ */ new Set()\n      };\n      this._changes = changes;\n    }\n    return (\n      /** @type {any} */\n      this._changes\n    );\n  }\n  /**\n   * Compute the changes in the delta format.\n   * A {@link https://quilljs.com/docs/delta/|Quill Delta}) that represents the changes on the document.\n   *\n   * @type {Array<{insert?:string|object|AbstractType<any>, delete?:number, retain?:number, attributes?: Object<string,any>}>}\n   *\n   * @public\n   */\n  get delta() {\n    if (this._delta === null) {\n      const y = (\n        /** @type {Doc} */\n        this.target.doc\n      );\n      const delta = [];\n      transact(y, (transaction) => {\n        const currentAttributes = /* @__PURE__ */ new Map();\n        const oldAttributes = /* @__PURE__ */ new Map();\n        let item = this.target._start;\n        let action = null;\n        const attributes = {};\n        let insert = \"\";\n        let retain = 0;\n        let deleteLen = 0;\n        const addOp = () => {\n          if (action !== null) {\n            let op = null;\n            switch (action) {\n              case \"delete\":\n                if (deleteLen > 0) {\n                  op = { delete: deleteLen };\n                }\n                deleteLen = 0;\n                break;\n              case \"insert\":\n                if (typeof insert === \"object\" || insert.length > 0) {\n                  op = { insert };\n                  if (currentAttributes.size > 0) {\n                    op.attributes = {};\n                    currentAttributes.forEach((value, key) => {\n                      if (value !== null) {\n                        op.attributes[key] = value;\n                      }\n                    });\n                  }\n                }\n                insert = \"\";\n                break;\n              case \"retain\":\n                if (retain > 0) {\n                  op = { retain };\n                  if (!isEmpty(attributes)) {\n                    op.attributes = assign({}, attributes);\n                  }\n                }\n                retain = 0;\n                break;\n            }\n            if (op)\n              delta.push(op);\n            action = null;\n          }\n        };\n        while (item !== null) {\n          switch (item.content.constructor) {\n            case ContentType:\n            case ContentEmbed:\n              if (this.adds(item)) {\n                if (!this.deletes(item)) {\n                  addOp();\n                  action = \"insert\";\n                  insert = item.content.getContent()[0];\n                  addOp();\n                }\n              } else if (this.deletes(item)) {\n                if (action !== \"delete\") {\n                  addOp();\n                  action = \"delete\";\n                }\n                deleteLen += 1;\n              } else if (!item.deleted) {\n                if (action !== \"retain\") {\n                  addOp();\n                  action = \"retain\";\n                }\n                retain += 1;\n              }\n              break;\n            case ContentString:\n              if (this.adds(item)) {\n                if (!this.deletes(item)) {\n                  if (action !== \"insert\") {\n                    addOp();\n                    action = \"insert\";\n                  }\n                  insert += /** @type {ContentString} */\n                  item.content.str;\n                }\n              } else if (this.deletes(item)) {\n                if (action !== \"delete\") {\n                  addOp();\n                  action = \"delete\";\n                }\n                deleteLen += item.length;\n              } else if (!item.deleted) {\n                if (action !== \"retain\") {\n                  addOp();\n                  action = \"retain\";\n                }\n                retain += item.length;\n              }\n              break;\n            case ContentFormat: {\n              const { key, value } = (\n                /** @type {ContentFormat} */\n                item.content\n              );\n              if (this.adds(item)) {\n                if (!this.deletes(item)) {\n                  const curVal = currentAttributes.get(key) || null;\n                  if (!equalAttrs(curVal, value)) {\n                    if (action === \"retain\") {\n                      addOp();\n                    }\n                    if (equalAttrs(value, oldAttributes.get(key) || null)) {\n                      delete attributes[key];\n                    } else {\n                      attributes[key] = value;\n                    }\n                  } else if (value !== null) {\n                    item.delete(transaction);\n                  }\n                }\n              } else if (this.deletes(item)) {\n                oldAttributes.set(key, value);\n                const curVal = currentAttributes.get(key) || null;\n                if (!equalAttrs(curVal, value)) {\n                  if (action === \"retain\") {\n                    addOp();\n                  }\n                  attributes[key] = curVal;\n                }\n              } else if (!item.deleted) {\n                oldAttributes.set(key, value);\n                const attr = attributes[key];\n                if (attr !== void 0) {\n                  if (!equalAttrs(attr, value)) {\n                    if (action === \"retain\") {\n                      addOp();\n                    }\n                    if (value === null) {\n                      delete attributes[key];\n                    } else {\n                      attributes[key] = value;\n                    }\n                  } else if (attr !== null) {\n                    item.delete(transaction);\n                  }\n                }\n              }\n              if (!item.deleted) {\n                if (action === \"insert\") {\n                  addOp();\n                }\n                updateCurrentAttributes(\n                  currentAttributes,\n                  /** @type {ContentFormat} */\n                  item.content\n                );\n              }\n              break;\n            }\n          }\n          item = item.right;\n        }\n        addOp();\n        while (delta.length > 0) {\n          const lastOp = delta[delta.length - 1];\n          if (lastOp.retain !== void 0 && lastOp.attributes === void 0) {\n            delta.pop();\n          } else {\n            break;\n          }\n        }\n      });\n      this._delta = delta;\n    }\n    return (\n      /** @type {any} */\n      this._delta\n    );\n  }\n};\nvar YText = class _YText extends AbstractType {\n  /**\n   * @param {String} [string] The initial value of the YText.\n   */\n  constructor(string) {\n    super();\n    this._pending = string !== void 0 ? [() => this.insert(0, string)] : [];\n    this._searchMarker = [];\n    this._hasFormatting = false;\n  }\n  /**\n   * Number of characters of this text type.\n   *\n   * @type {number}\n   */\n  get length() {\n    return this._length;\n  }\n  /**\n   * @param {Doc} y\n   * @param {Item} item\n   */\n  _integrate(y, item) {\n    super._integrate(y, item);\n    try {\n      this._pending.forEach((f) => f());\n    } catch (e) {\n      console.error(e);\n    }\n    this._pending = null;\n  }\n  _copy() {\n    return new _YText();\n  }\n  /**\n   * @return {YText}\n   */\n  clone() {\n    const text2 = new _YText();\n    text2.applyDelta(this.toDelta());\n    return text2;\n  }\n  /**\n   * Creates YTextEvent and calls observers.\n   *\n   * @param {Transaction} transaction\n   * @param {Set<null|string>} parentSubs Keys changed on this type. `null` if list was modified.\n   */\n  _callObserver(transaction, parentSubs) {\n    super._callObserver(transaction, parentSubs);\n    const event = new YTextEvent(this, transaction, parentSubs);\n    callTypeObservers(this, transaction, event);\n    if (!transaction.local && this._hasFormatting) {\n      transaction._needFormattingCleanup = true;\n    }\n  }\n  /**\n   * Returns the unformatted string representation of this YText type.\n   *\n   * @public\n   */\n  toString() {\n    let str = \"\";\n    let n = this._start;\n    while (n !== null) {\n      if (!n.deleted && n.countable && n.content.constructor === ContentString) {\n        str += /** @type {ContentString} */\n        n.content.str;\n      }\n      n = n.right;\n    }\n    return str;\n  }\n  /**\n   * Returns the unformatted string representation of this YText type.\n   *\n   * @return {string}\n   * @public\n   */\n  toJSON() {\n    return this.toString();\n  }\n  /**\n   * Apply a {@link Delta} on this shared YText type.\n   *\n   * @param {any} delta The changes to apply on this element.\n   * @param {object}  opts\n   * @param {boolean} [opts.sanitize] Sanitize input delta. Removes ending newlines if set to true.\n   *\n   *\n   * @public\n   */\n  applyDelta(delta, { sanitize = true } = {}) {\n    if (this.doc !== null) {\n      transact(this.doc, (transaction) => {\n        const currPos = new ItemTextListPosition(null, this._start, 0, /* @__PURE__ */ new Map());\n        for (let i = 0; i < delta.length; i++) {\n          const op = delta[i];\n          if (op.insert !== void 0) {\n            const ins = !sanitize && typeof op.insert === \"string\" && i === delta.length - 1 && currPos.right === null && op.insert.slice(-1) === \"\\n\" ? op.insert.slice(0, -1) : op.insert;\n            if (typeof ins !== \"string\" || ins.length > 0) {\n              insertText(transaction, this, currPos, ins, op.attributes || {});\n            }\n          } else if (op.retain !== void 0) {\n            formatText(transaction, this, currPos, op.retain, op.attributes || {});\n          } else if (op.delete !== void 0) {\n            deleteText(transaction, currPos, op.delete);\n          }\n        }\n      });\n    } else {\n      this._pending.push(() => this.applyDelta(delta));\n    }\n  }\n  /**\n   * Returns the Delta representation of this YText type.\n   *\n   * @param {Snapshot} [snapshot]\n   * @param {Snapshot} [prevSnapshot]\n   * @param {function('removed' | 'added', ID):any} [computeYChange]\n   * @return {any} The Delta representation of this type.\n   *\n   * @public\n   */\n  toDelta(snapshot2, prevSnapshot, computeYChange) {\n    const ops = [];\n    const currentAttributes = /* @__PURE__ */ new Map();\n    const doc2 = (\n      /** @type {Doc} */\n      this.doc\n    );\n    let str = \"\";\n    let n = this._start;\n    function packStr() {\n      if (str.length > 0) {\n        const attributes = {};\n        let addAttributes = false;\n        currentAttributes.forEach((value, key) => {\n          addAttributes = true;\n          attributes[key] = value;\n        });\n        const op = { insert: str };\n        if (addAttributes) {\n          op.attributes = attributes;\n        }\n        ops.push(op);\n        str = \"\";\n      }\n    }\n    const computeDelta = () => {\n      while (n !== null) {\n        if (isVisible(n, snapshot2) || prevSnapshot !== void 0 && isVisible(n, prevSnapshot)) {\n          switch (n.content.constructor) {\n            case ContentString: {\n              const cur = currentAttributes.get(\"ychange\");\n              if (snapshot2 !== void 0 && !isVisible(n, snapshot2)) {\n                if (cur === void 0 || cur.user !== n.id.client || cur.type !== \"removed\") {\n                  packStr();\n                  currentAttributes.set(\"ychange\", computeYChange ? computeYChange(\"removed\", n.id) : { type: \"removed\" });\n                }\n              } else if (prevSnapshot !== void 0 && !isVisible(n, prevSnapshot)) {\n                if (cur === void 0 || cur.user !== n.id.client || cur.type !== \"added\") {\n                  packStr();\n                  currentAttributes.set(\"ychange\", computeYChange ? computeYChange(\"added\", n.id) : { type: \"added\" });\n                }\n              } else if (cur !== void 0) {\n                packStr();\n                currentAttributes.delete(\"ychange\");\n              }\n              str += /** @type {ContentString} */\n              n.content.str;\n              break;\n            }\n            case ContentType:\n            case ContentEmbed: {\n              packStr();\n              const op = {\n                insert: n.content.getContent()[0]\n              };\n              if (currentAttributes.size > 0) {\n                const attrs = (\n                  /** @type {Object<string,any>} */\n                  {}\n                );\n                op.attributes = attrs;\n                currentAttributes.forEach((value, key) => {\n                  attrs[key] = value;\n                });\n              }\n              ops.push(op);\n              break;\n            }\n            case ContentFormat:\n              if (isVisible(n, snapshot2)) {\n                packStr();\n                updateCurrentAttributes(\n                  currentAttributes,\n                  /** @type {ContentFormat} */\n                  n.content\n                );\n              }\n              break;\n          }\n        }\n        n = n.right;\n      }\n      packStr();\n    };\n    if (snapshot2 || prevSnapshot) {\n      transact(doc2, (transaction) => {\n        if (snapshot2) {\n          splitSnapshotAffectedStructs(transaction, snapshot2);\n        }\n        if (prevSnapshot) {\n          splitSnapshotAffectedStructs(transaction, prevSnapshot);\n        }\n        computeDelta();\n      }, \"cleanup\");\n    } else {\n      computeDelta();\n    }\n    return ops;\n  }\n  /**\n   * Insert text at a given index.\n   *\n   * @param {number} index The index at which to start inserting.\n   * @param {String} text The text to insert at the specified position.\n   * @param {TextAttributes} [attributes] Optionally define some formatting\n   *                                    information to apply on the inserted\n   *                                    Text.\n   * @public\n   */\n  insert(index, text2, attributes) {\n    if (text2.length <= 0) {\n      return;\n    }\n    const y = this.doc;\n    if (y !== null) {\n      transact(y, (transaction) => {\n        const pos = findPosition(transaction, this, index);\n        if (!attributes) {\n          attributes = {};\n          pos.currentAttributes.forEach((v, k) => {\n            attributes[k] = v;\n          });\n        }\n        insertText(transaction, this, pos, text2, attributes);\n      });\n    } else {\n      this._pending.push(() => this.insert(index, text2, attributes));\n    }\n  }\n  /**\n   * Inserts an embed at a index.\n   *\n   * @param {number} index The index to insert the embed at.\n   * @param {Object | AbstractType<any>} embed The Object that represents the embed.\n   * @param {TextAttributes} attributes Attribute information to apply on the\n   *                                    embed\n   *\n   * @public\n   */\n  insertEmbed(index, embed, attributes = {}) {\n    const y = this.doc;\n    if (y !== null) {\n      transact(y, (transaction) => {\n        const pos = findPosition(transaction, this, index);\n        insertText(transaction, this, pos, embed, attributes);\n      });\n    } else {\n      this._pending.push(() => this.insertEmbed(index, embed, attributes));\n    }\n  }\n  /**\n   * Deletes text starting from an index.\n   *\n   * @param {number} index Index at which to start deleting.\n   * @param {number} length The number of characters to remove. Defaults to 1.\n   *\n   * @public\n   */\n  delete(index, length3) {\n    if (length3 === 0) {\n      return;\n    }\n    const y = this.doc;\n    if (y !== null) {\n      transact(y, (transaction) => {\n        deleteText(transaction, findPosition(transaction, this, index), length3);\n      });\n    } else {\n      this._pending.push(() => this.delete(index, length3));\n    }\n  }\n  /**\n   * Assigns properties to a range of text.\n   *\n   * @param {number} index The position where to start formatting.\n   * @param {number} length The amount of characters to assign properties to.\n   * @param {TextAttributes} attributes Attribute information to apply on the\n   *                                    text.\n   *\n   * @public\n   */\n  format(index, length3, attributes) {\n    if (length3 === 0) {\n      return;\n    }\n    const y = this.doc;\n    if (y !== null) {\n      transact(y, (transaction) => {\n        const pos = findPosition(transaction, this, index);\n        if (pos.right === null) {\n          return;\n        }\n        formatText(transaction, this, pos, length3, attributes);\n      });\n    } else {\n      this._pending.push(() => this.format(index, length3, attributes));\n    }\n  }\n  /**\n   * Removes an attribute.\n   *\n   * @note Xml-Text nodes don't have attributes. You can use this feature to assign properties to complete text-blocks.\n   *\n   * @param {String} attributeName The attribute name that is to be removed.\n   *\n   * @public\n   */\n  removeAttribute(attributeName) {\n    if (this.doc !== null) {\n      transact(this.doc, (transaction) => {\n        typeMapDelete(transaction, this, attributeName);\n      });\n    } else {\n      this._pending.push(() => this.removeAttribute(attributeName));\n    }\n  }\n  /**\n   * Sets or updates an attribute.\n   *\n   * @note Xml-Text nodes don't have attributes. You can use this feature to assign properties to complete text-blocks.\n   *\n   * @param {String} attributeName The attribute name that is to be set.\n   * @param {any} attributeValue The attribute value that is to be set.\n   *\n   * @public\n   */\n  setAttribute(attributeName, attributeValue) {\n    if (this.doc !== null) {\n      transact(this.doc, (transaction) => {\n        typeMapSet(transaction, this, attributeName, attributeValue);\n      });\n    } else {\n      this._pending.push(() => this.setAttribute(attributeName, attributeValue));\n    }\n  }\n  /**\n   * Returns an attribute value that belongs to the attribute name.\n   *\n   * @note Xml-Text nodes don't have attributes. You can use this feature to assign properties to complete text-blocks.\n   *\n   * @param {String} attributeName The attribute name that identifies the\n   *                               queried value.\n   * @return {any} The queried attribute value.\n   *\n   * @public\n   */\n  getAttribute(attributeName) {\n    return (\n      /** @type {any} */\n      typeMapGet(this, attributeName)\n    );\n  }\n  /**\n   * Returns all attribute name/value pairs in a JSON Object.\n   *\n   * @note Xml-Text nodes don't have attributes. You can use this feature to assign properties to complete text-blocks.\n   *\n   * @return {Object<string, any>} A JSON Object that describes the attributes.\n   *\n   * @public\n   */\n  getAttributes() {\n    return typeMapGetAll(this);\n  }\n  /**\n   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder\n   */\n  _write(encoder) {\n    encoder.writeTypeRef(YTextRefID);\n  }\n};\nvar readYText = (_decoder) => new YText();\nvar YXmlTreeWalker = class {\n  /**\n   * @param {YXmlFragment | YXmlElement} root\n   * @param {function(AbstractType<any>):boolean} [f]\n   */\n  constructor(root, f = () => true) {\n    this._filter = f;\n    this._root = root;\n    this._currentNode = /** @type {Item} */\n    root._start;\n    this._firstCall = true;\n  }\n  [Symbol.iterator]() {\n    return this;\n  }\n  /**\n   * Get the next node.\n   *\n   * @return {IteratorResult<YXmlElement|YXmlText|YXmlHook>} The next node.\n   *\n   * @public\n   */\n  next() {\n    let n = this._currentNode;\n    let type = n && n.content && /** @type {any} */\n    n.content.type;\n    if (n !== null && (!this._firstCall || n.deleted || !this._filter(type))) {\n      do {\n        type = /** @type {any} */\n        n.content.type;\n        if (!n.deleted && (type.constructor === YXmlElement || type.constructor === YXmlFragment) && type._start !== null) {\n          n = type._start;\n        } else {\n          while (n !== null) {\n            if (n.right !== null) {\n              n = n.right;\n              break;\n            } else if (n.parent === this._root) {\n              n = null;\n            } else {\n              n = /** @type {AbstractType<any>} */\n              n.parent._item;\n            }\n          }\n        }\n      } while (n !== null && (n.deleted || !this._filter(\n        /** @type {ContentType} */\n        n.content.type\n      )));\n    }\n    this._firstCall = false;\n    if (n === null) {\n      return { value: void 0, done: true };\n    }\n    this._currentNode = n;\n    return { value: (\n      /** @type {any} */\n      n.content.type\n    ), done: false };\n  }\n};\nvar YXmlFragment = class _YXmlFragment extends AbstractType {\n  constructor() {\n    super();\n    this._prelimContent = [];\n  }\n  /**\n   * @type {YXmlElement|YXmlText|null}\n   */\n  get firstChild() {\n    const first = this._first;\n    return first ? first.content.getContent()[0] : null;\n  }\n  /**\n   * Integrate this type into the Yjs instance.\n   *\n   * * Save this struct in the os\n   * * This type is sent to other client\n   * * Observer functions are fired\n   *\n   * @param {Doc} y The Yjs instance\n   * @param {Item} item\n   */\n  _integrate(y, item) {\n    super._integrate(y, item);\n    this.insert(\n      0,\n      /** @type {Array<any>} */\n      this._prelimContent\n    );\n    this._prelimContent = null;\n  }\n  _copy() {\n    return new _YXmlFragment();\n  }\n  /**\n   * @return {YXmlFragment}\n   */\n  clone() {\n    const el = new _YXmlFragment();\n    el.insert(0, this.toArray().map((item) => item instanceof AbstractType ? item.clone() : item));\n    return el;\n  }\n  get length() {\n    return this._prelimContent === null ? this._length : this._prelimContent.length;\n  }\n  /**\n   * Create a subtree of childNodes.\n   *\n   * @example\n   * const walker = elem.createTreeWalker(dom => dom.nodeName === 'div')\n   * for (let node in walker) {\n   *   // `node` is a div node\n   *   nop(node)\n   * }\n   *\n   * @param {function(AbstractType<any>):boolean} filter Function that is called on each child element and\n   *                          returns a Boolean indicating whether the child\n   *                          is to be included in the subtree.\n   * @return {YXmlTreeWalker} A subtree and a position within it.\n   *\n   * @public\n   */\n  createTreeWalker(filter) {\n    return new YXmlTreeWalker(this, filter);\n  }\n  /**\n   * Returns the first YXmlElement that matches the query.\n   * Similar to DOM's {@link querySelector}.\n   *\n   * Query support:\n   *   - tagname\n   * TODO:\n   *   - id\n   *   - attribute\n   *\n   * @param {CSS_Selector} query The query on the children.\n   * @return {YXmlElement|YXmlText|YXmlHook|null} The first element that matches the query or null.\n   *\n   * @public\n   */\n  querySelector(query) {\n    query = query.toUpperCase();\n    const iterator = new YXmlTreeWalker(this, (element2) => element2.nodeName && element2.nodeName.toUpperCase() === query);\n    const next = iterator.next();\n    if (next.done) {\n      return null;\n    } else {\n      return next.value;\n    }\n  }\n  /**\n   * Returns all YXmlElements that match the query.\n   * Similar to Dom's {@link querySelectorAll}.\n   *\n   * @todo Does not yet support all queries. Currently only query by tagName.\n   *\n   * @param {CSS_Selector} query The query on the children\n   * @return {Array<YXmlElement|YXmlText|YXmlHook|null>} The elements that match this query.\n   *\n   * @public\n   */\n  querySelectorAll(query) {\n    query = query.toUpperCase();\n    return from2(new YXmlTreeWalker(this, (element2) => element2.nodeName && element2.nodeName.toUpperCase() === query));\n  }\n  /**\n   * Creates YXmlEvent and calls observers.\n   *\n   * @param {Transaction} transaction\n   * @param {Set<null|string>} parentSubs Keys changed on this type. `null` if list was modified.\n   */\n  _callObserver(transaction, parentSubs) {\n    callTypeObservers(this, transaction, new YXmlEvent(this, parentSubs, transaction));\n  }\n  /**\n   * Get the string representation of all the children of this YXmlFragment.\n   *\n   * @return {string} The string representation of all children.\n   */\n  toString() {\n    return typeListMap(this, (xml) => xml.toString()).join(\"\");\n  }\n  /**\n   * @return {string}\n   */\n  toJSON() {\n    return this.toString();\n  }\n  /**\n   * Creates a Dom Element that mirrors this YXmlElement.\n   *\n   * @param {Document} [_document=document] The document object (you must define\n   *                                        this when calling this method in\n   *                                        nodejs)\n   * @param {Object<string, any>} [hooks={}] Optional property to customize how hooks\n   *                                             are presented in the DOM\n   * @param {any} [binding] You should not set this property. This is\n   *                               used if DomBinding wants to create a\n   *                               association to the created DOM type.\n   * @return {Node} The {@link https://developer.mozilla.org/en-US/docs/Web/API/Element|Dom Element}\n   *\n   * @public\n   */\n  toDOM(_document = document, hooks = {}, binding) {\n    const fragment = _document.createDocumentFragment();\n    if (binding !== void 0) {\n      binding._createAssociation(fragment, this);\n    }\n    typeListForEach(this, (xmlType) => {\n      fragment.insertBefore(xmlType.toDOM(_document, hooks, binding), null);\n    });\n    return fragment;\n  }\n  /**\n   * Inserts new content at an index.\n   *\n   * @example\n   *  // Insert character 'a' at position 0\n   *  xml.insert(0, [new Y.XmlText('text')])\n   *\n   * @param {number} index The index to insert content at\n   * @param {Array<YXmlElement|YXmlText>} content The array of content\n   */\n  insert(index, content) {\n    if (this.doc !== null) {\n      transact(this.doc, (transaction) => {\n        typeListInsertGenerics(transaction, this, index, content);\n      });\n    } else {\n      this._prelimContent.splice(index, 0, ...content);\n    }\n  }\n  /**\n   * Inserts new content at an index.\n   *\n   * @example\n   *  // Insert character 'a' at position 0\n   *  xml.insert(0, [new Y.XmlText('text')])\n   *\n   * @param {null|Item|YXmlElement|YXmlText} ref The index to insert content at\n   * @param {Array<YXmlElement|YXmlText>} content The array of content\n   */\n  insertAfter(ref, content) {\n    if (this.doc !== null) {\n      transact(this.doc, (transaction) => {\n        const refItem = ref && ref instanceof AbstractType ? ref._item : ref;\n        typeListInsertGenericsAfter(transaction, this, refItem, content);\n      });\n    } else {\n      const pc = (\n        /** @type {Array<any>} */\n        this._prelimContent\n      );\n      const index = ref === null ? 0 : pc.findIndex((el) => el === ref) + 1;\n      if (index === 0 && ref !== null) {\n        throw create3(\"Reference item not found\");\n      }\n      pc.splice(index, 0, ...content);\n    }\n  }\n  /**\n   * Deletes elements starting from an index.\n   *\n   * @param {number} index Index at which to start deleting elements\n   * @param {number} [length=1] The number of elements to remove. Defaults to 1.\n   */\n  delete(index, length3 = 1) {\n    if (this.doc !== null) {\n      transact(this.doc, (transaction) => {\n        typeListDelete(transaction, this, index, length3);\n      });\n    } else {\n      this._prelimContent.splice(index, length3);\n    }\n  }\n  /**\n   * Transforms this YArray to a JavaScript Array.\n   *\n   * @return {Array<YXmlElement|YXmlText|YXmlHook>}\n   */\n  toArray() {\n    return typeListToArray(this);\n  }\n  /**\n   * Appends content to this YArray.\n   *\n   * @param {Array<YXmlElement|YXmlText>} content Array of content to append.\n   */\n  push(content) {\n    this.insert(this.length, content);\n  }\n  /**\n   * Preppends content to this YArray.\n   *\n   * @param {Array<YXmlElement|YXmlText>} content Array of content to preppend.\n   */\n  unshift(content) {\n    this.insert(0, content);\n  }\n  /**\n   * Returns the i-th element from a YArray.\n   *\n   * @param {number} index The index of the element to return from the YArray\n   * @return {YXmlElement|YXmlText}\n   */\n  get(index) {\n    return typeListGet(this, index);\n  }\n  /**\n   * Transforms this YArray to a JavaScript Array.\n   *\n   * @param {number} [start]\n   * @param {number} [end]\n   * @return {Array<YXmlElement|YXmlText>}\n   */\n  slice(start = 0, end = this.length) {\n    return typeListSlice(this, start, end);\n  }\n  /**\n   * Executes a provided function on once on overy child element.\n   *\n   * @param {function(YXmlElement|YXmlText,number, typeof self):void} f A function to execute on every element of this YArray.\n   */\n  forEach(f) {\n    typeListForEach(this, f);\n  }\n  /**\n   * Transform the properties of this type to binary and write it to an\n   * BinaryEncoder.\n   *\n   * This is called when this Item is sent to a remote peer.\n   *\n   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder The encoder to write data to.\n   */\n  _write(encoder) {\n    encoder.writeTypeRef(YXmlFragmentRefID);\n  }\n};\nvar readYXmlFragment = (_decoder) => new YXmlFragment();\nvar YXmlElement = class _YXmlElement extends YXmlFragment {\n  constructor(nodeName = \"UNDEFINED\") {\n    super();\n    this.nodeName = nodeName;\n    this._prelimAttrs = /* @__PURE__ */ new Map();\n  }\n  /**\n   * @type {YXmlElement|YXmlText|null}\n   */\n  get nextSibling() {\n    const n = this._item ? this._item.next : null;\n    return n ? (\n      /** @type {YXmlElement|YXmlText} */\n      /** @type {ContentType} */\n      n.content.type\n    ) : null;\n  }\n  /**\n   * @type {YXmlElement|YXmlText|null}\n   */\n  get prevSibling() {\n    const n = this._item ? this._item.prev : null;\n    return n ? (\n      /** @type {YXmlElement|YXmlText} */\n      /** @type {ContentType} */\n      n.content.type\n    ) : null;\n  }\n  /**\n   * Integrate this type into the Yjs instance.\n   *\n   * * Save this struct in the os\n   * * This type is sent to other client\n   * * Observer functions are fired\n   *\n   * @param {Doc} y The Yjs instance\n   * @param {Item} item\n   */\n  _integrate(y, item) {\n    super._integrate(y, item);\n    /** @type {Map<string, any>} */\n    this._prelimAttrs.forEach((value, key) => {\n      this.setAttribute(key, value);\n    });\n    this._prelimAttrs = null;\n  }\n  /**\n   * Creates an Item with the same effect as this Item (without position effect)\n   *\n   * @return {YXmlElement}\n   */\n  _copy() {\n    return new _YXmlElement(this.nodeName);\n  }\n  /**\n   * @return {YXmlElement<KV>}\n   */\n  clone() {\n    const el = new _YXmlElement(this.nodeName);\n    const attrs = this.getAttributes();\n    forEach(attrs, (value, key) => {\n      if (typeof value === \"string\") {\n        el.setAttribute(key, value);\n      }\n    });\n    el.insert(0, this.toArray().map((item) => item instanceof AbstractType ? item.clone() : item));\n    return el;\n  }\n  /**\n   * Returns the XML serialization of this YXmlElement.\n   * The attributes are ordered by attribute-name, so you can easily use this\n   * method to compare YXmlElements\n   *\n   * @return {string} The string representation of this type.\n   *\n   * @public\n   */\n  toString() {\n    const attrs = this.getAttributes();\n    const stringBuilder = [];\n    const keys2 = [];\n    for (const key in attrs) {\n      keys2.push(key);\n    }\n    keys2.sort();\n    const keysLen = keys2.length;\n    for (let i = 0; i < keysLen; i++) {\n      const key = keys2[i];\n      stringBuilder.push(key + '=\"' + attrs[key] + '\"');\n    }\n    const nodeName = this.nodeName.toLocaleLowerCase();\n    const attrsString = stringBuilder.length > 0 ? \" \" + stringBuilder.join(\" \") : \"\";\n    return `<${nodeName}${attrsString}>${super.toString()}</${nodeName}>`;\n  }\n  /**\n   * Removes an attribute from this YXmlElement.\n   *\n   * @param {string} attributeName The attribute name that is to be removed.\n   *\n   * @public\n   */\n  removeAttribute(attributeName) {\n    if (this.doc !== null) {\n      transact(this.doc, (transaction) => {\n        typeMapDelete(transaction, this, attributeName);\n      });\n    } else {\n      this._prelimAttrs.delete(attributeName);\n    }\n  }\n  /**\n   * Sets or updates an attribute.\n   *\n   * @template {keyof KV & string} KEY\n   *\n   * @param {KEY} attributeName The attribute name that is to be set.\n   * @param {KV[KEY]} attributeValue The attribute value that is to be set.\n   *\n   * @public\n   */\n  setAttribute(attributeName, attributeValue) {\n    if (this.doc !== null) {\n      transact(this.doc, (transaction) => {\n        typeMapSet(transaction, this, attributeName, attributeValue);\n      });\n    } else {\n      this._prelimAttrs.set(attributeName, attributeValue);\n    }\n  }\n  /**\n   * Returns an attribute value that belongs to the attribute name.\n   *\n   * @template {keyof KV & string} KEY\n   *\n   * @param {KEY} attributeName The attribute name that identifies the\n   *                               queried value.\n   * @return {KV[KEY]|undefined} The queried attribute value.\n   *\n   * @public\n   */\n  getAttribute(attributeName) {\n    return (\n      /** @type {any} */\n      typeMapGet(this, attributeName)\n    );\n  }\n  /**\n   * Returns whether an attribute exists\n   *\n   * @param {string} attributeName The attribute name to check for existence.\n   * @return {boolean} whether the attribute exists.\n   *\n   * @public\n   */\n  hasAttribute(attributeName) {\n    return (\n      /** @type {any} */\n      typeMapHas(this, attributeName)\n    );\n  }\n  /**\n   * Returns all attribute name/value pairs in a JSON Object.\n   *\n   * @return {{ [Key in Extract<keyof KV,string>]?: KV[Key]}} A JSON Object that describes the attributes.\n   *\n   * @public\n   */\n  getAttributes() {\n    return (\n      /** @type {any} */\n      typeMapGetAll(this)\n    );\n  }\n  /**\n   * Creates a Dom Element that mirrors this YXmlElement.\n   *\n   * @param {Document} [_document=document] The document object (you must define\n   *                                        this when calling this method in\n   *                                        nodejs)\n   * @param {Object<string, any>} [hooks={}] Optional property to customize how hooks\n   *                                             are presented in the DOM\n   * @param {any} [binding] You should not set this property. This is\n   *                               used if DomBinding wants to create a\n   *                               association to the created DOM type.\n   * @return {Node} The {@link https://developer.mozilla.org/en-US/docs/Web/API/Element|Dom Element}\n   *\n   * @public\n   */\n  toDOM(_document = document, hooks = {}, binding) {\n    const dom = _document.createElement(this.nodeName);\n    const attrs = this.getAttributes();\n    for (const key in attrs) {\n      const value = attrs[key];\n      if (typeof value === \"string\") {\n        dom.setAttribute(key, value);\n      }\n    }\n    typeListForEach(this, (yxml) => {\n      dom.appendChild(yxml.toDOM(_document, hooks, binding));\n    });\n    if (binding !== void 0) {\n      binding._createAssociation(dom, this);\n    }\n    return dom;\n  }\n  /**\n   * Transform the properties of this type to binary and write it to an\n   * BinaryEncoder.\n   *\n   * This is called when this Item is sent to a remote peer.\n   *\n   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder The encoder to write data to.\n   */\n  _write(encoder) {\n    encoder.writeTypeRef(YXmlElementRefID);\n    encoder.writeKey(this.nodeName);\n  }\n};\nvar readYXmlElement = (decoder) => new YXmlElement(decoder.readKey());\nvar YXmlEvent = class extends YEvent {\n  /**\n   * @param {YXmlElement|YXmlText|YXmlFragment} target The target on which the event is created.\n   * @param {Set<string|null>} subs The set of changed attributes. `null` is included if the\n   *                   child list changed.\n   * @param {Transaction} transaction The transaction instance with wich the\n   *                                  change was created.\n   */\n  constructor(target, subs, transaction) {\n    super(target, transaction);\n    this.childListChanged = false;\n    this.attributesChanged = /* @__PURE__ */ new Set();\n    subs.forEach((sub) => {\n      if (sub === null) {\n        this.childListChanged = true;\n      } else {\n        this.attributesChanged.add(sub);\n      }\n    });\n  }\n};\nvar YXmlHook = class _YXmlHook extends YMap {\n  /**\n   * @param {string} hookName nodeName of the Dom Node.\n   */\n  constructor(hookName) {\n    super();\n    this.hookName = hookName;\n  }\n  /**\n   * Creates an Item with the same effect as this Item (without position effect)\n   */\n  _copy() {\n    return new _YXmlHook(this.hookName);\n  }\n  /**\n   * @return {YXmlHook}\n   */\n  clone() {\n    const el = new _YXmlHook(this.hookName);\n    this.forEach((value, key) => {\n      el.set(key, value);\n    });\n    return el;\n  }\n  /**\n   * Creates a Dom Element that mirrors this YXmlElement.\n   *\n   * @param {Document} [_document=document] The document object (you must define\n   *                                        this when calling this method in\n   *                                        nodejs)\n   * @param {Object.<string, any>} [hooks] Optional property to customize how hooks\n   *                                             are presented in the DOM\n   * @param {any} [binding] You should not set this property. This is\n   *                               used if DomBinding wants to create a\n   *                               association to the created DOM type\n   * @return {Element} The {@link https://developer.mozilla.org/en-US/docs/Web/API/Element|Dom Element}\n   *\n   * @public\n   */\n  toDOM(_document = document, hooks = {}, binding) {\n    const hook = hooks[this.hookName];\n    let dom;\n    if (hook !== void 0) {\n      dom = hook.createDom(this);\n    } else {\n      dom = document.createElement(this.hookName);\n    }\n    dom.setAttribute(\"data-yjs-hook\", this.hookName);\n    if (binding !== void 0) {\n      binding._createAssociation(dom, this);\n    }\n    return dom;\n  }\n  /**\n   * Transform the properties of this type to binary and write it to an\n   * BinaryEncoder.\n   *\n   * This is called when this Item is sent to a remote peer.\n   *\n   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder The encoder to write data to.\n   */\n  _write(encoder) {\n    encoder.writeTypeRef(YXmlHookRefID);\n    encoder.writeKey(this.hookName);\n  }\n};\nvar readYXmlHook = (decoder) => new YXmlHook(decoder.readKey());\nvar YXmlText = class _YXmlText extends YText {\n  /**\n   * @type {YXmlElement|YXmlText|null}\n   */\n  get nextSibling() {\n    const n = this._item ? this._item.next : null;\n    return n ? (\n      /** @type {YXmlElement|YXmlText} */\n      /** @type {ContentType} */\n      n.content.type\n    ) : null;\n  }\n  /**\n   * @type {YXmlElement|YXmlText|null}\n   */\n  get prevSibling() {\n    const n = this._item ? this._item.prev : null;\n    return n ? (\n      /** @type {YXmlElement|YXmlText} */\n      /** @type {ContentType} */\n      n.content.type\n    ) : null;\n  }\n  _copy() {\n    return new _YXmlText();\n  }\n  /**\n   * @return {YXmlText}\n   */\n  clone() {\n    const text2 = new _YXmlText();\n    text2.applyDelta(this.toDelta());\n    return text2;\n  }\n  /**\n   * Creates a Dom Element that mirrors this YXmlText.\n   *\n   * @param {Document} [_document=document] The document object (you must define\n   *                                        this when calling this method in\n   *                                        nodejs)\n   * @param {Object<string, any>} [hooks] Optional property to customize how hooks\n   *                                             are presented in the DOM\n   * @param {any} [binding] You should not set this property. This is\n   *                               used if DomBinding wants to create a\n   *                               association to the created DOM type.\n   * @return {Text} The {@link https://developer.mozilla.org/en-US/docs/Web/API/Element|Dom Element}\n   *\n   * @public\n   */\n  toDOM(_document = document, hooks, binding) {\n    const dom = _document.createTextNode(this.toString());\n    if (binding !== void 0) {\n      binding._createAssociation(dom, this);\n    }\n    return dom;\n  }\n  toString() {\n    return this.toDelta().map((delta) => {\n      const nestedNodes = [];\n      for (const nodeName in delta.attributes) {\n        const attrs = [];\n        for (const key in delta.attributes[nodeName]) {\n          attrs.push({ key, value: delta.attributes[nodeName][key] });\n        }\n        attrs.sort((a, b) => a.key < b.key ? -1 : 1);\n        nestedNodes.push({ nodeName, attrs });\n      }\n      nestedNodes.sort((a, b) => a.nodeName < b.nodeName ? -1 : 1);\n      let str = \"\";\n      for (let i = 0; i < nestedNodes.length; i++) {\n        const node = nestedNodes[i];\n        str += `<${node.nodeName}`;\n        for (let j = 0; j < node.attrs.length; j++) {\n          const attr = node.attrs[j];\n          str += ` ${attr.key}=\"${attr.value}\"`;\n        }\n        str += \">\";\n      }\n      str += delta.insert;\n      for (let i = nestedNodes.length - 1; i >= 0; i--) {\n        str += `</${nestedNodes[i].nodeName}>`;\n      }\n      return str;\n    }).join(\"\");\n  }\n  /**\n   * @return {string}\n   */\n  toJSON() {\n    return this.toString();\n  }\n  /**\n   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder\n   */\n  _write(encoder) {\n    encoder.writeTypeRef(YXmlTextRefID);\n  }\n};\nvar readYXmlText = (decoder) => new YXmlText();\nvar AbstractStruct = class {\n  /**\n   * @param {ID} id\n   * @param {number} length\n   */\n  constructor(id2, length3) {\n    this.id = id2;\n    this.length = length3;\n  }\n  /**\n   * @type {boolean}\n   */\n  get deleted() {\n    throw methodUnimplemented();\n  }\n  /**\n   * Merge this struct with the item to the right.\n   * This method is already assuming that `this.id.clock + this.length === this.id.clock`.\n   * Also this method does *not* remove right from StructStore!\n   * @param {AbstractStruct} right\n   * @return {boolean} wether this merged with right\n   */\n  mergeWith(right) {\n    return false;\n  }\n  /**\n   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder The encoder to write data to.\n   * @param {number} offset\n   * @param {number} encodingRef\n   */\n  write(encoder, offset, encodingRef) {\n    throw methodUnimplemented();\n  }\n  /**\n   * @param {Transaction} transaction\n   * @param {number} offset\n   */\n  integrate(transaction, offset) {\n    throw methodUnimplemented();\n  }\n};\nvar structGCRefNumber = 0;\nvar GC = class extends AbstractStruct {\n  get deleted() {\n    return true;\n  }\n  delete() {\n  }\n  /**\n   * @param {GC} right\n   * @return {boolean}\n   */\n  mergeWith(right) {\n    if (this.constructor !== right.constructor) {\n      return false;\n    }\n    this.length += right.length;\n    return true;\n  }\n  /**\n   * @param {Transaction} transaction\n   * @param {number} offset\n   */\n  integrate(transaction, offset) {\n    if (offset > 0) {\n      this.id.clock += offset;\n      this.length -= offset;\n    }\n    addStruct(transaction.doc.store, this);\n  }\n  /**\n   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder\n   * @param {number} offset\n   */\n  write(encoder, offset) {\n    encoder.writeInfo(structGCRefNumber);\n    encoder.writeLen(this.length - offset);\n  }\n  /**\n   * @param {Transaction} transaction\n   * @param {StructStore} store\n   * @return {null | number}\n   */\n  getMissing(transaction, store) {\n    return null;\n  }\n};\nvar ContentBinary = class _ContentBinary {\n  /**\n   * @param {Uint8Array} content\n   */\n  constructor(content) {\n    this.content = content;\n  }\n  /**\n   * @return {number}\n   */\n  getLength() {\n    return 1;\n  }\n  /**\n   * @return {Array<any>}\n   */\n  getContent() {\n    return [this.content];\n  }\n  /**\n   * @return {boolean}\n   */\n  isCountable() {\n    return true;\n  }\n  /**\n   * @return {ContentBinary}\n   */\n  copy() {\n    return new _ContentBinary(this.content);\n  }\n  /**\n   * @param {number} offset\n   * @return {ContentBinary}\n   */\n  splice(offset) {\n    throw methodUnimplemented();\n  }\n  /**\n   * @param {ContentBinary} right\n   * @return {boolean}\n   */\n  mergeWith(right) {\n    return false;\n  }\n  /**\n   * @param {Transaction} transaction\n   * @param {Item} item\n   */\n  integrate(transaction, item) {\n  }\n  /**\n   * @param {Transaction} transaction\n   */\n  delete(transaction) {\n  }\n  /**\n   * @param {StructStore} store\n   */\n  gc(store) {\n  }\n  /**\n   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder\n   * @param {number} offset\n   */\n  write(encoder, offset) {\n    encoder.writeBuf(this.content);\n  }\n  /**\n   * @return {number}\n   */\n  getRef() {\n    return 3;\n  }\n};\nvar readContentBinary = (decoder) => new ContentBinary(decoder.readBuf());\nvar ContentDeleted = class _ContentDeleted {\n  /**\n   * @param {number} len\n   */\n  constructor(len) {\n    this.len = len;\n  }\n  /**\n   * @return {number}\n   */\n  getLength() {\n    return this.len;\n  }\n  /**\n   * @return {Array<any>}\n   */\n  getContent() {\n    return [];\n  }\n  /**\n   * @return {boolean}\n   */\n  isCountable() {\n    return false;\n  }\n  /**\n   * @return {ContentDeleted}\n   */\n  copy() {\n    return new _ContentDeleted(this.len);\n  }\n  /**\n   * @param {number} offset\n   * @return {ContentDeleted}\n   */\n  splice(offset) {\n    const right = new _ContentDeleted(this.len - offset);\n    this.len = offset;\n    return right;\n  }\n  /**\n   * @param {ContentDeleted} right\n   * @return {boolean}\n   */\n  mergeWith(right) {\n    this.len += right.len;\n    return true;\n  }\n  /**\n   * @param {Transaction} transaction\n   * @param {Item} item\n   */\n  integrate(transaction, item) {\n    addToDeleteSet(transaction.deleteSet, item.id.client, item.id.clock, this.len);\n    item.markDeleted();\n  }\n  /**\n   * @param {Transaction} transaction\n   */\n  delete(transaction) {\n  }\n  /**\n   * @param {StructStore} store\n   */\n  gc(store) {\n  }\n  /**\n   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder\n   * @param {number} offset\n   */\n  write(encoder, offset) {\n    encoder.writeLen(this.len - offset);\n  }\n  /**\n   * @return {number}\n   */\n  getRef() {\n    return 1;\n  }\n};\nvar readContentDeleted = (decoder) => new ContentDeleted(decoder.readLen());\nvar createDocFromOpts = (guid, opts) => new Doc({ guid, ...opts, shouldLoad: opts.shouldLoad || opts.autoLoad || false });\nvar ContentDoc = class _ContentDoc {\n  /**\n   * @param {Doc} doc\n   */\n  constructor(doc2) {\n    if (doc2._item) {\n      console.error(\"This document was already integrated as a sub-document. You should create a second instance instead with the same guid.\");\n    }\n    this.doc = doc2;\n    const opts = {};\n    this.opts = opts;\n    if (!doc2.gc) {\n      opts.gc = false;\n    }\n    if (doc2.autoLoad) {\n      opts.autoLoad = true;\n    }\n    if (doc2.meta !== null) {\n      opts.meta = doc2.meta;\n    }\n  }\n  /**\n   * @return {number}\n   */\n  getLength() {\n    return 1;\n  }\n  /**\n   * @return {Array<any>}\n   */\n  getContent() {\n    return [this.doc];\n  }\n  /**\n   * @return {boolean}\n   */\n  isCountable() {\n    return true;\n  }\n  /**\n   * @return {ContentDoc}\n   */\n  copy() {\n    return new _ContentDoc(createDocFromOpts(this.doc.guid, this.opts));\n  }\n  /**\n   * @param {number} offset\n   * @return {ContentDoc}\n   */\n  splice(offset) {\n    throw methodUnimplemented();\n  }\n  /**\n   * @param {ContentDoc} right\n   * @return {boolean}\n   */\n  mergeWith(right) {\n    return false;\n  }\n  /**\n   * @param {Transaction} transaction\n   * @param {Item} item\n   */\n  integrate(transaction, item) {\n    this.doc._item = item;\n    transaction.subdocsAdded.add(this.doc);\n    if (this.doc.shouldLoad) {\n      transaction.subdocsLoaded.add(this.doc);\n    }\n  }\n  /**\n   * @param {Transaction} transaction\n   */\n  delete(transaction) {\n    if (transaction.subdocsAdded.has(this.doc)) {\n      transaction.subdocsAdded.delete(this.doc);\n    } else {\n      transaction.subdocsRemoved.add(this.doc);\n    }\n  }\n  /**\n   * @param {StructStore} store\n   */\n  gc(store) {\n  }\n  /**\n   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder\n   * @param {number} offset\n   */\n  write(encoder, offset) {\n    encoder.writeString(this.doc.guid);\n    encoder.writeAny(this.opts);\n  }\n  /**\n   * @return {number}\n   */\n  getRef() {\n    return 9;\n  }\n};\nvar readContentDoc = (decoder) => new ContentDoc(createDocFromOpts(decoder.readString(), decoder.readAny()));\nvar ContentEmbed = class _ContentEmbed {\n  /**\n   * @param {Object} embed\n   */\n  constructor(embed) {\n    this.embed = embed;\n  }\n  /**\n   * @return {number}\n   */\n  getLength() {\n    return 1;\n  }\n  /**\n   * @return {Array<any>}\n   */\n  getContent() {\n    return [this.embed];\n  }\n  /**\n   * @return {boolean}\n   */\n  isCountable() {\n    return true;\n  }\n  /**\n   * @return {ContentEmbed}\n   */\n  copy() {\n    return new _ContentEmbed(this.embed);\n  }\n  /**\n   * @param {number} offset\n   * @return {ContentEmbed}\n   */\n  splice(offset) {\n    throw methodUnimplemented();\n  }\n  /**\n   * @param {ContentEmbed} right\n   * @return {boolean}\n   */\n  mergeWith(right) {\n    return false;\n  }\n  /**\n   * @param {Transaction} transaction\n   * @param {Item} item\n   */\n  integrate(transaction, item) {\n  }\n  /**\n   * @param {Transaction} transaction\n   */\n  delete(transaction) {\n  }\n  /**\n   * @param {StructStore} store\n   */\n  gc(store) {\n  }\n  /**\n   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder\n   * @param {number} offset\n   */\n  write(encoder, offset) {\n    encoder.writeJSON(this.embed);\n  }\n  /**\n   * @return {number}\n   */\n  getRef() {\n    return 5;\n  }\n};\nvar readContentEmbed = (decoder) => new ContentEmbed(decoder.readJSON());\nvar ContentFormat = class _ContentFormat {\n  /**\n   * @param {string} key\n   * @param {Object} value\n   */\n  constructor(key, value) {\n    this.key = key;\n    this.value = value;\n  }\n  /**\n   * @return {number}\n   */\n  getLength() {\n    return 1;\n  }\n  /**\n   * @return {Array<any>}\n   */\n  getContent() {\n    return [];\n  }\n  /**\n   * @return {boolean}\n   */\n  isCountable() {\n    return false;\n  }\n  /**\n   * @return {ContentFormat}\n   */\n  copy() {\n    return new _ContentFormat(this.key, this.value);\n  }\n  /**\n   * @param {number} _offset\n   * @return {ContentFormat}\n   */\n  splice(_offset) {\n    throw methodUnimplemented();\n  }\n  /**\n   * @param {ContentFormat} _right\n   * @return {boolean}\n   */\n  mergeWith(_right) {\n    return false;\n  }\n  /**\n   * @param {Transaction} _transaction\n   * @param {Item} item\n   */\n  integrate(_transaction, item) {\n    const p = (\n      /** @type {YText} */\n      item.parent\n    );\n    p._searchMarker = null;\n    p._hasFormatting = true;\n  }\n  /**\n   * @param {Transaction} transaction\n   */\n  delete(transaction) {\n  }\n  /**\n   * @param {StructStore} store\n   */\n  gc(store) {\n  }\n  /**\n   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder\n   * @param {number} offset\n   */\n  write(encoder, offset) {\n    encoder.writeKey(this.key);\n    encoder.writeJSON(this.value);\n  }\n  /**\n   * @return {number}\n   */\n  getRef() {\n    return 6;\n  }\n};\nvar readContentFormat = (decoder) => new ContentFormat(decoder.readKey(), decoder.readJSON());\nvar ContentJSON = class _ContentJSON {\n  /**\n   * @param {Array<any>} arr\n   */\n  constructor(arr) {\n    this.arr = arr;\n  }\n  /**\n   * @return {number}\n   */\n  getLength() {\n    return this.arr.length;\n  }\n  /**\n   * @return {Array<any>}\n   */\n  getContent() {\n    return this.arr;\n  }\n  /**\n   * @return {boolean}\n   */\n  isCountable() {\n    return true;\n  }\n  /**\n   * @return {ContentJSON}\n   */\n  copy() {\n    return new _ContentJSON(this.arr);\n  }\n  /**\n   * @param {number} offset\n   * @return {ContentJSON}\n   */\n  splice(offset) {\n    const right = new _ContentJSON(this.arr.slice(offset));\n    this.arr = this.arr.slice(0, offset);\n    return right;\n  }\n  /**\n   * @param {ContentJSON} right\n   * @return {boolean}\n   */\n  mergeWith(right) {\n    this.arr = this.arr.concat(right.arr);\n    return true;\n  }\n  /**\n   * @param {Transaction} transaction\n   * @param {Item} item\n   */\n  integrate(transaction, item) {\n  }\n  /**\n   * @param {Transaction} transaction\n   */\n  delete(transaction) {\n  }\n  /**\n   * @param {StructStore} store\n   */\n  gc(store) {\n  }\n  /**\n   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder\n   * @param {number} offset\n   */\n  write(encoder, offset) {\n    const len = this.arr.length;\n    encoder.writeLen(len - offset);\n    for (let i = offset; i < len; i++) {\n      const c = this.arr[i];\n      encoder.writeString(c === void 0 ? \"undefined\" : JSON.stringify(c));\n    }\n  }\n  /**\n   * @return {number}\n   */\n  getRef() {\n    return 2;\n  }\n};\nvar readContentJSON = (decoder) => {\n  const len = decoder.readLen();\n  const cs = [];\n  for (let i = 0; i < len; i++) {\n    const c = decoder.readString();\n    if (c === \"undefined\") {\n      cs.push(void 0);\n    } else {\n      cs.push(JSON.parse(c));\n    }\n  }\n  return new ContentJSON(cs);\n};\nvar ContentAny = class _ContentAny {\n  /**\n   * @param {Array<any>} arr\n   */\n  constructor(arr) {\n    this.arr = arr;\n  }\n  /**\n   * @return {number}\n   */\n  getLength() {\n    return this.arr.length;\n  }\n  /**\n   * @return {Array<any>}\n   */\n  getContent() {\n    return this.arr;\n  }\n  /**\n   * @return {boolean}\n   */\n  isCountable() {\n    return true;\n  }\n  /**\n   * @return {ContentAny}\n   */\n  copy() {\n    return new _ContentAny(this.arr);\n  }\n  /**\n   * @param {number} offset\n   * @return {ContentAny}\n   */\n  splice(offset) {\n    const right = new _ContentAny(this.arr.slice(offset));\n    this.arr = this.arr.slice(0, offset);\n    return right;\n  }\n  /**\n   * @param {ContentAny} right\n   * @return {boolean}\n   */\n  mergeWith(right) {\n    this.arr = this.arr.concat(right.arr);\n    return true;\n  }\n  /**\n   * @param {Transaction} transaction\n   * @param {Item} item\n   */\n  integrate(transaction, item) {\n  }\n  /**\n   * @param {Transaction} transaction\n   */\n  delete(transaction) {\n  }\n  /**\n   * @param {StructStore} store\n   */\n  gc(store) {\n  }\n  /**\n   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder\n   * @param {number} offset\n   */\n  write(encoder, offset) {\n    const len = this.arr.length;\n    encoder.writeLen(len - offset);\n    for (let i = offset; i < len; i++) {\n      const c = this.arr[i];\n      encoder.writeAny(c);\n    }\n  }\n  /**\n   * @return {number}\n   */\n  getRef() {\n    return 8;\n  }\n};\nvar readContentAny = (decoder) => {\n  const len = decoder.readLen();\n  const cs = [];\n  for (let i = 0; i < len; i++) {\n    cs.push(decoder.readAny());\n  }\n  return new ContentAny(cs);\n};\nvar ContentString = class _ContentString {\n  /**\n   * @param {string} str\n   */\n  constructor(str) {\n    this.str = str;\n  }\n  /**\n   * @return {number}\n   */\n  getLength() {\n    return this.str.length;\n  }\n  /**\n   * @return {Array<any>}\n   */\n  getContent() {\n    return this.str.split(\"\");\n  }\n  /**\n   * @return {boolean}\n   */\n  isCountable() {\n    return true;\n  }\n  /**\n   * @return {ContentString}\n   */\n  copy() {\n    return new _ContentString(this.str);\n  }\n  /**\n   * @param {number} offset\n   * @return {ContentString}\n   */\n  splice(offset) {\n    const right = new _ContentString(this.str.slice(offset));\n    this.str = this.str.slice(0, offset);\n    const firstCharCode = this.str.charCodeAt(offset - 1);\n    if (firstCharCode >= 55296 && firstCharCode <= 56319) {\n      this.str = this.str.slice(0, offset - 1) + \"\";\n      right.str = \"\" + right.str.slice(1);\n    }\n    return right;\n  }\n  /**\n   * @param {ContentString} right\n   * @return {boolean}\n   */\n  mergeWith(right) {\n    this.str += right.str;\n    return true;\n  }\n  /**\n   * @param {Transaction} transaction\n   * @param {Item} item\n   */\n  integrate(transaction, item) {\n  }\n  /**\n   * @param {Transaction} transaction\n   */\n  delete(transaction) {\n  }\n  /**\n   * @param {StructStore} store\n   */\n  gc(store) {\n  }\n  /**\n   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder\n   * @param {number} offset\n   */\n  write(encoder, offset) {\n    encoder.writeString(offset === 0 ? this.str : this.str.slice(offset));\n  }\n  /**\n   * @return {number}\n   */\n  getRef() {\n    return 4;\n  }\n};\nvar readContentString = (decoder) => new ContentString(decoder.readString());\nvar typeRefs = [\n  readYArray,\n  readYMap,\n  readYText,\n  readYXmlElement,\n  readYXmlFragment,\n  readYXmlHook,\n  readYXmlText\n];\nvar YArrayRefID = 0;\nvar YMapRefID = 1;\nvar YTextRefID = 2;\nvar YXmlElementRefID = 3;\nvar YXmlFragmentRefID = 4;\nvar YXmlHookRefID = 5;\nvar YXmlTextRefID = 6;\nvar ContentType = class _ContentType {\n  /**\n   * @param {AbstractType<any>} type\n   */\n  constructor(type) {\n    this.type = type;\n  }\n  /**\n   * @return {number}\n   */\n  getLength() {\n    return 1;\n  }\n  /**\n   * @return {Array<any>}\n   */\n  getContent() {\n    return [this.type];\n  }\n  /**\n   * @return {boolean}\n   */\n  isCountable() {\n    return true;\n  }\n  /**\n   * @return {ContentType}\n   */\n  copy() {\n    return new _ContentType(this.type._copy());\n  }\n  /**\n   * @param {number} offset\n   * @return {ContentType}\n   */\n  splice(offset) {\n    throw methodUnimplemented();\n  }\n  /**\n   * @param {ContentType} right\n   * @return {boolean}\n   */\n  mergeWith(right) {\n    return false;\n  }\n  /**\n   * @param {Transaction} transaction\n   * @param {Item} item\n   */\n  integrate(transaction, item) {\n    this.type._integrate(transaction.doc, item);\n  }\n  /**\n   * @param {Transaction} transaction\n   */\n  delete(transaction) {\n    let item = this.type._start;\n    while (item !== null) {\n      if (!item.deleted) {\n        item.delete(transaction);\n      } else if (item.id.clock < (transaction.beforeState.get(item.id.client) || 0)) {\n        transaction._mergeStructs.push(item);\n      }\n      item = item.right;\n    }\n    this.type._map.forEach((item2) => {\n      if (!item2.deleted) {\n        item2.delete(transaction);\n      } else if (item2.id.clock < (transaction.beforeState.get(item2.id.client) || 0)) {\n        transaction._mergeStructs.push(item2);\n      }\n    });\n    transaction.changed.delete(this.type);\n  }\n  /**\n   * @param {StructStore} store\n   */\n  gc(store) {\n    let item = this.type._start;\n    while (item !== null) {\n      item.gc(store, true);\n      item = item.right;\n    }\n    this.type._start = null;\n    this.type._map.forEach(\n      /** @param {Item | null} item */\n      (item2) => {\n        while (item2 !== null) {\n          item2.gc(store, true);\n          item2 = item2.left;\n        }\n      }\n    );\n    this.type._map = /* @__PURE__ */ new Map();\n  }\n  /**\n   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder\n   * @param {number} offset\n   */\n  write(encoder, offset) {\n    this.type._write(encoder);\n  }\n  /**\n   * @return {number}\n   */\n  getRef() {\n    return 7;\n  }\n};\nvar readContentType = (decoder) => new ContentType(typeRefs[decoder.readTypeRef()](decoder));\nvar followRedone = (store, id2) => {\n  let nextID = id2;\n  let diff = 0;\n  let item;\n  do {\n    if (diff > 0) {\n      nextID = createID(nextID.client, nextID.clock + diff);\n    }\n    item = getItem(store, nextID);\n    diff = nextID.clock - item.id.clock;\n    nextID = item.redone;\n  } while (nextID !== null && item instanceof Item);\n  return {\n    item,\n    diff\n  };\n};\nvar keepItem = (item, keep) => {\n  while (item !== null && item.keep !== keep) {\n    item.keep = keep;\n    item = /** @type {AbstractType<any>} */\n    item.parent._item;\n  }\n};\nvar splitItem = (transaction, leftItem, diff) => {\n  const { client, clock } = leftItem.id;\n  const rightItem = new Item(\n    createID(client, clock + diff),\n    leftItem,\n    createID(client, clock + diff - 1),\n    leftItem.right,\n    leftItem.rightOrigin,\n    leftItem.parent,\n    leftItem.parentSub,\n    leftItem.content.splice(diff)\n  );\n  if (leftItem.deleted) {\n    rightItem.markDeleted();\n  }\n  if (leftItem.keep) {\n    rightItem.keep = true;\n  }\n  if (leftItem.redone !== null) {\n    rightItem.redone = createID(leftItem.redone.client, leftItem.redone.clock + diff);\n  }\n  leftItem.right = rightItem;\n  if (rightItem.right !== null) {\n    rightItem.right.left = rightItem;\n  }\n  transaction._mergeStructs.push(rightItem);\n  if (rightItem.parentSub !== null && rightItem.right === null) {\n    rightItem.parent._map.set(rightItem.parentSub, rightItem);\n  }\n  leftItem.length = diff;\n  return rightItem;\n};\nvar isDeletedByUndoStack = (stack, id2) => some(\n  stack,\n  /** @param {StackItem} s */\n  (s) => isDeleted(s.deletions, id2)\n);\nvar redoItem = (transaction, item, redoitems, itemsToDelete, ignoreRemoteMapChanges, um) => {\n  const doc2 = transaction.doc;\n  const store = doc2.store;\n  const ownClientID = doc2.clientID;\n  const redone = item.redone;\n  if (redone !== null) {\n    return getItemCleanStart(transaction, redone);\n  }\n  let parentItem = (\n    /** @type {AbstractType<any>} */\n    item.parent._item\n  );\n  let left = null;\n  let right;\n  if (parentItem !== null && parentItem.deleted === true) {\n    if (parentItem.redone === null && (!redoitems.has(parentItem) || redoItem(transaction, parentItem, redoitems, itemsToDelete, ignoreRemoteMapChanges, um) === null)) {\n      return null;\n    }\n    while (parentItem.redone !== null) {\n      parentItem = getItemCleanStart(transaction, parentItem.redone);\n    }\n  }\n  const parentType = parentItem === null ? (\n    /** @type {AbstractType<any>} */\n    item.parent\n  ) : (\n    /** @type {ContentType} */\n    parentItem.content.type\n  );\n  if (item.parentSub === null) {\n    left = item.left;\n    right = item;\n    while (left !== null) {\n      let leftTrace = left;\n      while (leftTrace !== null && /** @type {AbstractType<any>} */\n      leftTrace.parent._item !== parentItem) {\n        leftTrace = leftTrace.redone === null ? null : getItemCleanStart(transaction, leftTrace.redone);\n      }\n      if (leftTrace !== null && /** @type {AbstractType<any>} */\n      leftTrace.parent._item === parentItem) {\n        left = leftTrace;\n        break;\n      }\n      left = left.left;\n    }\n    while (right !== null) {\n      let rightTrace = right;\n      while (rightTrace !== null && /** @type {AbstractType<any>} */\n      rightTrace.parent._item !== parentItem) {\n        rightTrace = rightTrace.redone === null ? null : getItemCleanStart(transaction, rightTrace.redone);\n      }\n      if (rightTrace !== null && /** @type {AbstractType<any>} */\n      rightTrace.parent._item === parentItem) {\n        right = rightTrace;\n        break;\n      }\n      right = right.right;\n    }\n  } else {\n    right = null;\n    if (item.right && !ignoreRemoteMapChanges) {\n      left = item;\n      while (left !== null && left.right !== null && (left.right.redone || isDeleted(itemsToDelete, left.right.id) || isDeletedByUndoStack(um.undoStack, left.right.id) || isDeletedByUndoStack(um.redoStack, left.right.id))) {\n        left = left.right;\n        while (left.redone)\n          left = getItemCleanStart(transaction, left.redone);\n      }\n      if (left && left.right !== null) {\n        return null;\n      }\n    } else {\n      left = parentType._map.get(item.parentSub) || null;\n    }\n  }\n  const nextClock = getState(store, ownClientID);\n  const nextId = createID(ownClientID, nextClock);\n  const redoneItem = new Item(\n    nextId,\n    left,\n    left && left.lastId,\n    right,\n    right && right.id,\n    parentType,\n    item.parentSub,\n    item.content.copy()\n  );\n  item.redone = nextId;\n  keepItem(redoneItem, true);\n  redoneItem.integrate(transaction, 0);\n  return redoneItem;\n};\nvar Item = class _Item extends AbstractStruct {\n  /**\n   * @param {ID} id\n   * @param {Item | null} left\n   * @param {ID | null} origin\n   * @param {Item | null} right\n   * @param {ID | null} rightOrigin\n   * @param {AbstractType<any>|ID|null} parent Is a type if integrated, is null if it is possible to copy parent from left or right, is ID before integration to search for it.\n   * @param {string | null} parentSub\n   * @param {AbstractContent} content\n   */\n  constructor(id2, left, origin, right, rightOrigin, parent, parentSub, content) {\n    super(id2, content.getLength());\n    this.origin = origin;\n    this.left = left;\n    this.right = right;\n    this.rightOrigin = rightOrigin;\n    this.parent = parent;\n    this.parentSub = parentSub;\n    this.redone = null;\n    this.content = content;\n    this.info = this.content.isCountable() ? BIT2 : 0;\n  }\n  /**\n   * This is used to mark the item as an indexed fast-search marker\n   *\n   * @type {boolean}\n   */\n  set marker(isMarked) {\n    if ((this.info & BIT4) > 0 !== isMarked) {\n      this.info ^= BIT4;\n    }\n  }\n  get marker() {\n    return (this.info & BIT4) > 0;\n  }\n  /**\n   * If true, do not garbage collect this Item.\n   */\n  get keep() {\n    return (this.info & BIT1) > 0;\n  }\n  set keep(doKeep) {\n    if (this.keep !== doKeep) {\n      this.info ^= BIT1;\n    }\n  }\n  get countable() {\n    return (this.info & BIT2) > 0;\n  }\n  /**\n   * Whether this item was deleted or not.\n   * @type {Boolean}\n   */\n  get deleted() {\n    return (this.info & BIT3) > 0;\n  }\n  set deleted(doDelete) {\n    if (this.deleted !== doDelete) {\n      this.info ^= BIT3;\n    }\n  }\n  markDeleted() {\n    this.info |= BIT3;\n  }\n  /**\n   * Return the creator clientID of the missing op or define missing items and return null.\n   *\n   * @param {Transaction} transaction\n   * @param {StructStore} store\n   * @return {null | number}\n   */\n  getMissing(transaction, store) {\n    if (this.origin && this.origin.client !== this.id.client && this.origin.clock >= getState(store, this.origin.client)) {\n      return this.origin.client;\n    }\n    if (this.rightOrigin && this.rightOrigin.client !== this.id.client && this.rightOrigin.clock >= getState(store, this.rightOrigin.client)) {\n      return this.rightOrigin.client;\n    }\n    if (this.parent && this.parent.constructor === ID && this.id.client !== this.parent.client && this.parent.clock >= getState(store, this.parent.client)) {\n      return this.parent.client;\n    }\n    if (this.origin) {\n      this.left = getItemCleanEnd(transaction, store, this.origin);\n      this.origin = this.left.lastId;\n    }\n    if (this.rightOrigin) {\n      this.right = getItemCleanStart(transaction, this.rightOrigin);\n      this.rightOrigin = this.right.id;\n    }\n    if (this.left && this.left.constructor === GC || this.right && this.right.constructor === GC) {\n      this.parent = null;\n    }\n    if (!this.parent) {\n      if (this.left && this.left.constructor === _Item) {\n        this.parent = this.left.parent;\n        this.parentSub = this.left.parentSub;\n      }\n      if (this.right && this.right.constructor === _Item) {\n        this.parent = this.right.parent;\n        this.parentSub = this.right.parentSub;\n      }\n    } else if (this.parent.constructor === ID) {\n      const parentItem = getItem(store, this.parent);\n      if (parentItem.constructor === GC) {\n        this.parent = null;\n      } else {\n        this.parent = /** @type {ContentType} */\n        parentItem.content.type;\n      }\n    }\n    return null;\n  }\n  /**\n   * @param {Transaction} transaction\n   * @param {number} offset\n   */\n  integrate(transaction, offset) {\n    if (offset > 0) {\n      this.id.clock += offset;\n      this.left = getItemCleanEnd(transaction, transaction.doc.store, createID(this.id.client, this.id.clock - 1));\n      this.origin = this.left.lastId;\n      this.content = this.content.splice(offset);\n      this.length -= offset;\n    }\n    if (this.parent) {\n      if (!this.left && (!this.right || this.right.left !== null) || this.left && this.left.right !== this.right) {\n        let left = this.left;\n        let o;\n        if (left !== null) {\n          o = left.right;\n        } else if (this.parentSub !== null) {\n          o = /** @type {AbstractType<any>} */\n          this.parent._map.get(this.parentSub) || null;\n          while (o !== null && o.left !== null) {\n            o = o.left;\n          }\n        } else {\n          o = /** @type {AbstractType<any>} */\n          this.parent._start;\n        }\n        const conflictingItems = /* @__PURE__ */ new Set();\n        const itemsBeforeOrigin = /* @__PURE__ */ new Set();\n        while (o !== null && o !== this.right) {\n          itemsBeforeOrigin.add(o);\n          conflictingItems.add(o);\n          if (compareIDs(this.origin, o.origin)) {\n            if (o.id.client < this.id.client) {\n              left = o;\n              conflictingItems.clear();\n            } else if (compareIDs(this.rightOrigin, o.rightOrigin)) {\n              break;\n            }\n          } else if (o.origin !== null && itemsBeforeOrigin.has(getItem(transaction.doc.store, o.origin))) {\n            if (!conflictingItems.has(getItem(transaction.doc.store, o.origin))) {\n              left = o;\n              conflictingItems.clear();\n            }\n          } else {\n            break;\n          }\n          o = o.right;\n        }\n        this.left = left;\n      }\n      if (this.left !== null) {\n        const right = this.left.right;\n        this.right = right;\n        this.left.right = this;\n      } else {\n        let r;\n        if (this.parentSub !== null) {\n          r = /** @type {AbstractType<any>} */\n          this.parent._map.get(this.parentSub) || null;\n          while (r !== null && r.left !== null) {\n            r = r.left;\n          }\n        } else {\n          r = /** @type {AbstractType<any>} */\n          this.parent._start;\n          this.parent._start = this;\n        }\n        this.right = r;\n      }\n      if (this.right !== null) {\n        this.right.left = this;\n      } else if (this.parentSub !== null) {\n        this.parent._map.set(this.parentSub, this);\n        if (this.left !== null) {\n          this.left.delete(transaction);\n        }\n      }\n      if (this.parentSub === null && this.countable && !this.deleted) {\n        this.parent._length += this.length;\n      }\n      addStruct(transaction.doc.store, this);\n      this.content.integrate(transaction, this);\n      addChangedTypeToTransaction(\n        transaction,\n        /** @type {AbstractType<any>} */\n        this.parent,\n        this.parentSub\n      );\n      if (\n        /** @type {AbstractType<any>} */\n        this.parent._item !== null && /** @type {AbstractType<any>} */\n        this.parent._item.deleted || this.parentSub !== null && this.right !== null\n      ) {\n        this.delete(transaction);\n      }\n    } else {\n      new GC(this.id, this.length).integrate(transaction, 0);\n    }\n  }\n  /**\n   * Returns the next non-deleted item\n   */\n  get next() {\n    let n = this.right;\n    while (n !== null && n.deleted) {\n      n = n.right;\n    }\n    return n;\n  }\n  /**\n   * Returns the previous non-deleted item\n   */\n  get prev() {\n    let n = this.left;\n    while (n !== null && n.deleted) {\n      n = n.left;\n    }\n    return n;\n  }\n  /**\n   * Computes the last content address of this Item.\n   */\n  get lastId() {\n    return this.length === 1 ? this.id : createID(this.id.client, this.id.clock + this.length - 1);\n  }\n  /**\n   * Try to merge two items\n   *\n   * @param {Item} right\n   * @return {boolean}\n   */\n  mergeWith(right) {\n    if (this.constructor === right.constructor && compareIDs(right.origin, this.lastId) && this.right === right && compareIDs(this.rightOrigin, right.rightOrigin) && this.id.client === right.id.client && this.id.clock + this.length === right.id.clock && this.deleted === right.deleted && this.redone === null && right.redone === null && this.content.constructor === right.content.constructor && this.content.mergeWith(right.content)) {\n      const searchMarker = (\n        /** @type {AbstractType<any>} */\n        this.parent._searchMarker\n      );\n      if (searchMarker) {\n        searchMarker.forEach((marker) => {\n          if (marker.p === right) {\n            marker.p = this;\n            if (!this.deleted && this.countable) {\n              marker.index -= this.length;\n            }\n          }\n        });\n      }\n      if (right.keep) {\n        this.keep = true;\n      }\n      this.right = right.right;\n      if (this.right !== null) {\n        this.right.left = this;\n      }\n      this.length += right.length;\n      return true;\n    }\n    return false;\n  }\n  /**\n   * Mark this Item as deleted.\n   *\n   * @param {Transaction} transaction\n   */\n  delete(transaction) {\n    if (!this.deleted) {\n      const parent = (\n        /** @type {AbstractType<any>} */\n        this.parent\n      );\n      if (this.countable && this.parentSub === null) {\n        parent._length -= this.length;\n      }\n      this.markDeleted();\n      addToDeleteSet(transaction.deleteSet, this.id.client, this.id.clock, this.length);\n      addChangedTypeToTransaction(transaction, parent, this.parentSub);\n      this.content.delete(transaction);\n    }\n  }\n  /**\n   * @param {StructStore} store\n   * @param {boolean} parentGCd\n   */\n  gc(store, parentGCd) {\n    if (!this.deleted) {\n      throw unexpectedCase();\n    }\n    this.content.gc(store);\n    if (parentGCd) {\n      replaceStruct(store, this, new GC(this.id, this.length));\n    } else {\n      this.content = new ContentDeleted(this.length);\n    }\n  }\n  /**\n   * Transform the properties of this type to binary and write it to an\n   * BinaryEncoder.\n   *\n   * This is called when this Item is sent to a remote peer.\n   *\n   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder The encoder to write data to.\n   * @param {number} offset\n   */\n  write(encoder, offset) {\n    const origin = offset > 0 ? createID(this.id.client, this.id.clock + offset - 1) : this.origin;\n    const rightOrigin = this.rightOrigin;\n    const parentSub = this.parentSub;\n    const info = this.content.getRef() & BITS5 | (origin === null ? 0 : BIT8) | // origin is defined\n    (rightOrigin === null ? 0 : BIT7) | // right origin is defined\n    (parentSub === null ? 0 : BIT6);\n    encoder.writeInfo(info);\n    if (origin !== null) {\n      encoder.writeLeftID(origin);\n    }\n    if (rightOrigin !== null) {\n      encoder.writeRightID(rightOrigin);\n    }\n    if (origin === null && rightOrigin === null) {\n      const parent = (\n        /** @type {AbstractType<any>} */\n        this.parent\n      );\n      if (parent._item !== void 0) {\n        const parentItem = parent._item;\n        if (parentItem === null) {\n          const ykey = findRootTypeKey(parent);\n          encoder.writeParentInfo(true);\n          encoder.writeString(ykey);\n        } else {\n          encoder.writeParentInfo(false);\n          encoder.writeLeftID(parentItem.id);\n        }\n      } else if (parent.constructor === String) {\n        encoder.writeParentInfo(true);\n        encoder.writeString(parent);\n      } else if (parent.constructor === ID) {\n        encoder.writeParentInfo(false);\n        encoder.writeLeftID(parent);\n      } else {\n        unexpectedCase();\n      }\n      if (parentSub !== null) {\n        encoder.writeString(parentSub);\n      }\n    }\n    this.content.write(encoder, offset);\n  }\n};\nvar readItemContent = (decoder, info) => contentRefs[info & BITS5](decoder);\nvar contentRefs = [\n  () => {\n    unexpectedCase();\n  },\n  // GC is not ItemContent\n  readContentDeleted,\n  // 1\n  readContentJSON,\n  // 2\n  readContentBinary,\n  // 3\n  readContentString,\n  // 4\n  readContentEmbed,\n  // 5\n  readContentFormat,\n  // 6\n  readContentType,\n  // 7\n  readContentAny,\n  // 8\n  readContentDoc,\n  // 9\n  () => {\n    unexpectedCase();\n  }\n  // 10 - Skip is not ItemContent\n];\nvar structSkipRefNumber = 10;\nvar Skip = class extends AbstractStruct {\n  get deleted() {\n    return true;\n  }\n  delete() {\n  }\n  /**\n   * @param {Skip} right\n   * @return {boolean}\n   */\n  mergeWith(right) {\n    if (this.constructor !== right.constructor) {\n      return false;\n    }\n    this.length += right.length;\n    return true;\n  }\n  /**\n   * @param {Transaction} transaction\n   * @param {number} offset\n   */\n  integrate(transaction, offset) {\n    unexpectedCase();\n  }\n  /**\n   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder\n   * @param {number} offset\n   */\n  write(encoder, offset) {\n    encoder.writeInfo(structSkipRefNumber);\n    writeVarUint(encoder.restEncoder, this.length - offset);\n  }\n  /**\n   * @param {Transaction} transaction\n   * @param {StructStore} store\n   * @return {null | number}\n   */\n  getMissing(transaction, store) {\n    return null;\n  }\n};\nvar glo = (\n  /** @type {any} */\n  typeof globalThis !== \"undefined\" ? globalThis : typeof window !== \"undefined\" ? window : typeof global !== \"undefined\" ? global : {}\n);\nvar importIdentifier = \"__ $YJS$ __\";\nif (glo[importIdentifier] === true) {\n  console.error(\"Yjs was already imported. This breaks constructor checks and will lead to issues! - https://github.com/yjs/yjs/issues/438\");\n}\nglo[importIdentifier] = true;\nexport {\n  AbsolutePosition,\n  AbstractConnector,\n  AbstractStruct,\n  AbstractType,\n  YArray as Array,\n  ContentAny,\n  ContentBinary,\n  ContentDeleted,\n  ContentEmbed,\n  ContentFormat,\n  ContentJSON,\n  ContentString,\n  ContentType,\n  Doc,\n  GC,\n  ID,\n  Item,\n  YMap as Map,\n  PermanentUserData,\n  RelativePosition,\n  Snapshot,\n  YText as Text,\n  Transaction,\n  UndoManager,\n  UpdateEncoderV1,\n  YXmlElement as XmlElement,\n  YXmlFragment as XmlFragment,\n  YXmlHook as XmlHook,\n  YXmlText as XmlText,\n  YArrayEvent,\n  YEvent,\n  YMapEvent,\n  YTextEvent,\n  YXmlEvent,\n  applyUpdate,\n  applyUpdateV2,\n  cleanupYTextFormatting,\n  compareIDs,\n  compareRelativePositions,\n  convertUpdateFormatV1ToV2,\n  convertUpdateFormatV2ToV1,\n  createAbsolutePositionFromRelativePosition,\n  createDeleteSet,\n  createDeleteSetFromStructStore,\n  createDocFromSnapshot,\n  createID,\n  createRelativePositionFromJSON,\n  createRelativePositionFromTypeIndex,\n  createSnapshot,\n  decodeRelativePosition,\n  decodeSnapshot,\n  decodeSnapshotV2,\n  decodeStateVector,\n  decodeUpdate,\n  decodeUpdateV2,\n  diffUpdate,\n  diffUpdateV2,\n  emptySnapshot,\n  encodeRelativePosition,\n  encodeSnapshot,\n  encodeSnapshotV2,\n  encodeStateAsUpdate,\n  encodeStateAsUpdateV2,\n  encodeStateVector,\n  encodeStateVectorFromUpdate,\n  encodeStateVectorFromUpdateV2,\n  equalDeleteSets,\n  equalSnapshots,\n  findIndexSS,\n  findRootTypeKey,\n  getItem,\n  getState,\n  getTypeChildren,\n  isDeleted,\n  isParentOf,\n  iterateDeletedStructs,\n  logType,\n  logUpdate,\n  logUpdateV2,\n  mergeUpdates,\n  mergeUpdatesV2,\n  obfuscateUpdate,\n  obfuscateUpdateV2,\n  parseUpdateMeta,\n  parseUpdateMetaV2,\n  readUpdate,\n  readUpdateV2,\n  relativePositionToJSON,\n  snapshot,\n  snapshotContainsUpdate,\n  transact,\n  tryGc,\n  typeListToArraySnapshot,\n  typeMapGetSnapshot\n};\n//# sourceMappingURL=yjs.js.map\n",
      "start": 1699405180689,
      "end": 1699405180691,
      "order": "normal",
      "sourcemaps": null
    }
  ]
}
