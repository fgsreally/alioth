{
  "resolvedId": "D:/MyProject/5/alioth/packages/lib/dist/index.mjs",
  "transforms": [
    {
      "name": "__load__",
      "result": "var __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __decorateClass = (decorators, target, key, kind) => {\n  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc(target, key) : target;\n  for (var i = decorators.length - 1, decorator; i >= 0; i--)\n    if (decorator = decorators[i])\n      result = (kind ? decorator(target, key, result) : decorator(result)) || result;\n  if (kind && result)\n    __defProp(target, key, result);\n  return result;\n};\n\n// src/core/connect.ts\nfunction createConnector() {\n  const projectMap2 = /* @__PURE__ */ new Map();\n  const urlMap2 = /* @__PURE__ */ new Map();\n  async function connect2(url) {\n    if (urlMap2.has(url))\n      return;\n    urlMap2.set(url, null);\n    const ret = await fetch(new URL(\"/alioth\", url).href);\n    const data = await ret.json();\n    const { project, entry } = data;\n    if (projectMap2.has(project))\n      throw new Error(\"\\u5DF2\\u5B58\\u5728\\u540C\\u540D\\u9879\\u76EE\");\n    const sEl = document.createElement(\"script\");\n    sEl.src = new URL(\"/@vite/client\", url).href;\n    sEl.type = \"module\";\n    document.body.appendChild(sEl);\n    for (const name in entry) {\n      entry[name] = new URL(entry[name], url).href;\n      urlMap2.set(entry[name], project);\n    }\n    projectMap2.set(project, entry);\n    urlMap2.set(url, project);\n  }\n  async function dynamicImport2(project, entry, method) {\n    const entries = projectMap2.get(project);\n    if (!entries)\n      return;\n    if (!(entry in entries))\n      return;\n    const url = entries[entry];\n    const module = await import(url);\n    return {\n      module,\n      data: method && module[method],\n      url\n    };\n  }\n  return {\n    connect: connect2,\n    projectMap: projectMap2,\n    dynamicImport: dynamicImport2,\n    urlMap: urlMap2\n  };\n}\n\n// src/core/eventStack.ts\nfunction createEventStack(options = {}) {\n  let initialized = false;\n  const state2 = {\n    isActive: true,\n    current: -1,\n    queue: [],\n    commands: {},\n    commandArray: [],\n    destroyArray: []\n  };\n  const register2 = (command) => {\n    if (command.name in state2.commands)\n      return;\n    if (initialized && command.init)\n      state2.destroyArray.push(command.init());\n    state2.commandArray.push(command);\n    state2.commands[command.name] = () => {\n      const { redo, undo } = command.execute() || {};\n      if (!command.pushQueue)\n        return;\n      let { queue, current } = state2;\n      if (queue.length > 0) {\n        queue = queue.slice(0, current + 1);\n        state2.queue = queue;\n      }\n      queue.push({\n        redo,\n        undo\n      });\n      state2.current = current + 1;\n    };\n  };\n  if (options.redo) {\n    register2({\n      name: \"redo\",\n      keyboard: \"ctrl+y\",\n      execute() {\n        const item = state2.queue[state2.current + 1];\n        if (item) {\n          item.redo && item.redo();\n          state2.current++;\n        }\n      }\n    });\n  }\n  if (options.undo) {\n    register2({\n      name: \"undo\",\n      keyboard: \"ctrl+z\",\n      execute() {\n        if (state2.current === -1)\n          return;\n        const item = state2.queue[state2.current];\n        if (item) {\n          item.undo && item.undo();\n          state2.current--;\n        }\n      }\n    });\n  }\n  const keyboardEvent = (() => {\n    const onKeydowm = (e) => {\n      const { ctrlKey, key, altKey, shiftKey } = e;\n      let keyString = [];\n      if (altKey)\n        keyString.push(\"alt\");\n      if (ctrlKey)\n        keyString.push(\"ctrl\");\n      if (shiftKey)\n        keyString.push(\"shift\");\n      keyString.push(key.toLowerCase());\n      keyString = keyString.join(\"+\");\n      state2.commandArray.forEach(({ keyboard, name }) => {\n        if (!keyboard)\n          return;\n        if (keyboard === keyString) {\n          state2.commands[name]();\n          e.preventDefault();\n        }\n      });\n    };\n    const init = () => {\n      window.addEventListener(\"keydown\", onKeydowm);\n      return () => {\n        window.removeEventListener(\"keydown\", onKeydowm);\n      };\n    };\n    return init;\n  })();\n  state2.destroyArray.push(keyboardEvent());\n  function initialize2() {\n    if (initialized)\n      return;\n    initialized = true;\n    state2.commandArray.forEach(\n      (command) => command.init && state2.destroyArray.push(command.init())\n    );\n  }\n  function destroy() {\n    state2.isActive && state2.destroyArray.forEach((fn) => fn && fn());\n  }\n  return { state: state2, register: register2, initialize: initialize2, destroy };\n}\n\n// src/core/invoke.ts\nasync function loadJSON(url) {\n  const ret = await fetch(url);\n  return ret.json();\n}\nfunction loadPresets(presets) {\n  return Promise.all(presets.map((url) => {\n    if (url.endsWith(\".css\")) {\n      const css = document.createElement(\"link\");\n      css.href = url;\n      css.rel = \"stylesheet\";\n      css.type = \"text/css\";\n      document.head.appendChild(css);\n      return new Promise((resolve, reject) => {\n        css.onload = resolve;\n        css.onerror = reject;\n      });\n    } else {\n      return new Promise(async (resolve, reject) => {\n        try {\n          const module = await import(url);\n          for (const key in module) {\n            const exports = module[key];\n            if (typeof exports === \"object\" && exports.alioth)\n              window[`$alioth_${exports.alioth}`]?.(exports.data);\n          }\n          resolve(module);\n        } catch (e) {\n          reject(e);\n        }\n      });\n    }\n  }));\n}\nfunction loadStyleOrScript(url) {\n  if (url.endsWith(\".css\")) {\n    const css = document.createElement(\"link\");\n    css.href = url;\n    css.rel = \"stylesheet\";\n    css.type = \"text/css\";\n    document.head.appendChild(css);\n    return new Promise((resolve, reject) => {\n      css.onload = resolve;\n      css.onerror = reject;\n    });\n  } else {\n    return import(url);\n  }\n}\nfunction detect() {\n  [\"header\", \"state\", \"error\", \"eventStack\", \"zone\", \"view\", \"update\", \"error\", \"interval\", \"setEngine\"].forEach((item) => {\n    if (!window[`$alioth_${item}`])\n      console.warn(`[Alioth]: miss global property $alioth_${item}`);\n  });\n}\n\n// src/document/document.ts\nimport { omit } from \"lodash-es\";\nimport { UndoManager, Map as YMap } from \"yjs\";\nimport { nanoid as nanoid2 } from \"nanoid\";\nimport EventEmitter from \"eventemitter3\";\n\n// src/document/node.ts\nimport { nanoid } from \"nanoid\";\nimport { clone, set } from \"lodash-es\";\nvar VirtualNode = class {\n  constructor(initAttrs) {\n    this.id = nanoid();\n    this.children = [];\n    this.timeout = 800;\n    this.attrs = initAttrs || {};\n  }\n  get cloneChilds() {\n    return clone(this.children);\n  }\n  get index() {\n    return this.parent?.children.findIndex((node) => node.id === this.id);\n  }\n  bind(doc) {\n    this.doc = doc;\n    if (this.doc.controller)\n      this.doc.controller.create(this.id, this.attrs);\n  }\n  setAttributes(values) {\n    for (const key in values)\n      this.set(key, values[key]);\n  }\n  toJSON() {\n    return {\n      id: this.id,\n      attrs: this.attrs,\n      children: this.children.map((item) => item.toJSON())\n    };\n  }\n  set(path, value) {\n    this._set(path, value);\n    if (this.doc?.controller)\n      this.doc.controller.set(this.id, path, value);\n  }\n  _set(path, value) {\n    this.doc.emit(\"set\", { path, value });\n    set(this.attrs, path, value);\n  }\n  insert(node, index) {\n    if (!index && index !== 0)\n      index = this.children.length;\n    this._insert(node, index);\n    if (this.doc?.controller)\n      this.doc.controller.insert(this.id, node.id, index);\n  }\n  _insert(node, index) {\n    node.parent = this;\n    this.doc.emit(\"insert\", { parent: this, child: node, index });\n    this.children.splice(index, 0, node);\n  }\n  remove(index) {\n    const node = this._remove(index);\n    if (this.doc?.controller && node)\n      this.doc.controller.delete(this.id, node.id, index);\n  }\n  _removeNode(node) {\n    this.children.splice(this.children.findIndex((item) => item.id === node.id), 1);\n  }\n  _remove(index) {\n    const removeBlock = this.children.splice(index, 1)[0];\n    const { doc } = this;\n    function traverse2(node) {\n      if (!node)\n        return;\n      doc.blockMap.delete(node.id);\n      doc.emit(\"remove\", { node });\n      node.parent = null;\n      node.children.forEach(traverse2);\n    }\n    traverse2(removeBlock);\n    return removeBlock;\n  }\n  findById(id) {\n    for (const VirtualNode2 of this.children) {\n      if (VirtualNode2.id === id)\n        return VirtualNode2;\n      if (VirtualNode2.findById(id))\n        return VirtualNode2.findById(id);\n    }\n  }\n  contains(VirtualNode2) {\n    return this.id === VirtualNode2.id || !!this.findById(VirtualNode2.id);\n  }\n  findByAttrs(filter) {\n    const blocks = [];\n    for (const VirtualNode2 of this.children) {\n      if (filter(VirtualNode2.attrs))\n        blocks.push(VirtualNode2);\n      blocks.push(...VirtualNode2.findByAttrs(filter));\n    }\n    return blocks;\n  }\n};\n\n// src/document/document.ts\nvar VirtualDocument = class extends EventEmitter {\n  constructor(initAttrs, id = nanoid2()) {\n    super();\n    this.id = id;\n    this.blockMap = /* @__PURE__ */ new Map();\n    this.data = {};\n    this.root = this.createNode(initAttrs, \"root\");\n  }\n  get(id) {\n    return this.blockMap.get(id);\n  }\n  bind(controller) {\n    this.controller = controller;\n    this.root.bind(this);\n  }\n  clean() {\n    this.blockMap.forEach((v, k, m) => {\n      if (!v.parent)\n        m.delete(k);\n    });\n  }\n  createNode(initAttrs, id) {\n    const node = new VirtualNode(initAttrs);\n    id && (node.id = id);\n    node.bind(this);\n    if (id === \"root\")\n      this.root = node;\n    this.blockMap.set(node.id, node);\n    this.emit(\"create\", id);\n    return node;\n  }\n  _createNode(initAttrs, id) {\n    if (id && this.blockMap.has(id))\n      return this.blockMap.get(id);\n    const node = new VirtualNode(initAttrs);\n    id && (node.id = id);\n    node.doc = this;\n    if (id === \"root\")\n      this.root = node;\n    this.blockMap.set(node.id, node);\n    this.emit(\"create\", id);\n    return node;\n  }\n  removeNode(node) {\n    if (node.parent) {\n      node.parent.remove(node.index);\n      this.blockMap.delete(node.id);\n    }\n  }\n  _removeNode(node) {\n    if (node.parent) {\n      node.parent._remove(node.index);\n      this.blockMap.delete(node.id);\n    } else {\n      this.blockMap.delete(node.id);\n    }\n  }\n  select(node, type = \"activeNode\") {\n    return this[type] = node;\n  }\n  cancel(type = \"activeNode\") {\n    return this[type] = void 0;\n  }\n  load(data) {\n    const that = this;\n    function traverse2(data2) {\n      const node = that.createNode(data2.attrs, data2.id);\n      data2.children.forEach((item, i) => {\n        const child = traverse2(item);\n        node.insert(child, i);\n      });\n      return node;\n    }\n    if (this.controller) {\n      this.controller.ydoc.transact(() => {\n        this.root = traverse2(data);\n      });\n    } else {\n      this.root = traverse2(data);\n    }\n    return this;\n  }\n  transact(cb, origin) {\n    if (this.controller)\n      this.controller.ydoc.transact(cb, origin);\n  }\n};\nfunction observeDoc(doc) {\n  const fn = (events, t) => {\n    let tasks = [];\n    events.forEach((event) => {\n      if (!t.local || t.origin instanceof UndoManager) {\n        if (event.changes.keys.size === 0) {\n          event.changes.deleted.forEach((item) => {\n            const parent = doc.get(event.path[0]);\n            const id = item.content.getContent()[0];\n            const node = doc.get(id);\n            if (node)\n              parent._removeNode(node);\n          });\n          event.changes.added.forEach((item) => {\n            const id = item.content.getContent()[0];\n            const node = doc.get(id);\n            if (item.left) {\n              const left = doc.get(item.left.content.getContent()[0]);\n              left.parent._insert(node, left.index + 1);\n            } else {\n              const parent = doc.get(event.path[0]);\n              parent._insert(node, 0);\n            }\n          });\n        } else {\n          event.changes.keys.forEach((item, i) => {\n            const obj = event.target.get(i);\n            switch (item.action) {\n              case \"add\":\n                if (obj instanceof YMap) {\n                  if (obj.has(\"_is_node\")) {\n                    const attrs = obj.toJSON();\n                    const node = doc._createNode(omit(attrs, [\"children\"]), i);\n                    if (attrs.children.length) {\n                      tasks.push(() => {\n                        attrs.children.forEach((k, i2) => {\n                          node._insert(doc.get(k), i2);\n                        });\n                      });\n                    }\n                  } else {\n                    const path = [...event.path.slice(1), i].join(\".\");\n                    doc.get(event.path[0])?._set(path, obj.toJSON());\n                  }\n                } else {\n                  const path = [...event.path.slice(1), i].join(\".\");\n                  doc.get(event.path[0])?._set(path, obj);\n                }\n                break;\n              case \"delete\":\n                if (item.oldValue instanceof YMap) {\n                  doc._removeNode(doc.get(i));\n                } else {\n                  const path = [...event.path.slice(1), i].join(\".\");\n                  doc.get(event.path[0])?._set(path, obj);\n                }\n                break;\n              case \"update\":\n                if (obj instanceof YMap) {\n                  if (obj.has(\"_is_node\")) {\n                    const attrs = obj.toJSON();\n                    if (attrs.children.length) {\n                      tasks.push(() => {\n                        attrs.children.forEach((k, i2) => {\n                          doc.get(attrs.id)._insert(doc.get(k), i2);\n                        });\n                      });\n                    }\n                  } else {\n                    doc.get(event.path[0])?._set(\n                      [...event.path.slice(1), i].join(\".\"),\n                      obj.toJSON()\n                    );\n                  }\n                } else {\n                  doc.get(event.path[0])?._set(\n                    [...event.path.slice(1), i].join(\".\"),\n                    obj\n                  );\n                }\n            }\n          });\n        }\n        tasks.forEach((task) => task());\n        tasks = [];\n      }\n    });\n  };\n  doc.controller.map.observeDeep(fn);\n  return () => {\n    doc.controller.map.unobserveDeep(fn);\n  };\n}\n\n// src/document/controller.ts\nimport { Doc, UndoManager as UndoManager2, Array as YArray, Map as YMap2 } from \"yjs\";\nvar Controller = class {\n  constructor(options = {}) {\n    this.options = options;\n    this.ydoc = new Doc();\n    this.map = this.ydoc.getMap(\"nodes\");\n    this.manager = new UndoManager2(this.map, this.options);\n  }\n  toJSON() {\n    return this.map.toJSON();\n  }\n  undo() {\n    this.manager.undo();\n  }\n  redo() {\n    this.manager.redo();\n  }\n  create(id, data) {\n    this.ydoc.transact(() => {\n      const map = traverse({ ...data, id, _is_node: true });\n      map.set(\"children\", new YArray());\n      this.map.set(id, map);\n    });\n  }\n  insert(parent, child, index) {\n    this.ydoc.transact(() => {\n      const arr = this.map.get(parent).get(\"children\");\n      arr.insert(index, [child]);\n    });\n  }\n  delete(parent, child, index) {\n    this.ydoc.transact(() => {\n      const arr = this.map.get(parent).get(\"children\");\n      arr.delete(index, 1);\n      this.map.delete(child);\n    });\n  }\n  set(id, path, value) {\n    const map = this.map.get(id);\n    const paths = path.split(\".\");\n    let structure = map;\n    const key = paths.pop();\n    paths.forEach((p) => {\n      structure = structure.get(p);\n    });\n    this.ydoc.transact(() => {\n    });\n    structure.set(key, traverse(value));\n  }\n};\nfunction traverse(value) {\n  if (Array.isArray(value))\n    return YArray.from(value.map(traverse));\n  if (typeof value === \"object\") {\n    const obj = {};\n    for (const i in value)\n      obj[i] = traverse(value[i]);\n    return new YMap2(Object.entries(obj));\n  }\n  return value;\n}\n\n// src/utils/index.ts\nfunction getQuery(key) {\n  return new URLSearchParams(location.search).get(key);\n}\nfunction draggable(opts, dom = window) {\n  let element;\n  const moveEvent = (e) => {\n    opts.move?.(e);\n  };\n  const upEvent = (e) => {\n    opts.up?.(e);\n    element.removeEventListener(\"mousemove\", moveEvent);\n    element.removeEventListener(\"mouseup\", upEvent);\n  };\n  if (typeof dom === \"string\")\n    element = document.querySelector(dom);\n  else\n    element = dom;\n  element.addEventListener(\"mousemove\", moveEvent);\n  element.addEventListener(\"mouseup\", upEvent);\n}\n\n// src/model/baseDocModel.ts\nimport { Global, Init, Tag } from \"phecda-core\";\nvar BaseDocModel = class {\n  constructor() {\n    this.containerAttrs = {};\n    this.doc = new VirtualDocument({}, \"model\");\n  }\n  _init() {\n    window.$alioth_container = (attr) => this.containerAttrs = attr;\n  }\n  get activePage() {\n    return this.find(this.activeId);\n  }\n  get activeNode() {\n    return this.doc.activeNode;\n  }\n  get pages() {\n    return this.doc.root.children;\n  }\n  active(id) {\n    if (this.activeId === id)\n      return;\n    if (this.doc.root.children.some((item) => item.id === id))\n      this.activeId = id;\n  }\n  add(id) {\n    const node = this.doc.createNode(this.containerAttrs, id);\n    this.doc.root.insert(node);\n    return node;\n  }\n  remove(id) {\n    const { children } = this.doc.root;\n    const index = children.findIndex((item) => item.id === id);\n    this.doc.root.remove(index);\n    if (children.length > 1)\n      this.activeId = children[index - 1].id;\n    else\n      this.activeId = \"\";\n  }\n  find(id) {\n    return this.doc.root.children.find((item) => item.id === id);\n  }\n  index(id) {\n    return this.doc.root.children.findIndex((item) => id === item.id);\n  }\n  load(data) {\n    data = typeof data === \"string\" ? JSON.parse(data) : data;\n    this.doc.load(data);\n  }\n  toJSON() {\n    return this.doc.root;\n  }\n};\n__decorateClass([\n  Init\n], BaseDocModel.prototype, \"_init\", 1);\nBaseDocModel = __decorateClass([\n  Global,\n  Tag(\"doc\")\n], BaseDocModel);\n\n// src/model/baseDragModel.ts\nimport { Global as Global2, Tag as Tag2 } from \"phecda-core\";\nvar dragenter = (e) => {\n  e.dataTransfer.dropEffect = \"move\";\n};\nvar dragover = (e) => {\n  e.preventDefault();\n};\nvar dragleave = (e) => {\n  e.dataTransfer.dropEffect = \"none\";\n};\nvar BaseDragModel = class {\n  constructor() {\n    this.moduleMap = /* @__PURE__ */ new Map();\n    this.data = {};\n  }\n  add(el, cb) {\n    this.moduleMap.set(el, cb);\n  }\n  del(el) {\n    this.moduleMap.delete(el);\n  }\n  execCb(el, data, e) {\n    this.moduleMap.get(el)?.(data, e);\n  }\n  dragStart(data) {\n    this.listenController = new AbortController();\n    const { signal } = this.listenController;\n    for (const [el] of this.moduleMap) {\n      el.addEventListener(\"dragenter\", dragenter, { signal });\n      el.addEventListener(\"dragover\", dragover, { signal });\n      el.addEventListener(\"dragleave\", dragleave, { signal });\n      el.addEventListener(\"drop\", (e) => {\n        this.execCb(el, data, e);\n      }, { signal });\n    }\n  }\n  dragEnd() {\n    this.listenController.abort();\n    this.listenController = void 0;\n  }\n};\nBaseDragModel = __decorateClass([\n  Global2,\n  Tag2(\"drag\")\n], BaseDragModel);\n\n// src/model/baseEventModel.ts\nimport { Global as Global3, Tag as Tag3 } from \"phecda-core\";\nvar { register, initialize, state } = createEventStack({ undo: true, redo: true });\nvar BaseEventModel = class {\n  constructor() {\n    this.state = state;\n    this.register = register;\n    window.$alioth_eventStack = register;\n    initialize();\n  }\n};\nBaseEventModel = __decorateClass([\n  Global3,\n  Tag3(\"event\")\n], BaseEventModel);\n\n// src/model/baseImportModel.ts\nimport { Global as Global4, Init as Init2, Tag as Tag4 } from \"phecda-core\";\nvar { connect, dynamicImport, urlMap, projectMap } = createConnector();\nvar BaseImportModel = class {\n  constructor() {\n    this.graph = {};\n  }\n  _init() {\n    window.$alioth_update = (url, module) => {\n      this.graph[url.split(\"?\")[0]] = this.importModule(module);\n    };\n    window.$alioth_state = (arg) => this.setState?.(arg);\n  }\n  async connectVite(url) {\n    await connect(url);\n    for (const [project, entries] of projectMap.entries()) {\n      for (const entry in entries) {\n        const { module, url: url2 } = await dynamicImport(project, entry);\n        this.graph[url2] = this.importModule(module);\n      }\n    }\n  }\n  async connectPreset(presets) {\n    presets.forEach(async (url) => {\n      try {\n        const module = await loadStyleOrScript(url);\n        if (!url.endsWith(\".css\"))\n          this.graph[url] = this.importModule(module);\n        else\n          this.graph[url] = {};\n      } catch (e) {\n        window.$alioth_error(\"LoadError\", `load dependence ${url} failed`);\n      }\n    });\n  }\n  importModule(module) {\n    const exportsMap = {};\n    for (const exports in module) {\n      if (typeof module[exports] === \"object\" && module[exports].alioth) {\n        const { alioth: type, data } = module[exports];\n        window[`$alioth_${type}`]?.(data);\n        exportsMap[exports] = module[exports];\n      }\n    }\n    return exportsMap;\n  }\n};\n__decorateClass([\n  Init2\n], BaseImportModel.prototype, \"_init\", 1);\nBaseImportModel = __decorateClass([\n  Global4,\n  Tag4(\"import\")\n], BaseImportModel);\n\n// src/model/baseCommandModel.ts\nimport { Global as Global5, Init as Init3, Tag as Tag5 } from \"phecda-core\";\nvar BaseCommandModel = class {\n  constructor() {\n    this.commands = [];\n  }\n  _init() {\n    window.$alioth_command = this.register.bind(this);\n  }\n  register(command) {\n    this.commands.push(command);\n  }\n  input(key, arg) {\n    return this.commands.find((item) => item.key === key)?.exec(arg);\n  }\n};\n__decorateClass([\n  Init3\n], BaseCommandModel.prototype, \"_init\", 1);\nBaseCommandModel = __decorateClass([\n  Global5,\n  Tag5(\"command\")\n], BaseCommandModel);\n\n// src/model/baseErrorModel.ts\nimport { Global as Global6, Init as Init4, Tag as Tag6, Watcher } from \"phecda-core\";\nvar BaseErrorModel = class {\n  _init() {\n    window.$alioth_error = this.setErrorHandler.bind(this);\n  }\n  setErrorHandler(handler) {\n    this.errorHandlers.push(handler);\n  }\n  watchError({ error, type }) {\n    const handler = this.errorHandlers.find((item) => item.type === type);\n    if (handler)\n      handler.handler(error);\n    else\n      console.error(`[Alioth]: ${type}`);\n  }\n};\n__decorateClass([\n  Init4\n], BaseErrorModel.prototype, \"_init\", 1);\n__decorateClass([\n  Watcher(\"custom_error\")\n], BaseErrorModel.prototype, \"watchError\", 1);\nBaseErrorModel = __decorateClass([\n  Global6,\n  Tag6(\"error\")\n], BaseErrorModel);\nexport {\n  BaseCommandModel,\n  BaseDocModel,\n  BaseDragModel,\n  BaseErrorModel,\n  BaseEventModel,\n  BaseImportModel,\n  Controller,\n  VirtualDocument,\n  VirtualNode,\n  connect,\n  createConnector,\n  createEventStack,\n  detect,\n  draggable,\n  dynamicImport,\n  getQuery,\n  loadJSON,\n  loadPresets,\n  loadStyleOrScript,\n  observeDoc,\n  projectMap,\n  urlMap\n};\n                                  ",
      "start": 1699405180658,
      "end": 1699405180658
    },
    {
      "name": "vite:css",
      "start": 1699405180658,
      "end": 1699405180658,
      "order": "normal"
    },
    {
      "name": "vite:esbuild",
      "start": 1699405180658,
      "end": 1699405180658,
      "order": "normal"
    },
    {
      "name": "vite:json",
      "start": 1699405180658,
      "end": 1699405180658,
      "order": "normal"
    },
    {
      "name": "vite:worker",
      "start": 1699405180658,
      "end": 1699405180658,
      "order": "normal"
    },
    {
      "name": "vite:vue",
      "start": 1699405180658,
      "end": 1699405180658,
      "order": "normal"
    },
    {
      "name": "alioth-connector",
      "start": 1699405180658,
      "end": 1699405180658,
      "order": "normal"
    },
    {
      "name": "vite:define",
      "start": 1699405180658,
      "end": 1699405180658,
      "order": "normal"
    },
    {
      "name": "vite:css-post",
      "start": 1699405180658,
      "end": 1699405180658,
      "order": "normal"
    },
    {
      "name": "vite:worker-import-meta-url",
      "start": 1699405180658,
      "end": 1699405180658,
      "order": "normal"
    },
    {
      "name": "vite:asset-import-meta-url",
      "start": 1699405180658,
      "end": 1699405180658,
      "order": "normal"
    },
    {
      "name": "vite:dynamic-import-vars",
      "start": 1699405180658,
      "end": 1699405180658,
      "order": "normal"
    },
    {
      "name": "vite:import-glob",
      "start": 1699405180658,
      "end": 1699405180658,
      "order": "normal"
    },
    {
      "name": "vite:client-inject",
      "start": 1699405180658,
      "end": 1699405180658,
      "order": "normal"
    },
    {
      "name": "vite:import-analysis",
      "result": "import { injectQuery as __vite__injectQuery } from \"/@vite/client\";var __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __decorateClass = (decorators, target, key, kind) => {\n  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc(target, key) : target;\n  for (var i = decorators.length - 1, decorator; i >= 0; i--)\n    if (decorator = decorators[i])\n      result = (kind ? decorator(target, key, result) : decorator(result)) || result;\n  if (kind && result)\n    __defProp(target, key, result);\n  return result;\n};\n\n// src/core/connect.ts\nfunction createConnector() {\n  const projectMap2 = /* @__PURE__ */ new Map();\n  const urlMap2 = /* @__PURE__ */ new Map();\n  async function connect2(url) {\n    if (urlMap2.has(url))\n      return;\n    urlMap2.set(url, null);\n    const ret = await fetch(new URL(\"/alioth\", url).href);\n    const data = await ret.json();\n    const { project, entry } = data;\n    if (projectMap2.has(project))\n      throw new Error(\"\\u5DF2\\u5B58\\u5728\\u540C\\u540D\\u9879\\u76EE\");\n    const sEl = document.createElement(\"script\");\n    sEl.src = new URL(\"/@vite/client\", url).href;\n    sEl.type = \"module\";\n    document.body.appendChild(sEl);\n    for (const name in entry) {\n      entry[name] = new URL(entry[name], url).href;\n      urlMap2.set(entry[name], project);\n    }\n    projectMap2.set(project, entry);\n    urlMap2.set(url, project);\n  }\n  async function dynamicImport2(project, entry, method) {\n    const entries = projectMap2.get(project);\n    if (!entries)\n      return;\n    if (!(entry in entries))\n      return;\n    const url = entries[entry];\n    const module = await import(__vite__injectQuery(url, 'import'));\n    return {\n      module,\n      data: method && module[method],\n      url\n    };\n  }\n  return {\n    connect: connect2,\n    projectMap: projectMap2,\n    dynamicImport: dynamicImport2,\n    urlMap: urlMap2\n  };\n}\n\n// src/core/eventStack.ts\nfunction createEventStack(options = {}) {\n  let initialized = false;\n  const state2 = {\n    isActive: true,\n    current: -1,\n    queue: [],\n    commands: {},\n    commandArray: [],\n    destroyArray: []\n  };\n  const register2 = (command) => {\n    if (command.name in state2.commands)\n      return;\n    if (initialized && command.init)\n      state2.destroyArray.push(command.init());\n    state2.commandArray.push(command);\n    state2.commands[command.name] = () => {\n      const { redo, undo } = command.execute() || {};\n      if (!command.pushQueue)\n        return;\n      let { queue, current } = state2;\n      if (queue.length > 0) {\n        queue = queue.slice(0, current + 1);\n        state2.queue = queue;\n      }\n      queue.push({\n        redo,\n        undo\n      });\n      state2.current = current + 1;\n    };\n  };\n  if (options.redo) {\n    register2({\n      name: \"redo\",\n      keyboard: \"ctrl+y\",\n      execute() {\n        const item = state2.queue[state2.current + 1];\n        if (item) {\n          item.redo && item.redo();\n          state2.current++;\n        }\n      }\n    });\n  }\n  if (options.undo) {\n    register2({\n      name: \"undo\",\n      keyboard: \"ctrl+z\",\n      execute() {\n        if (state2.current === -1)\n          return;\n        const item = state2.queue[state2.current];\n        if (item) {\n          item.undo && item.undo();\n          state2.current--;\n        }\n      }\n    });\n  }\n  const keyboardEvent = (() => {\n    const onKeydowm = (e) => {\n      const { ctrlKey, key, altKey, shiftKey } = e;\n      let keyString = [];\n      if (altKey)\n        keyString.push(\"alt\");\n      if (ctrlKey)\n        keyString.push(\"ctrl\");\n      if (shiftKey)\n        keyString.push(\"shift\");\n      keyString.push(key.toLowerCase());\n      keyString = keyString.join(\"+\");\n      state2.commandArray.forEach(({ keyboard, name }) => {\n        if (!keyboard)\n          return;\n        if (keyboard === keyString) {\n          state2.commands[name]();\n          e.preventDefault();\n        }\n      });\n    };\n    const init = () => {\n      window.addEventListener(\"keydown\", onKeydowm);\n      return () => {\n        window.removeEventListener(\"keydown\", onKeydowm);\n      };\n    };\n    return init;\n  })();\n  state2.destroyArray.push(keyboardEvent());\n  function initialize2() {\n    if (initialized)\n      return;\n    initialized = true;\n    state2.commandArray.forEach(\n      (command) => command.init && state2.destroyArray.push(command.init())\n    );\n  }\n  function destroy() {\n    state2.isActive && state2.destroyArray.forEach((fn) => fn && fn());\n  }\n  return { state: state2, register: register2, initialize: initialize2, destroy };\n}\n\n// src/core/invoke.ts\nasync function loadJSON(url) {\n  const ret = await fetch(url);\n  return ret.json();\n}\nfunction loadPresets(presets) {\n  return Promise.all(presets.map((url) => {\n    if (url.endsWith(\".css\")) {\n      const css = document.createElement(\"link\");\n      css.href = url;\n      css.rel = \"stylesheet\";\n      css.type = \"text/css\";\n      document.head.appendChild(css);\n      return new Promise((resolve, reject) => {\n        css.onload = resolve;\n        css.onerror = reject;\n      });\n    } else {\n      return new Promise(async (resolve, reject) => {\n        try {\n          const module = await import(__vite__injectQuery(url, 'import'));\n          for (const key in module) {\n            const exports = module[key];\n            if (typeof exports === \"object\" && exports.alioth)\n              window[`$alioth_${exports.alioth}`]?.(exports.data);\n          }\n          resolve(module);\n        } catch (e) {\n          reject(e);\n        }\n      });\n    }\n  }));\n}\nfunction loadStyleOrScript(url) {\n  if (url.endsWith(\".css\")) {\n    const css = document.createElement(\"link\");\n    css.href = url;\n    css.rel = \"stylesheet\";\n    css.type = \"text/css\";\n    document.head.appendChild(css);\n    return new Promise((resolve, reject) => {\n      css.onload = resolve;\n      css.onerror = reject;\n    });\n  } else {\n    return import(__vite__injectQuery(url, 'import'));\n  }\n}\nfunction detect() {\n  [\"header\", \"state\", \"error\", \"eventStack\", \"zone\", \"view\", \"update\", \"error\", \"interval\", \"setEngine\"].forEach((item) => {\n    if (!window[`$alioth_${item}`])\n      console.warn(`[Alioth]: miss global property $alioth_${item}`);\n  });\n}\n\n// src/document/document.ts\nimport { omit } from \"/node_modules/.vite/deps/lodash-es.js?v=4de675e4\";\nimport { UndoManager, Map as YMap } from \"/node_modules/.vite/deps/yjs.js?v=4de675e4\";\nimport { nanoid as nanoid2 } from \"/node_modules/.vite/deps/nanoid.js?v=4de675e4\";\nimport EventEmitter from \"/node_modules/.vite/deps/eventemitter3.js?v=4de675e4\";\n\n// src/document/node.ts\nimport { nanoid } from \"/node_modules/.vite/deps/nanoid.js?v=4de675e4\";\nimport { clone, set } from \"/node_modules/.vite/deps/lodash-es.js?v=4de675e4\";\nvar VirtualNode = class {\n  constructor(initAttrs) {\n    this.id = nanoid();\n    this.children = [];\n    this.timeout = 800;\n    this.attrs = initAttrs || {};\n  }\n  get cloneChilds() {\n    return clone(this.children);\n  }\n  get index() {\n    return this.parent?.children.findIndex((node) => node.id === this.id);\n  }\n  bind(doc) {\n    this.doc = doc;\n    if (this.doc.controller)\n      this.doc.controller.create(this.id, this.attrs);\n  }\n  setAttributes(values) {\n    for (const key in values)\n      this.set(key, values[key]);\n  }\n  toJSON() {\n    return {\n      id: this.id,\n      attrs: this.attrs,\n      children: this.children.map((item) => item.toJSON())\n    };\n  }\n  set(path, value) {\n    this._set(path, value);\n    if (this.doc?.controller)\n      this.doc.controller.set(this.id, path, value);\n  }\n  _set(path, value) {\n    this.doc.emit(\"set\", { path, value });\n    set(this.attrs, path, value);\n  }\n  insert(node, index) {\n    if (!index && index !== 0)\n      index = this.children.length;\n    this._insert(node, index);\n    if (this.doc?.controller)\n      this.doc.controller.insert(this.id, node.id, index);\n  }\n  _insert(node, index) {\n    node.parent = this;\n    this.doc.emit(\"insert\", { parent: this, child: node, index });\n    this.children.splice(index, 0, node);\n  }\n  remove(index) {\n    const node = this._remove(index);\n    if (this.doc?.controller && node)\n      this.doc.controller.delete(this.id, node.id, index);\n  }\n  _removeNode(node) {\n    this.children.splice(this.children.findIndex((item) => item.id === node.id), 1);\n  }\n  _remove(index) {\n    const removeBlock = this.children.splice(index, 1)[0];\n    const { doc } = this;\n    function traverse2(node) {\n      if (!node)\n        return;\n      doc.blockMap.delete(node.id);\n      doc.emit(\"remove\", { node });\n      node.parent = null;\n      node.children.forEach(traverse2);\n    }\n    traverse2(removeBlock);\n    return removeBlock;\n  }\n  findById(id) {\n    for (const VirtualNode2 of this.children) {\n      if (VirtualNode2.id === id)\n        return VirtualNode2;\n      if (VirtualNode2.findById(id))\n        return VirtualNode2.findById(id);\n    }\n  }\n  contains(VirtualNode2) {\n    return this.id === VirtualNode2.id || !!this.findById(VirtualNode2.id);\n  }\n  findByAttrs(filter) {\n    const blocks = [];\n    for (const VirtualNode2 of this.children) {\n      if (filter(VirtualNode2.attrs))\n        blocks.push(VirtualNode2);\n      blocks.push(...VirtualNode2.findByAttrs(filter));\n    }\n    return blocks;\n  }\n};\n\n// src/document/document.ts\nvar VirtualDocument = class extends EventEmitter {\n  constructor(initAttrs, id = nanoid2()) {\n    super();\n    this.id = id;\n    this.blockMap = /* @__PURE__ */ new Map();\n    this.data = {};\n    this.root = this.createNode(initAttrs, \"root\");\n  }\n  get(id) {\n    return this.blockMap.get(id);\n  }\n  bind(controller) {\n    this.controller = controller;\n    this.root.bind(this);\n  }\n  clean() {\n    this.blockMap.forEach((v, k, m) => {\n      if (!v.parent)\n        m.delete(k);\n    });\n  }\n  createNode(initAttrs, id) {\n    const node = new VirtualNode(initAttrs);\n    id && (node.id = id);\n    node.bind(this);\n    if (id === \"root\")\n      this.root = node;\n    this.blockMap.set(node.id, node);\n    this.emit(\"create\", id);\n    return node;\n  }\n  _createNode(initAttrs, id) {\n    if (id && this.blockMap.has(id))\n      return this.blockMap.get(id);\n    const node = new VirtualNode(initAttrs);\n    id && (node.id = id);\n    node.doc = this;\n    if (id === \"root\")\n      this.root = node;\n    this.blockMap.set(node.id, node);\n    this.emit(\"create\", id);\n    return node;\n  }\n  removeNode(node) {\n    if (node.parent) {\n      node.parent.remove(node.index);\n      this.blockMap.delete(node.id);\n    }\n  }\n  _removeNode(node) {\n    if (node.parent) {\n      node.parent._remove(node.index);\n      this.blockMap.delete(node.id);\n    } else {\n      this.blockMap.delete(node.id);\n    }\n  }\n  select(node, type = \"activeNode\") {\n    return this[type] = node;\n  }\n  cancel(type = \"activeNode\") {\n    return this[type] = void 0;\n  }\n  load(data) {\n    const that = this;\n    function traverse2(data2) {\n      const node = that.createNode(data2.attrs, data2.id);\n      data2.children.forEach((item, i) => {\n        const child = traverse2(item);\n        node.insert(child, i);\n      });\n      return node;\n    }\n    if (this.controller) {\n      this.controller.ydoc.transact(() => {\n        this.root = traverse2(data);\n      });\n    } else {\n      this.root = traverse2(data);\n    }\n    return this;\n  }\n  transact(cb, origin) {\n    if (this.controller)\n      this.controller.ydoc.transact(cb, origin);\n  }\n};\nfunction observeDoc(doc) {\n  const fn = (events, t) => {\n    let tasks = [];\n    events.forEach((event) => {\n      if (!t.local || t.origin instanceof UndoManager) {\n        if (event.changes.keys.size === 0) {\n          event.changes.deleted.forEach((item) => {\n            const parent = doc.get(event.path[0]);\n            const id = item.content.getContent()[0];\n            const node = doc.get(id);\n            if (node)\n              parent._removeNode(node);\n          });\n          event.changes.added.forEach((item) => {\n            const id = item.content.getContent()[0];\n            const node = doc.get(id);\n            if (item.left) {\n              const left = doc.get(item.left.content.getContent()[0]);\n              left.parent._insert(node, left.index + 1);\n            } else {\n              const parent = doc.get(event.path[0]);\n              parent._insert(node, 0);\n            }\n          });\n        } else {\n          event.changes.keys.forEach((item, i) => {\n            const obj = event.target.get(i);\n            switch (item.action) {\n              case \"add\":\n                if (obj instanceof YMap) {\n                  if (obj.has(\"_is_node\")) {\n                    const attrs = obj.toJSON();\n                    const node = doc._createNode(omit(attrs, [\"children\"]), i);\n                    if (attrs.children.length) {\n                      tasks.push(() => {\n                        attrs.children.forEach((k, i2) => {\n                          node._insert(doc.get(k), i2);\n                        });\n                      });\n                    }\n                  } else {\n                    const path = [...event.path.slice(1), i].join(\".\");\n                    doc.get(event.path[0])?._set(path, obj.toJSON());\n                  }\n                } else {\n                  const path = [...event.path.slice(1), i].join(\".\");\n                  doc.get(event.path[0])?._set(path, obj);\n                }\n                break;\n              case \"delete\":\n                if (item.oldValue instanceof YMap) {\n                  doc._removeNode(doc.get(i));\n                } else {\n                  const path = [...event.path.slice(1), i].join(\".\");\n                  doc.get(event.path[0])?._set(path, obj);\n                }\n                break;\n              case \"update\":\n                if (obj instanceof YMap) {\n                  if (obj.has(\"_is_node\")) {\n                    const attrs = obj.toJSON();\n                    if (attrs.children.length) {\n                      tasks.push(() => {\n                        attrs.children.forEach((k, i2) => {\n                          doc.get(attrs.id)._insert(doc.get(k), i2);\n                        });\n                      });\n                    }\n                  } else {\n                    doc.get(event.path[0])?._set(\n                      [...event.path.slice(1), i].join(\".\"),\n                      obj.toJSON()\n                    );\n                  }\n                } else {\n                  doc.get(event.path[0])?._set(\n                    [...event.path.slice(1), i].join(\".\"),\n                    obj\n                  );\n                }\n            }\n          });\n        }\n        tasks.forEach((task) => task());\n        tasks = [];\n      }\n    });\n  };\n  doc.controller.map.observeDeep(fn);\n  return () => {\n    doc.controller.map.unobserveDeep(fn);\n  };\n}\n\n// src/document/controller.ts\nimport { Doc, UndoManager as UndoManager2, Array as YArray, Map as YMap2 } from \"/node_modules/.vite/deps/yjs.js?v=4de675e4\";\nvar Controller = class {\n  constructor(options = {}) {\n    this.options = options;\n    this.ydoc = new Doc();\n    this.map = this.ydoc.getMap(\"nodes\");\n    this.manager = new UndoManager2(this.map, this.options);\n  }\n  toJSON() {\n    return this.map.toJSON();\n  }\n  undo() {\n    this.manager.undo();\n  }\n  redo() {\n    this.manager.redo();\n  }\n  create(id, data) {\n    this.ydoc.transact(() => {\n      const map = traverse({ ...data, id, _is_node: true });\n      map.set(\"children\", new YArray());\n      this.map.set(id, map);\n    });\n  }\n  insert(parent, child, index) {\n    this.ydoc.transact(() => {\n      const arr = this.map.get(parent).get(\"children\");\n      arr.insert(index, [child]);\n    });\n  }\n  delete(parent, child, index) {\n    this.ydoc.transact(() => {\n      const arr = this.map.get(parent).get(\"children\");\n      arr.delete(index, 1);\n      this.map.delete(child);\n    });\n  }\n  set(id, path, value) {\n    const map = this.map.get(id);\n    const paths = path.split(\".\");\n    let structure = map;\n    const key = paths.pop();\n    paths.forEach((p) => {\n      structure = structure.get(p);\n    });\n    this.ydoc.transact(() => {\n    });\n    structure.set(key, traverse(value));\n  }\n};\nfunction traverse(value) {\n  if (Array.isArray(value))\n    return YArray.from(value.map(traverse));\n  if (typeof value === \"object\") {\n    const obj = {};\n    for (const i in value)\n      obj[i] = traverse(value[i]);\n    return new YMap2(Object.entries(obj));\n  }\n  return value;\n}\n\n// src/utils/index.ts\nfunction getQuery(key) {\n  return new URLSearchParams(location.search).get(key);\n}\nfunction draggable(opts, dom = window) {\n  let element;\n  const moveEvent = (e) => {\n    opts.move?.(e);\n  };\n  const upEvent = (e) => {\n    opts.up?.(e);\n    element.removeEventListener(\"mousemove\", moveEvent);\n    element.removeEventListener(\"mouseup\", upEvent);\n  };\n  if (typeof dom === \"string\")\n    element = document.querySelector(dom);\n  else\n    element = dom;\n  element.addEventListener(\"mousemove\", moveEvent);\n  element.addEventListener(\"mouseup\", upEvent);\n}\n\n// src/model/baseDocModel.ts\nimport { Global, Init, Tag } from \"http://localhost:4010/phecda-vue.mjs\";\nvar BaseDocModel = class {\n  constructor() {\n    this.containerAttrs = {};\n    this.doc = new VirtualDocument({}, \"model\");\n  }\n  _init() {\n    window.$alioth_container = (attr) => this.containerAttrs = attr;\n  }\n  get activePage() {\n    return this.find(this.activeId);\n  }\n  get activeNode() {\n    return this.doc.activeNode;\n  }\n  get pages() {\n    return this.doc.root.children;\n  }\n  active(id) {\n    if (this.activeId === id)\n      return;\n    if (this.doc.root.children.some((item) => item.id === id))\n      this.activeId = id;\n  }\n  add(id) {\n    const node = this.doc.createNode(this.containerAttrs, id);\n    this.doc.root.insert(node);\n    return node;\n  }\n  remove(id) {\n    const { children } = this.doc.root;\n    const index = children.findIndex((item) => item.id === id);\n    this.doc.root.remove(index);\n    if (children.length > 1)\n      this.activeId = children[index - 1].id;\n    else\n      this.activeId = \"\";\n  }\n  find(id) {\n    return this.doc.root.children.find((item) => item.id === id);\n  }\n  index(id) {\n    return this.doc.root.children.findIndex((item) => id === item.id);\n  }\n  load(data) {\n    data = typeof data === \"string\" ? JSON.parse(data) : data;\n    this.doc.load(data);\n  }\n  toJSON() {\n    return this.doc.root;\n  }\n};\n__decorateClass([\n  Init\n], BaseDocModel.prototype, \"_init\", 1);\nBaseDocModel = __decorateClass([\n  Global,\n  Tag(\"doc\")\n], BaseDocModel);\n\n// src/model/baseDragModel.ts\nimport { Global as Global2, Tag as Tag2 } from \"http://localhost:4010/phecda-vue.mjs\";\nvar dragenter = (e) => {\n  e.dataTransfer.dropEffect = \"move\";\n};\nvar dragover = (e) => {\n  e.preventDefault();\n};\nvar dragleave = (e) => {\n  e.dataTransfer.dropEffect = \"none\";\n};\nvar BaseDragModel = class {\n  constructor() {\n    this.moduleMap = /* @__PURE__ */ new Map();\n    this.data = {};\n  }\n  add(el, cb) {\n    this.moduleMap.set(el, cb);\n  }\n  del(el) {\n    this.moduleMap.delete(el);\n  }\n  execCb(el, data, e) {\n    this.moduleMap.get(el)?.(data, e);\n  }\n  dragStart(data) {\n    this.listenController = new AbortController();\n    const { signal } = this.listenController;\n    for (const [el] of this.moduleMap) {\n      el.addEventListener(\"dragenter\", dragenter, { signal });\n      el.addEventListener(\"dragover\", dragover, { signal });\n      el.addEventListener(\"dragleave\", dragleave, { signal });\n      el.addEventListener(\"drop\", (e) => {\n        this.execCb(el, data, e);\n      }, { signal });\n    }\n  }\n  dragEnd() {\n    this.listenController.abort();\n    this.listenController = void 0;\n  }\n};\nBaseDragModel = __decorateClass([\n  Global2,\n  Tag2(\"drag\")\n], BaseDragModel);\n\n// src/model/baseEventModel.ts\nimport { Global as Global3, Tag as Tag3 } from \"http://localhost:4010/phecda-vue.mjs\";\nvar { register, initialize, state } = createEventStack({ undo: true, redo: true });\nvar BaseEventModel = class {\n  constructor() {\n    this.state = state;\n    this.register = register;\n    window.$alioth_eventStack = register;\n    initialize();\n  }\n};\nBaseEventModel = __decorateClass([\n  Global3,\n  Tag3(\"event\")\n], BaseEventModel);\n\n// src/model/baseImportModel.ts\nimport { Global as Global4, Init as Init2, Tag as Tag4 } from \"http://localhost:4010/phecda-vue.mjs\";\nvar { connect, dynamicImport, urlMap, projectMap } = createConnector();\nvar BaseImportModel = class {\n  constructor() {\n    this.graph = {};\n  }\n  _init() {\n    window.$alioth_update = (url, module) => {\n      this.graph[url.split(\"?\")[0]] = this.importModule(module);\n    };\n    window.$alioth_state = (arg) => this.setState?.(arg);\n  }\n  async connectVite(url) {\n    await connect(url);\n    for (const [project, entries] of projectMap.entries()) {\n      for (const entry in entries) {\n        const { module, url: url2 } = await dynamicImport(project, entry);\n        this.graph[url2] = this.importModule(module);\n      }\n    }\n  }\n  async connectPreset(presets) {\n    presets.forEach(async (url) => {\n      try {\n        const module = await loadStyleOrScript(url);\n        if (!url.endsWith(\".css\"))\n          this.graph[url] = this.importModule(module);\n        else\n          this.graph[url] = {};\n      } catch (e) {\n        window.$alioth_error(\"LoadError\", `load dependence ${url} failed`);\n      }\n    });\n  }\n  importModule(module) {\n    const exportsMap = {};\n    for (const exports in module) {\n      if (typeof module[exports] === \"object\" && module[exports].alioth) {\n        const { alioth: type, data } = module[exports];\n        window[`$alioth_${type}`]?.(data);\n        exportsMap[exports] = module[exports];\n      }\n    }\n    return exportsMap;\n  }\n};\n__decorateClass([\n  Init2\n], BaseImportModel.prototype, \"_init\", 1);\nBaseImportModel = __decorateClass([\n  Global4,\n  Tag4(\"import\")\n], BaseImportModel);\n\n// src/model/baseCommandModel.ts\nimport { Global as Global5, Init as Init3, Tag as Tag5 } from \"http://localhost:4010/phecda-vue.mjs\";\nvar BaseCommandModel = class {\n  constructor() {\n    this.commands = [];\n  }\n  _init() {\n    window.$alioth_command = this.register.bind(this);\n  }\n  register(command) {\n    this.commands.push(command);\n  }\n  input(key, arg) {\n    return this.commands.find((item) => item.key === key)?.exec(arg);\n  }\n};\n__decorateClass([\n  Init3\n], BaseCommandModel.prototype, \"_init\", 1);\nBaseCommandModel = __decorateClass([\n  Global5,\n  Tag5(\"command\")\n], BaseCommandModel);\n\n// src/model/baseErrorModel.ts\nimport { Global as Global6, Init as Init4, Tag as Tag6, Watcher } from \"http://localhost:4010/phecda-vue.mjs\";\nvar BaseErrorModel = class {\n  _init() {\n    window.$alioth_error = this.setErrorHandler.bind(this);\n  }\n  setErrorHandler(handler) {\n    this.errorHandlers.push(handler);\n  }\n  watchError({ error, type }) {\n    const handler = this.errorHandlers.find((item) => item.type === type);\n    if (handler)\n      handler.handler(error);\n    else\n      console.error(`[Alioth]: ${type}`);\n  }\n};\n__decorateClass([\n  Init4\n], BaseErrorModel.prototype, \"_init\", 1);\n__decorateClass([\n  Watcher(\"custom_error\")\n], BaseErrorModel.prototype, \"watchError\", 1);\nBaseErrorModel = __decorateClass([\n  Global6,\n  Tag6(\"error\")\n], BaseErrorModel);\nexport {\n  BaseCommandModel,\n  BaseDocModel,\n  BaseDragModel,\n  BaseErrorModel,\n  BaseEventModel,\n  BaseImportModel,\n  Controller,\n  VirtualDocument,\n  VirtualNode,\n  connect,\n  createConnector,\n  createEventStack,\n  detect,\n  draggable,\n  dynamicImport,\n  getQuery,\n  loadJSON,\n  loadPresets,\n  loadStyleOrScript,\n  observeDoc,\n  projectMap,\n  urlMap\n};\n                                  ",
      "start": 1699405180658,
      "end": 1699405180684,
      "order": "normal",
      "sourcemaps": null
    }
  ]
}
