{
  "resolvedId": "D:/MyProject/5/alioth/node_modules/.pnpm/@vexip-ui+hooks@1.11.4_vue@3.3.4/node_modules/@vexip-ui/hooks/dist/index.mjs",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "import { watch as fe, unref as D, getCurrentScope as Ye, onScopeDispose as Ue, ref as P, onMounted as _e, nextTick as ze, onBeforeUnmount as ve, computed as _, customRef as Sr, reactive as kt, readonly as kr, isRef as Ze, watchEffect as Rr, renderSlot as Tr } from \"vue\";\nconst oe = typeof window < \"u\";\nvar Rt;\noe && ((Rt = window == null ? void 0 : window.navigator) != null && Rt.userAgent) && /iP(ad|hone|od)/.test(window.navigator.userAgent);\nfunction nt(e) {\n  return e != null;\n}\nfunction F() {\n}\nconst zr = Object.freeze({\n  aliceblue: \"f0f8ff\",\n  antiquewhite: \"faebd7\",\n  aqua: \"0ff\",\n  aquamarine: \"7fffd4\",\n  azure: \"f0ffff\",\n  beige: \"f5f5dc\",\n  bisque: \"ffe4c4\",\n  black: \"000\",\n  blanchedalmond: \"ffebcd\",\n  blue: \"00f\",\n  blueviolet: \"8a2be2\",\n  brown: \"a52a2a\",\n  burlywood: \"deb887\",\n  burntsienna: \"ea7e5d\",\n  cadetblue: \"5f9ea0\",\n  chartreuse: \"7fff00\",\n  chocolate: \"d2691e\",\n  coral: \"ff7f50\",\n  cornflowerblue: \"6495ed\",\n  cornsilk: \"fff8dc\",\n  crimson: \"dc143c\",\n  cyan: \"0ff\",\n  darkblue: \"00008b\",\n  darkcyan: \"008b8b\",\n  darkgoldenrod: \"b8860b\",\n  darkgray: \"a9a9a9\",\n  darkgreen: \"006400\",\n  darkgrey: \"a9a9a9\",\n  darkkhaki: \"bdb76b\",\n  darkmagenta: \"8b008b\",\n  darkolivegreen: \"556b2f\",\n  darkorange: \"ff8c00\",\n  darkorchid: \"9932cc\",\n  darkred: \"8b0000\",\n  darksalmon: \"e9967a\",\n  darkseagreen: \"8fbc8f\",\n  darkslateblue: \"483d8b\",\n  darkslategray: \"2f4f4f\",\n  darkslategrey: \"2f4f4f\",\n  darkturquoise: \"00ced1\",\n  darkviolet: \"9400d3\",\n  deeppink: \"ff1493\",\n  deepskyblue: \"00bfff\",\n  dimgray: \"696969\",\n  dimgrey: \"696969\",\n  dodgerblue: \"1e90ff\",\n  firebrick: \"b22222\",\n  floralwhite: \"fffaf0\",\n  forestgreen: \"228b22\",\n  fuchsia: \"f0f\",\n  gainsboro: \"dcdcdc\",\n  ghostwhite: \"f8f8ff\",\n  gold: \"ffd700\",\n  goldenrod: \"daa520\",\n  gray: \"808080\",\n  green: \"008000\",\n  greenyellow: \"adff2f\",\n  grey: \"808080\",\n  honeydew: \"f0fff0\",\n  hotpink: \"ff69b4\",\n  indianred: \"cd5c5c\",\n  indigo: \"4b0082\",\n  ivory: \"fffff0\",\n  khaki: \"f0e68c\",\n  lavender: \"e6e6fa\",\n  lavenderblush: \"fff0f5\",\n  lawngreen: \"7cfc00\",\n  lemonchiffon: \"fffacd\",\n  lightblue: \"add8e6\",\n  lightcoral: \"f08080\",\n  lightcyan: \"e0ffff\",\n  lightgoldenrodyellow: \"fafad2\",\n  lightgray: \"d3d3d3\",\n  lightgreen: \"90ee90\",\n  lightgrey: \"d3d3d3\",\n  lightpink: \"ffb6c1\",\n  lightsalmon: \"ffa07a\",\n  lightseagreen: \"20b2aa\",\n  lightskyblue: \"87cefa\",\n  lightslategray: \"789\",\n  lightslategrey: \"789\",\n  lightsteelblue: \"b0c4de\",\n  lightyellow: \"ffffe0\",\n  lime: \"0f0\",\n  limegreen: \"32cd32\",\n  linen: \"faf0e6\",\n  magenta: \"f0f\",\n  maroon: \"800000\",\n  mediumaquamarine: \"66cdaa\",\n  mediumblue: \"0000cd\",\n  mediumorchid: \"ba55d3\",\n  mediumpurple: \"9370db\",\n  mediumseagreen: \"3cb371\",\n  mediumslateblue: \"7b68ee\",\n  mediumspringgreen: \"00fa9a\",\n  mediumturquoise: \"48d1cc\",\n  mediumvioletred: \"c71585\",\n  midnightblue: \"191970\",\n  mintcream: \"f5fffa\",\n  mistyrose: \"ffe4e1\",\n  moccasin: \"ffe4b5\",\n  navajowhite: \"ffdead\",\n  navy: \"000080\",\n  oldlace: \"fdf5e6\",\n  olive: \"808000\",\n  olivedrab: \"6b8e23\",\n  orange: \"ffa500\",\n  orangered: \"ff4500\",\n  orchid: \"da70d6\",\n  palegoldenrod: \"eee8aa\",\n  palegreen: \"98fb98\",\n  paleturquoise: \"afeeee\",\n  palevioletred: \"db7093\",\n  papayawhip: \"ffefd5\",\n  peachpuff: \"ffdab9\",\n  peru: \"cd853f\",\n  pink: \"ffc0cb\",\n  plum: \"dda0dd\",\n  powderblue: \"b0e0e6\",\n  purple: \"800080\",\n  rebeccapurple: \"663399\",\n  red: \"f00\",\n  rosybrown: \"bc8f8f\",\n  royalblue: \"4169e1\",\n  saddlebrown: \"8b4513\",\n  salmon: \"fa8072\",\n  sandybrown: \"f4a460\",\n  seagreen: \"2e8b57\",\n  seashell: \"fff5ee\",\n  sienna: \"a0522d\",\n  silver: \"c0c0c0\",\n  skyblue: \"87ceeb\",\n  slateblue: \"6a5acd\",\n  slategray: \"708090\",\n  slategrey: \"708090\",\n  snow: \"fffafa\",\n  springgreen: \"00ff7f\",\n  steelblue: \"4682b4\",\n  tan: \"d2b48c\",\n  teal: \"008080\",\n  thistle: \"d8bfd8\",\n  tomato: \"ff6347\",\n  turquoise: \"40e0d0\",\n  violet: \"ee82ee\",\n  wheat: \"f5deb3\",\n  white: \"fff\",\n  whitesmoke: \"f5f5f5\",\n  yellow: \"ff0\",\n  yellowgreen: \"9acd32\"\n});\nObject.freeze(new Set(Object.keys(zr)));\nfunction Tt(e) {\n  return e & -e;\n}\nfunction Br(e, t = 0) {\n  const r = new Array(e + 1).fill(0);\n  function n(i, s) {\n    if (!(!s || i >= e))\n      for (i += 1; i <= e; )\n        r[i] += s, i += Tt(i);\n  }\n  function o(i = e) {\n    if (i <= 0)\n      return 0;\n    i > e && (i = e);\n    let s = i * t;\n    for (; i > 0; )\n      s += r[i], i -= Tt(i);\n    return s;\n  }\n  function a(i) {\n    return o(i + 1) - o(i);\n  }\n  function c(i) {\n    let s = 0, u = e;\n    for (; u > s; ) {\n      const f = Math.floor((s + u) / 2), h = o(f);\n      if (h > i) {\n        u = f;\n        continue;\n      } else if (h < i) {\n        if (s === f)\n          return o(s + 1) <= i ? s + 1 : s;\n        s = f;\n      } else\n        return f;\n    }\n    return s;\n  }\n  return { add: n, sum: o, get: a, boundIndex: c };\n}\nfunction Mr(e) {\n  const t = parseFloat(e);\n  return Number.isNaN(t) ? 0 : t;\n}\nconst Ar = oe && (\"ontouchstart\" in window || Dr() > 0), Pr = Ar ? \"pointerdown\" : \"click\";\nfunction Dr() {\n  return typeof navigator < \"u\" && (navigator.maxTouchPoints || navigator.msMaxTouchPoints) || 0;\n}\nconst J = /* @__PURE__ */ new Map();\nfunction Cr(e) {\n  J.has(e) || J.set(e, /* @__PURE__ */ new Set());\n}\nfunction Lr(e) {\n  return J.get(e) ?? J.set(e, /* @__PURE__ */ new Set()).get(e);\n}\nfunction Wr(e, t) {\n  if (typeof t == \"string\" && (t = [t]), Array.isArray(t))\n    for (let r = 0, n = t.length; r < n; ++r) {\n      const o = t[r];\n      J.has(o) || J.set(o, /* @__PURE__ */ new Set()), J.get(o).add(e);\n    }\n}\nfunction Fr(e, t) {\n  var r;\n  if (typeof t == \"string\" && (t = [t]), Array.isArray(t))\n    for (let n = 0, o = t.length; n < o; ++n) {\n      const a = t[n];\n      J.has(a) && ((r = J.get(a)) == null || r.delete(e));\n    }\n}\nfunction jr(e, t, r = window.Event) {\n  const { type: n, bubbles: o = !1, cancelable: a = !1, ...c } = t;\n  if (!nt(n) || n === \"\")\n    return !1;\n  let i;\n  return nt(r) ? i = new r(n, { bubbles: o, cancelable: a }) : (i = document.createEvent(\"HTMLEvents\"), i.initEvent(n, o, a)), Object.assign(i, c), e.dispatchEvent(i);\n}\nfunction Kt(e, t = 16) {\n  if (typeof e != \"function\")\n    return e;\n  let r = Date.now(), n;\n  return function(...o) {\n    const a = Date.now(), c = r + t - a;\n    clearTimeout(n), c <= 0 ? (e(...o), r = Date.now()) : n = setTimeout(() => {\n      e(...o);\n    }, t);\n  };\n}\nconst Se = /* @__PURE__ */ new Set(), Gt = /* @__PURE__ */ new WeakMap();\nfunction $r() {\n  Se.forEach((e) => {\n    e(...Gt.get(e));\n  }), Se.clear();\n}\nfunction Hr(e, ...t) {\n  if (typeof e != \"function\")\n    return e;\n  Gt.set(e, t), !Se.has(e) && (Se.add(e), Se.size === 1 && requestAnimationFrame($r));\n}\nfunction Ir(e) {\n  return Array.isArray(e) ? e : [e];\n}\nfunction Q(e, t, r, n) {\n  if (!e)\n    return F;\n  let o = F;\n  const a = fe(\n    () => D(e),\n    (i) => {\n      o(), i && (i.addEventListener(t, r, n), o = () => {\n        i.removeEventListener(t, r, n), o = F;\n      });\n    },\n    { immediate: !0, flush: \"post\" }\n  ), c = () => {\n    a(), o();\n  };\n  return Ye() && Ue(c), c;\n}\nconst he = \"clickoutside\";\nCr(he);\noe && document.addEventListener(\n  Pr,\n  (e) => {\n    const t = e.target, r = e.composedPath && e.composedPath();\n    Lr(he).forEach((n) => {\n      n !== t && (r ? !r.includes(n) : !n.contains(t)) && (!n.__transferElement || n.__transferElement !== t && !n.__transferElement.contains(t)) && jr(n, { type: he });\n    });\n  },\n  !0\n);\nfunction Bo(e, t = P(null)) {\n  let r = F;\n  const n = fe(\n    () => D(t),\n    (a) => {\n      r(), a && (Wr(a, he), r = () => {\n        Fr(a, he), r = F;\n      });\n    },\n    { immediate: !0, flush: \"post\" }\n  ), o = () => {\n    n(), r();\n  };\n  return Ye() && Ue(o), Q(t, he, e), t;\n}\nfunction Mo(e = F, t = P(null)) {\n  let r;\n  return _e(() => {\n    ze(() => {\n      const n = Jt(t.value);\n      n ? (r = new MutationObserver(() => {\n        n.style.display !== \"none\" && (typeof e == \"function\" && e(), r == null || r.disconnect(), r = null);\n      }), r.observe(n, {\n        attributes: !0,\n        childList: !0,\n        characterData: !0,\n        attributeFilter: [\"style\"]\n      })) : typeof e == \"function\" && e();\n    });\n  }), ve(() => {\n    r == null || r.disconnect(), r = null;\n  }), t;\n}\nfunction Jt(e) {\n  if (e) {\n    let t = e.parentElement;\n    for (; t && t !== document.body; ) {\n      if (t.style.display === \"none\")\n        return t;\n      t = t.parentElement;\n    }\n  }\n  return null;\n}\nfunction zt(e) {\n  return (e == null ? void 0 : e.style.display) !== \"none\" ? !!Jt(e) : !0;\n}\nconst Nr = [\n  [\n    \"requestFullscreen\",\n    \"exitFullscreen\",\n    \"fullscreenElement\",\n    \"fullscreenEnabled\",\n    \"fullscreenchange\",\n    \"fullscreenerror\"\n  ],\n  // New WebKit\n  [\n    \"webkitRequestFullscreen\",\n    \"webkitExitFullscreen\",\n    \"webkitFullscreenElement\",\n    \"webkitFullscreenEnabled\",\n    \"webkitfullscreenchange\",\n    \"webkitfullscreenerror\"\n  ],\n  // Old WebKit\n  [\n    \"webkitRequestFullScreen\",\n    \"webkitCancelFullScreen\",\n    \"webkitCurrentFullScreenElement\",\n    \"webkitCancelFullScreen\",\n    \"webkitfullscreenchange\",\n    \"webkitfullscreenerror\"\n  ],\n  [\n    \"mozRequestFullScreen\",\n    \"mozCancelFullScreen\",\n    \"mozFullScreenElement\",\n    \"mozFullScreenEnabled\",\n    \"mozfullscreenchange\",\n    \"mozfullscreenerror\"\n  ],\n  [\n    \"msRequestFullscreen\",\n    \"msExitFullscreen\",\n    \"msFullscreenElement\",\n    \"msFullscreenEnabled\",\n    \"MSFullscreenChange\",\n    \"MSFullscreenError\"\n  ]\n];\nlet ge;\nif (oe) {\n  for (const e of Nr)\n    if (e[1] in document) {\n      ge = e;\n      break;\n    }\n}\nconst ot = !!ge, qr = {\n  supported: ot,\n  full: _(() => !1),\n  enter: F,\n  exit: F,\n  toggle: F\n}, Qt = /* @__PURE__ */ new Set();\nif (oe && ge) {\n  const e = ge[2], t = ge[4];\n  document.addEventListener(\n    t,\n    () => {\n      const r = !!document[e];\n      Qt.forEach((n) => {\n        n.value = r;\n      });\n    },\n    !1\n  );\n}\nfunction Ao(e = P(null)) {\n  if (!oe || !ot)\n    return { ...qr };\n  const [t, r, n] = ge, o = P(!1);\n  async function a(s = !1) {\n    await c(), e.value && (s || !document[n]) && (await e.value[t](), o.value = !0);\n  }\n  async function c(s = !1) {\n    (s || document[n] && document[n] === e.value) && (await document[r](), o.value = !1);\n  }\n  async function i(s = !1) {\n    o.value ? await c(s) : await a(s);\n  }\n  return Qt.add(o), Ye() && Ue(c), {\n    supported: ot,\n    target: e,\n    full: _(() => o.value),\n    enter: a,\n    exit: c,\n    toggle: i\n  };\n}\nfunction Po(e = P(null)) {\n  const t = P(!1);\n  Q(e, \"mouseenter\", r), Q(e, \"mouseleave\", n);\n  function r() {\n    t.value = !0;\n  }\n  function n() {\n    t.value = !1;\n  }\n  return { wrapper: e, isHover: t };\n}\nconst Fe = /* @__PURE__ */ new WeakMap(), Xr = /\\s+/g, Vr = /(px|%)$/;\nfunction Do(e) {\n  const t = e.target || P(null);\n  if (!oe)\n    return { target: t, disconnect: F };\n  const { handler: r } = e;\n  let n = e.root ?? document;\n  const o = Ir(e.threshold || 0).join() || \"0\", a = g(e.rootMargin);\n  Fe.has(n) || Fe.set(n, /* @__PURE__ */ new Map());\n  const c = Fe.get(n);\n  c.has(o) || c.set(o, /* @__PURE__ */ new Map());\n  const i = c.get(o);\n  i.has(a) || i.set(a, {\n    ob: new IntersectionObserver(w, { ...e, rootMargin: a }),\n    count: 0,\n    handlers: /* @__PURE__ */ new WeakMap()\n  });\n  let s = i.get(a), { ob: u, handlers: f } = s, h = F;\n  const y = fe(\n    () => D(t),\n    (l) => {\n      h(), !(!l || !u) && (f.set(l, r), u.observe(l), s && s.count++, h = () => {\n        u.unobserve(l), f.delete(l), s && s.count--, h = F;\n      });\n    },\n    { immediate: !0, flush: \"post\" }\n  );\n  Ye() && Ue(d);\n  function g(l) {\n    if (!l || !l.trim())\n      return \"_\";\n    const p = l.trim().split(Xr, 4);\n    p.length = 4;\n    for (let b = 0; b < 4; ++b) {\n      const x = p[b];\n      p[b] = Vr.test(x) ? x : `${Mr(x)}px`;\n    }\n    return p.join(\" \");\n  }\n  function w(l) {\n    for (let p = 0, b = l.length; p < b; ++p) {\n      const x = l[p], m = f.get(x.target);\n      typeof m == \"function\" && m(x);\n    }\n  }\n  function d() {\n    y(), h(), s && (s.count <= 0 && (i.delete(a), i.size || (c.delete(o), c.size || Fe.delete(n))), s = void 0, u = void 0, f = void 0, n = void 0);\n  }\n  return { target: t, disconnect: d };\n}\nfunction Co() {\n  const e = /* @__PURE__ */ new Set();\n  function t(n) {\n    return Sr((o, a) => {\n      let c = n;\n      const i = () => {\n        n !== c && (c = n, a());\n      };\n      return {\n        // eslint-disable-next-line no-sequences\n        get: () => (o(), n),\n        set: (s) => {\n          s !== n && (n = s, e.add(i));\n        }\n      };\n    });\n  }\n  function r() {\n    for (const n of e)\n      n();\n    e.clear();\n  }\n  return { updateSet: e, manualRef: t, triggerUpdate: r };\n}\nconst Yr = {\n  ctrl: \"control\",\n  command: \"meta\",\n  cmd: \"meta\",\n  option: \"alt\",\n  up: \"arrowup\",\n  down: \"arrowdown\",\n  left: \"arrowleft\",\n  right: \"arrowright\"\n}, Ur = /[+_-]/, _r = /[+_-]/g, Kr = [\"activeKeys\", \"resetAll\"];\nfunction Lo(e = {}) {\n  const {\n    autoReset: t = !0,\n    capture: r = !1,\n    passive: n = !0,\n    onKeyDown: o = F,\n    onKeyUp: a = F\n  } = e, c = e.target || P(null), i = { ...Yr, ...e.aliasMap || {} }, s = kt(/* @__PURE__ */ new Set()), u = /* @__PURE__ */ new Set(), f = kt({ activeKeys: s, resetAll: g });\n  function h(d, l) {\n    d in f && (f[d] = l);\n  }\n  function y(d, l) {\n    var m, O;\n    const p = (m = d.key) == null ? void 0 : m.toLocaleLowerCase(), x = [(O = d.code) == null ? void 0 : O.toLocaleLowerCase(), p].filter(Boolean);\n    for (const E of x)\n      s[l ? \"add\" : \"delete\"](E), h(E, l);\n    if (!l && p === \"meta\") {\n      for (const E of u)\n        s.delete(E), h(E, !1);\n      u.clear();\n    } else if (l && typeof d.getModifierState == \"function\" && d.getModifierState(\"Meta\"))\n      for (const E of [...s, ...x])\n        u.add(E);\n  }\n  function g() {\n    Object.keys(f).forEach((d) => {\n      f[d] = !1;\n    }), f.activeKeys = s, f.resetAll = g;\n  }\n  const w = new Proxy(f, {\n    get(d, l, p) {\n      if (typeof l != \"string\" || Kr.includes(l))\n        return Reflect.get(d, l, p);\n      if (l = l.toLocaleLowerCase(), l in i && (l = i[l]), !(l in f))\n        if (Ur.test(l)) {\n          const b = l.split(_r).map((x) => x.trim());\n          f[l] = _(() => b.every((x) => D(w[x])));\n        } else\n          f[l] = P(s.has(l));\n      return D(Reflect.get(d, l, p));\n    }\n  });\n  return Q(\n    c,\n    \"keydown\",\n    (d) => {\n      y(d, !0), o(d, w);\n    },\n    { capture: r, passive: n }\n  ), Q(\n    c,\n    \"keyup\",\n    (d) => {\n      y(d, !1), a(d, w);\n    },\n    { capture: r, passive: n }\n  ), t && Q(c, \"blur\", g, { capture: r, passive: n }), { target: c, modifier: w };\n}\nfunction Wo(e) {\n  const t = P(!1), r = () => t.value = !0;\n  return _e(() => {\n    e === \"tick\" ? ze(r) : e === \"frame\" ? requestAnimationFrame(r) : r();\n  }), ve(() => {\n    t.value = !1;\n  }), { isMounted: kr(t) };\n}\nfunction et(e) {\n  e.cancelable && (e.stopPropagation(), e.preventDefault());\n}\nfunction Fo(e) {\n  const t = e.target || P(null), r = Ze(e.x) ? e.x : P(0), n = Ze(e.y) ? e.y : P(0), o = Ze(e.lazy) ? e.lazy : P(!1), { capture: a = !0, stopMouse: c = !0, stopTouch: i = !0 } = e, s = P(!1), u = {\n    xStart: 0,\n    yStart: 0,\n    xEnd: 0,\n    yEnd: 0,\n    clientX: 0,\n    clientY: 0,\n    deltaX: 0,\n    deltaY: 0,\n    lazy: !1\n  };\n  let f = 0, h = 0;\n  const y = Kt((p) => {\n    var b;\n    h < f || (l(p), u.lazy || (r.value = u.xEnd, n.value = u.yEnd), (b = e.onMove) == null || b.call(e, u, p));\n  });\n  function g(p) {\n    var b;\n    Object.assign(u, {\n      xStart: r.value,\n      yStart: n.value,\n      xEnd: r.value,\n      yEnd: n.value,\n      clientX: p.clientX,\n      clientY: p.clientY,\n      lazy: o.value\n    }), ((b = e.onStart) == null ? void 0 : b.call(e, u, p)) !== !1 && (document.addEventListener(\"pointermove\", w, { capture: a }), document.addEventListener(\"pointerup\", d, { capture: a }), h = f, s.value = !0);\n  }\n  function w(p) {\n    et(p), y(p);\n  }\n  function d(p) {\n    var b;\n    document.removeEventListener(\"pointermove\", w, { capture: a }), document.removeEventListener(\"pointerup\", d, { capture: a }), l(p), u.lazy && (r.value = u.xEnd, n.value = u.yEnd), s.value = !1, ++f, (b = e.onEnd) == null || b.call(e, u, p);\n  }\n  function l(p) {\n    const { clientX: b, clientY: x } = p, { xStart: m, yStart: O, clientX: E, clientY: R } = u, B = b - E, T = x - R;\n    u.deltaX = B, u.deltaY = T, u.xEnd = m + B, u.yEnd = O + T;\n  }\n  return Q(t, \"pointerdown\", g, { capture: a }), c && Q(t, \"mousedown\", et, { capture: a }), i && Q(t, \"touchstart\", et, { capture: a }), {\n    target: t,\n    moving: _(() => s.value),\n    x: r,\n    y: n,\n    lazy: o\n  };\n}\nconst Be = /* @__PURE__ */ new Set(), ne = /* @__PURE__ */ new Map();\nne.set(\"x\", 0);\nne.set(\"y\", 0);\nfunction Gr(e) {\n  const { pageX: t, pageY: r } = e;\n  ne.set(\"x\", t), ne.set(\"y\", r), Be.forEach((n) => {\n    n.x.value = t, n.y.value = r;\n  });\n}\nconst Zt = Kt(Gr);\nfunction Jr(e) {\n  !Be.size && window && (ne.set(\"x\", 0), ne.set(\"y\", 0), window.addEventListener(\"pointermove\", Zt, { passive: !0 })), Be.add(e);\n}\nfunction Bt(e) {\n  Be.delete(e), !Be.size && window && window.removeEventListener(\"pointermove\", Zt);\n}\nfunction jo(e = {}) {\n  const t = P(e.x ?? ne.get(\"x\")), r = P(e.y ?? ne.get(\"y\")), n = { x: t, y: r };\n  return Jr(n), e.manualStop || ve(() => {\n    Bt(n);\n  }), { ...n, unregister: () => Bt(n) };\n}\nvar j = \"top\", N = \"bottom\", q = \"right\", $ = \"left\", ct = \"auto\", De = [j, N, q, $], be = \"start\", Me = \"end\", Qr = \"clippingParents\", er = \"viewport\", Oe = \"popper\", Zr = \"reference\", Mt = /* @__PURE__ */ De.reduce(function(e, t) {\n  return e.concat([t + \"-\" + be, t + \"-\" + Me]);\n}, []), tr = /* @__PURE__ */ [].concat(De, [ct]).reduce(function(e, t) {\n  return e.concat([t, t + \"-\" + be, t + \"-\" + Me]);\n}, []), en = \"beforeRead\", tn = \"read\", rn = \"afterRead\", nn = \"beforeMain\", on = \"main\", an = \"afterMain\", sn = \"beforeWrite\", cn = \"write\", fn = \"afterWrite\", un = [en, tn, rn, nn, on, an, sn, cn, fn];\nfunction G(e) {\n  return e ? (e.nodeName || \"\").toLowerCase() : null;\n}\nfunction H(e) {\n  if (e == null)\n    return window;\n  if (e.toString() !== \"[object Window]\") {\n    var t = e.ownerDocument;\n    return t && t.defaultView || window;\n  }\n  return e;\n}\nfunction pe(e) {\n  var t = H(e).Element;\n  return e instanceof t || e instanceof Element;\n}\nfunction I(e) {\n  var t = H(e).HTMLElement;\n  return e instanceof t || e instanceof HTMLElement;\n}\nfunction ft(e) {\n  if (typeof ShadowRoot > \"u\")\n    return !1;\n  var t = H(e).ShadowRoot;\n  return e instanceof t || e instanceof ShadowRoot;\n}\nfunction ln(e) {\n  var t = e.state;\n  Object.keys(t.elements).forEach(function(r) {\n    var n = t.styles[r] || {}, o = t.attributes[r] || {}, a = t.elements[r];\n    !I(a) || !G(a) || (Object.assign(a.style, n), Object.keys(o).forEach(function(c) {\n      var i = o[c];\n      i === !1 ? a.removeAttribute(c) : a.setAttribute(c, i === !0 ? \"\" : i);\n    }));\n  });\n}\nfunction dn(e) {\n  var t = e.state, r = {\n    popper: {\n      position: t.options.strategy,\n      left: \"0\",\n      top: \"0\",\n      margin: \"0\"\n    },\n    arrow: {\n      position: \"absolute\"\n    },\n    reference: {}\n  };\n  return Object.assign(t.elements.popper.style, r.popper), t.styles = r, t.elements.arrow && Object.assign(t.elements.arrow.style, r.arrow), function() {\n    Object.keys(t.elements).forEach(function(n) {\n      var o = t.elements[n], a = t.attributes[n] || {}, c = Object.keys(t.styles.hasOwnProperty(n) ? t.styles[n] : r[n]), i = c.reduce(function(s, u) {\n        return s[u] = \"\", s;\n      }, {});\n      !I(o) || !G(o) || (Object.assign(o.style, i), Object.keys(a).forEach(function(s) {\n        o.removeAttribute(s);\n      }));\n    });\n  };\n}\nconst pn = {\n  name: \"applyStyles\",\n  enabled: !0,\n  phase: \"write\",\n  fn: ln,\n  effect: dn,\n  requires: [\"computeStyles\"]\n};\nfunction K(e) {\n  return e.split(\"-\")[0];\n}\nvar ue = Math.max, Xe = Math.min, ye = Math.round;\nfunction it() {\n  var e = navigator.userAgentData;\n  return e != null && e.brands && Array.isArray(e.brands) ? e.brands.map(function(t) {\n    return t.brand + \"/\" + t.version;\n  }).join(\" \") : navigator.userAgent;\n}\nfunction rr() {\n  return !/^((?!chrome|android).)*safari/i.test(it());\n}\nfunction we(e, t, r) {\n  t === void 0 && (t = !1), r === void 0 && (r = !1);\n  var n = e.getBoundingClientRect(), o = 1, a = 1;\n  t && I(e) && (o = e.offsetWidth > 0 && ye(n.width) / e.offsetWidth || 1, a = e.offsetHeight > 0 && ye(n.height) / e.offsetHeight || 1);\n  var c = pe(e) ? H(e) : window, i = c.visualViewport, s = !rr() && r, u = (n.left + (s && i ? i.offsetLeft : 0)) / o, f = (n.top + (s && i ? i.offsetTop : 0)) / a, h = n.width / o, y = n.height / a;\n  return {\n    width: h,\n    height: y,\n    top: f,\n    right: u + h,\n    bottom: f + y,\n    left: u,\n    x: u,\n    y: f\n  };\n}\nfunction ut(e) {\n  var t = we(e), r = e.offsetWidth, n = e.offsetHeight;\n  return Math.abs(t.width - r) <= 1 && (r = t.width), Math.abs(t.height - n) <= 1 && (n = t.height), {\n    x: e.offsetLeft,\n    y: e.offsetTop,\n    width: r,\n    height: n\n  };\n}\nfunction nr(e, t) {\n  var r = t.getRootNode && t.getRootNode();\n  if (e.contains(t))\n    return !0;\n  if (r && ft(r)) {\n    var n = t;\n    do {\n      if (n && e.isSameNode(n))\n        return !0;\n      n = n.parentNode || n.host;\n    } while (n);\n  }\n  return !1;\n}\nfunction Z(e) {\n  return H(e).getComputedStyle(e);\n}\nfunction vn(e) {\n  return [\"table\", \"td\", \"th\"].indexOf(G(e)) >= 0;\n}\nfunction ie(e) {\n  return ((pe(e) ? e.ownerDocument : (\n    // $FlowFixMe[prop-missing]\n    e.document\n  )) || window.document).documentElement;\n}\nfunction Ke(e) {\n  return G(e) === \"html\" ? e : (\n    // this is a quicker (but less type safe) way to save quite some bytes from the bundle\n    // $FlowFixMe[incompatible-return]\n    // $FlowFixMe[prop-missing]\n    e.assignedSlot || // step into the shadow DOM of the parent of a slotted node\n    e.parentNode || // DOM Element detected\n    (ft(e) ? e.host : null) || // ShadowRoot detected\n    // $FlowFixMe[incompatible-call]: HTMLElement is a Node\n    ie(e)\n  );\n}\nfunction At(e) {\n  return !I(e) || // https://github.com/popperjs/popper-core/issues/837\n  Z(e).position === \"fixed\" ? null : e.offsetParent;\n}\nfunction hn(e) {\n  var t = /firefox/i.test(it()), r = /Trident/i.test(it());\n  if (r && I(e)) {\n    var n = Z(e);\n    if (n.position === \"fixed\")\n      return null;\n  }\n  var o = Ke(e);\n  for (ft(o) && (o = o.host); I(o) && [\"html\", \"body\"].indexOf(G(o)) < 0; ) {\n    var a = Z(o);\n    if (a.transform !== \"none\" || a.perspective !== \"none\" || a.contain === \"paint\" || [\"transform\", \"perspective\"].indexOf(a.willChange) !== -1 || t && a.willChange === \"filter\" || t && a.filter && a.filter !== \"none\")\n      return o;\n    o = o.parentNode;\n  }\n  return null;\n}\nfunction Ce(e) {\n  for (var t = H(e), r = At(e); r && vn(r) && Z(r).position === \"static\"; )\n    r = At(r);\n  return r && (G(r) === \"html\" || G(r) === \"body\" && Z(r).position === \"static\") ? t : r || hn(e) || t;\n}\nfunction lt(e) {\n  return [\"top\", \"bottom\"].indexOf(e) >= 0 ? \"x\" : \"y\";\n}\nfunction ke(e, t, r) {\n  return ue(e, Xe(t, r));\n}\nfunction gn(e, t, r) {\n  var n = ke(e, t, r);\n  return n > r ? r : n;\n}\nfunction or() {\n  return {\n    top: 0,\n    right: 0,\n    bottom: 0,\n    left: 0\n  };\n}\nfunction ir(e) {\n  return Object.assign({}, or(), e);\n}\nfunction ar(e, t) {\n  return t.reduce(function(r, n) {\n    return r[n] = e, r;\n  }, {});\n}\nvar mn = function(t, r) {\n  return t = typeof t == \"function\" ? t(Object.assign({}, r.rects, {\n    placement: r.placement\n  })) : t, ir(typeof t != \"number\" ? t : ar(t, De));\n};\nfunction bn(e) {\n  var t, r = e.state, n = e.name, o = e.options, a = r.elements.arrow, c = r.modifiersData.popperOffsets, i = K(r.placement), s = lt(i), u = [$, q].indexOf(i) >= 0, f = u ? \"height\" : \"width\";\n  if (!(!a || !c)) {\n    var h = mn(o.padding, r), y = ut(a), g = s === \"y\" ? j : $, w = s === \"y\" ? N : q, d = r.rects.reference[f] + r.rects.reference[s] - c[s] - r.rects.popper[f], l = c[s] - r.rects.reference[s], p = Ce(a), b = p ? s === \"y\" ? p.clientHeight || 0 : p.clientWidth || 0 : 0, x = d / 2 - l / 2, m = h[g], O = b - y[f] - h[w], E = b / 2 - y[f] / 2 + x, R = ke(m, E, O), B = s;\n    r.modifiersData[n] = (t = {}, t[B] = R, t.centerOffset = R - E, t);\n  }\n}\nfunction yn(e) {\n  var t = e.state, r = e.options, n = r.element, o = n === void 0 ? \"[data-popper-arrow]\" : n;\n  o != null && (typeof o == \"string\" && (o = t.elements.popper.querySelector(o), !o) || nr(t.elements.popper, o) && (t.elements.arrow = o));\n}\nconst wn = {\n  name: \"arrow\",\n  enabled: !0,\n  phase: \"main\",\n  fn: bn,\n  effect: yn,\n  requires: [\"popperOffsets\"],\n  requiresIfExists: [\"preventOverflow\"]\n};\nfunction xe(e) {\n  return e.split(\"-\")[1];\n}\nvar xn = {\n  top: \"auto\",\n  right: \"auto\",\n  bottom: \"auto\",\n  left: \"auto\"\n};\nfunction En(e, t) {\n  var r = e.x, n = e.y, o = t.devicePixelRatio || 1;\n  return {\n    x: ye(r * o) / o || 0,\n    y: ye(n * o) / o || 0\n  };\n}\nfunction Pt(e) {\n  var t, r = e.popper, n = e.popperRect, o = e.placement, a = e.variation, c = e.offsets, i = e.position, s = e.gpuAcceleration, u = e.adaptive, f = e.roundOffsets, h = e.isFixed, y = c.x, g = y === void 0 ? 0 : y, w = c.y, d = w === void 0 ? 0 : w, l = typeof f == \"function\" ? f({\n    x: g,\n    y: d\n  }) : {\n    x: g,\n    y: d\n  };\n  g = l.x, d = l.y;\n  var p = c.hasOwnProperty(\"x\"), b = c.hasOwnProperty(\"y\"), x = $, m = j, O = window;\n  if (u) {\n    var E = Ce(r), R = \"clientHeight\", B = \"clientWidth\";\n    if (E === H(r) && (E = ie(r), Z(E).position !== \"static\" && i === \"absolute\" && (R = \"scrollHeight\", B = \"scrollWidth\")), E = E, o === j || (o === $ || o === q) && a === Me) {\n      m = N;\n      var T = h && E === O && O.visualViewport ? O.visualViewport.height : (\n        // $FlowFixMe[prop-missing]\n        E[R]\n      );\n      d -= T - n.height, d *= s ? 1 : -1;\n    }\n    if (o === $ || (o === j || o === N) && a === Me) {\n      x = q;\n      var A = h && E === O && O.visualViewport ? O.visualViewport.width : (\n        // $FlowFixMe[prop-missing]\n        E[B]\n      );\n      g -= A - n.width, g *= s ? 1 : -1;\n    }\n  }\n  var C = Object.assign({\n    position: i\n  }, u && xn), L = f === !0 ? En({\n    x: g,\n    y: d\n  }, H(r)) : {\n    x: g,\n    y: d\n  };\n  if (g = L.x, d = L.y, s) {\n    var v;\n    return Object.assign({}, C, (v = {}, v[m] = b ? \"0\" : \"\", v[x] = p ? \"0\" : \"\", v.transform = (O.devicePixelRatio || 1) <= 1 ? \"translate(\" + g + \"px, \" + d + \"px)\" : \"translate3d(\" + g + \"px, \" + d + \"px, 0)\", v));\n  }\n  return Object.assign({}, C, (t = {}, t[m] = b ? d + \"px\" : \"\", t[x] = p ? g + \"px\" : \"\", t.transform = \"\", t));\n}\nfunction On(e) {\n  var t = e.state, r = e.options, n = r.gpuAcceleration, o = n === void 0 ? !0 : n, a = r.adaptive, c = a === void 0 ? !0 : a, i = r.roundOffsets, s = i === void 0 ? !0 : i, u = {\n    placement: K(t.placement),\n    variation: xe(t.placement),\n    popper: t.elements.popper,\n    popperRect: t.rects.popper,\n    gpuAcceleration: o,\n    isFixed: t.options.strategy === \"fixed\"\n  };\n  t.modifiersData.popperOffsets != null && (t.styles.popper = Object.assign({}, t.styles.popper, Pt(Object.assign({}, u, {\n    offsets: t.modifiersData.popperOffsets,\n    position: t.options.strategy,\n    adaptive: c,\n    roundOffsets: s\n  })))), t.modifiersData.arrow != null && (t.styles.arrow = Object.assign({}, t.styles.arrow, Pt(Object.assign({}, u, {\n    offsets: t.modifiersData.arrow,\n    position: \"absolute\",\n    adaptive: !1,\n    roundOffsets: s\n  })))), t.attributes.popper = Object.assign({}, t.attributes.popper, {\n    \"data-popper-placement\": t.placement\n  });\n}\nconst Sn = {\n  name: \"computeStyles\",\n  enabled: !0,\n  phase: \"beforeWrite\",\n  fn: On,\n  data: {}\n};\nvar je = {\n  passive: !0\n};\nfunction kn(e) {\n  var t = e.state, r = e.instance, n = e.options, o = n.scroll, a = o === void 0 ? !0 : o, c = n.resize, i = c === void 0 ? !0 : c, s = H(t.elements.popper), u = [].concat(t.scrollParents.reference, t.scrollParents.popper);\n  return a && u.forEach(function(f) {\n    f.addEventListener(\"scroll\", r.update, je);\n  }), i && s.addEventListener(\"resize\", r.update, je), function() {\n    a && u.forEach(function(f) {\n      f.removeEventListener(\"scroll\", r.update, je);\n    }), i && s.removeEventListener(\"resize\", r.update, je);\n  };\n}\nconst Rn = {\n  name: \"eventListeners\",\n  enabled: !0,\n  phase: \"write\",\n  fn: function() {\n  },\n  effect: kn,\n  data: {}\n};\nvar Tn = {\n  left: \"right\",\n  right: \"left\",\n  bottom: \"top\",\n  top: \"bottom\"\n};\nfunction Ne(e) {\n  return e.replace(/left|right|bottom|top/g, function(t) {\n    return Tn[t];\n  });\n}\nvar zn = {\n  start: \"end\",\n  end: \"start\"\n};\nfunction Dt(e) {\n  return e.replace(/start|end/g, function(t) {\n    return zn[t];\n  });\n}\nfunction dt(e) {\n  var t = H(e), r = t.pageXOffset, n = t.pageYOffset;\n  return {\n    scrollLeft: r,\n    scrollTop: n\n  };\n}\nfunction pt(e) {\n  return we(ie(e)).left + dt(e).scrollLeft;\n}\nfunction Bn(e, t) {\n  var r = H(e), n = ie(e), o = r.visualViewport, a = n.clientWidth, c = n.clientHeight, i = 0, s = 0;\n  if (o) {\n    a = o.width, c = o.height;\n    var u = rr();\n    (u || !u && t === \"fixed\") && (i = o.offsetLeft, s = o.offsetTop);\n  }\n  return {\n    width: a,\n    height: c,\n    x: i + pt(e),\n    y: s\n  };\n}\nfunction Mn(e) {\n  var t, r = ie(e), n = dt(e), o = (t = e.ownerDocument) == null ? void 0 : t.body, a = ue(r.scrollWidth, r.clientWidth, o ? o.scrollWidth : 0, o ? o.clientWidth : 0), c = ue(r.scrollHeight, r.clientHeight, o ? o.scrollHeight : 0, o ? o.clientHeight : 0), i = -n.scrollLeft + pt(e), s = -n.scrollTop;\n  return Z(o || r).direction === \"rtl\" && (i += ue(r.clientWidth, o ? o.clientWidth : 0) - a), {\n    width: a,\n    height: c,\n    x: i,\n    y: s\n  };\n}\nfunction vt(e) {\n  var t = Z(e), r = t.overflow, n = t.overflowX, o = t.overflowY;\n  return /auto|scroll|overlay|hidden/.test(r + o + n);\n}\nfunction sr(e) {\n  return [\"html\", \"body\", \"#document\"].indexOf(G(e)) >= 0 ? e.ownerDocument.body : I(e) && vt(e) ? e : sr(Ke(e));\n}\nfunction Re(e, t) {\n  var r;\n  t === void 0 && (t = []);\n  var n = sr(e), o = n === ((r = e.ownerDocument) == null ? void 0 : r.body), a = H(n), c = o ? [a].concat(a.visualViewport || [], vt(n) ? n : []) : n, i = t.concat(c);\n  return o ? i : (\n    // $FlowFixMe[incompatible-call]: isBody tells us target will be an HTMLElement here\n    i.concat(Re(Ke(c)))\n  );\n}\nfunction at(e) {\n  return Object.assign({}, e, {\n    left: e.x,\n    top: e.y,\n    right: e.x + e.width,\n    bottom: e.y + e.height\n  });\n}\nfunction An(e, t) {\n  var r = we(e, !1, t === \"fixed\");\n  return r.top = r.top + e.clientTop, r.left = r.left + e.clientLeft, r.bottom = r.top + e.clientHeight, r.right = r.left + e.clientWidth, r.width = e.clientWidth, r.height = e.clientHeight, r.x = r.left, r.y = r.top, r;\n}\nfunction Ct(e, t, r) {\n  return t === er ? at(Bn(e, r)) : pe(t) ? An(t, r) : at(Mn(ie(e)));\n}\nfunction Pn(e) {\n  var t = Re(Ke(e)), r = [\"absolute\", \"fixed\"].indexOf(Z(e).position) >= 0, n = r && I(e) ? Ce(e) : e;\n  return pe(n) ? t.filter(function(o) {\n    return pe(o) && nr(o, n) && G(o) !== \"body\";\n  }) : [];\n}\nfunction Dn(e, t, r, n) {\n  var o = t === \"clippingParents\" ? Pn(e) : [].concat(t), a = [].concat(o, [r]), c = a[0], i = a.reduce(function(s, u) {\n    var f = Ct(e, u, n);\n    return s.top = ue(f.top, s.top), s.right = Xe(f.right, s.right), s.bottom = Xe(f.bottom, s.bottom), s.left = ue(f.left, s.left), s;\n  }, Ct(e, c, n));\n  return i.width = i.right - i.left, i.height = i.bottom - i.top, i.x = i.left, i.y = i.top, i;\n}\nfunction cr(e) {\n  var t = e.reference, r = e.element, n = e.placement, o = n ? K(n) : null, a = n ? xe(n) : null, c = t.x + t.width / 2 - r.width / 2, i = t.y + t.height / 2 - r.height / 2, s;\n  switch (o) {\n    case j:\n      s = {\n        x: c,\n        y: t.y - r.height\n      };\n      break;\n    case N:\n      s = {\n        x: c,\n        y: t.y + t.height\n      };\n      break;\n    case q:\n      s = {\n        x: t.x + t.width,\n        y: i\n      };\n      break;\n    case $:\n      s = {\n        x: t.x - r.width,\n        y: i\n      };\n      break;\n    default:\n      s = {\n        x: t.x,\n        y: t.y\n      };\n  }\n  var u = o ? lt(o) : null;\n  if (u != null) {\n    var f = u === \"y\" ? \"height\" : \"width\";\n    switch (a) {\n      case be:\n        s[u] = s[u] - (t[f] / 2 - r[f] / 2);\n        break;\n      case Me:\n        s[u] = s[u] + (t[f] / 2 - r[f] / 2);\n        break;\n    }\n  }\n  return s;\n}\nfunction Ae(e, t) {\n  t === void 0 && (t = {});\n  var r = t, n = r.placement, o = n === void 0 ? e.placement : n, a = r.strategy, c = a === void 0 ? e.strategy : a, i = r.boundary, s = i === void 0 ? Qr : i, u = r.rootBoundary, f = u === void 0 ? er : u, h = r.elementContext, y = h === void 0 ? Oe : h, g = r.altBoundary, w = g === void 0 ? !1 : g, d = r.padding, l = d === void 0 ? 0 : d, p = ir(typeof l != \"number\" ? l : ar(l, De)), b = y === Oe ? Zr : Oe, x = e.rects.popper, m = e.elements[w ? b : y], O = Dn(pe(m) ? m : m.contextElement || ie(e.elements.popper), s, f, c), E = we(e.elements.reference), R = cr({\n    reference: E,\n    element: x,\n    strategy: \"absolute\",\n    placement: o\n  }), B = at(Object.assign({}, x, R)), T = y === Oe ? B : E, A = {\n    top: O.top - T.top + p.top,\n    bottom: T.bottom - O.bottom + p.bottom,\n    left: O.left - T.left + p.left,\n    right: T.right - O.right + p.right\n  }, C = e.modifiersData.offset;\n  if (y === Oe && C) {\n    var L = C[o];\n    Object.keys(A).forEach(function(v) {\n      var k = [q, N].indexOf(v) >= 0 ? 1 : -1, S = [j, N].indexOf(v) >= 0 ? \"y\" : \"x\";\n      A[v] += L[S] * k;\n    });\n  }\n  return A;\n}\nfunction Cn(e, t) {\n  t === void 0 && (t = {});\n  var r = t, n = r.placement, o = r.boundary, a = r.rootBoundary, c = r.padding, i = r.flipVariations, s = r.allowedAutoPlacements, u = s === void 0 ? tr : s, f = xe(n), h = f ? i ? Mt : Mt.filter(function(w) {\n    return xe(w) === f;\n  }) : De, y = h.filter(function(w) {\n    return u.indexOf(w) >= 0;\n  });\n  y.length === 0 && (y = h);\n  var g = y.reduce(function(w, d) {\n    return w[d] = Ae(e, {\n      placement: d,\n      boundary: o,\n      rootBoundary: a,\n      padding: c\n    })[K(d)], w;\n  }, {});\n  return Object.keys(g).sort(function(w, d) {\n    return g[w] - g[d];\n  });\n}\nfunction Ln(e) {\n  if (K(e) === ct)\n    return [];\n  var t = Ne(e);\n  return [Dt(e), t, Dt(t)];\n}\nfunction Wn(e) {\n  var t = e.state, r = e.options, n = e.name;\n  if (!t.modifiersData[n]._skip) {\n    for (var o = r.mainAxis, a = o === void 0 ? !0 : o, c = r.altAxis, i = c === void 0 ? !0 : c, s = r.fallbackPlacements, u = r.padding, f = r.boundary, h = r.rootBoundary, y = r.altBoundary, g = r.flipVariations, w = g === void 0 ? !0 : g, d = r.allowedAutoPlacements, l = t.options.placement, p = K(l), b = p === l, x = s || (b || !w ? [Ne(l)] : Ln(l)), m = [l].concat(x).reduce(function(te, re) {\n      return te.concat(K(re) === ct ? Cn(t, {\n        placement: re,\n        boundary: f,\n        rootBoundary: h,\n        padding: u,\n        flipVariations: w,\n        allowedAutoPlacements: d\n      }) : re);\n    }, []), O = t.rects.reference, E = t.rects.popper, R = /* @__PURE__ */ new Map(), B = !0, T = m[0], A = 0; A < m.length; A++) {\n      var C = m[A], L = K(C), v = xe(C) === be, k = [j, N].indexOf(L) >= 0, S = k ? \"width\" : \"height\", M = Ae(t, {\n        placement: C,\n        boundary: f,\n        rootBoundary: h,\n        altBoundary: y,\n        padding: u\n      }), z = k ? v ? q : $ : v ? N : j;\n      O[S] > E[S] && (z = Ne(z));\n      var X = Ne(z), W = [];\n      if (a && W.push(M[L] <= 0), i && W.push(M[z] <= 0, M[X] <= 0), W.every(function(te) {\n        return te;\n      })) {\n        T = C, B = !1;\n        break;\n      }\n      R.set(C, W);\n    }\n    if (B)\n      for (var Y = w ? 3 : 1, V = function(re) {\n        var Ee = m.find(function(Le) {\n          var se = R.get(Le);\n          if (se)\n            return se.slice(0, re).every(function(Ge) {\n              return Ge;\n            });\n        });\n        if (Ee)\n          return T = Ee, \"break\";\n      }, ee = Y; ee > 0; ee--) {\n        var ae = V(ee);\n        if (ae === \"break\")\n          break;\n      }\n    t.placement !== T && (t.modifiersData[n]._skip = !0, t.placement = T, t.reset = !0);\n  }\n}\nconst Fn = {\n  name: \"flip\",\n  enabled: !0,\n  phase: \"main\",\n  fn: Wn,\n  requiresIfExists: [\"offset\"],\n  data: {\n    _skip: !1\n  }\n};\nfunction Lt(e, t, r) {\n  return r === void 0 && (r = {\n    x: 0,\n    y: 0\n  }), {\n    top: e.top - t.height - r.y,\n    right: e.right - t.width + r.x,\n    bottom: e.bottom - t.height + r.y,\n    left: e.left - t.width - r.x\n  };\n}\nfunction Wt(e) {\n  return [j, q, N, $].some(function(t) {\n    return e[t] >= 0;\n  });\n}\nfunction jn(e) {\n  var t = e.state, r = e.name, n = t.rects.reference, o = t.rects.popper, a = t.modifiersData.preventOverflow, c = Ae(t, {\n    elementContext: \"reference\"\n  }), i = Ae(t, {\n    altBoundary: !0\n  }), s = Lt(c, n), u = Lt(i, o, a), f = Wt(s), h = Wt(u);\n  t.modifiersData[r] = {\n    referenceClippingOffsets: s,\n    popperEscapeOffsets: u,\n    isReferenceHidden: f,\n    hasPopperEscaped: h\n  }, t.attributes.popper = Object.assign({}, t.attributes.popper, {\n    \"data-popper-reference-hidden\": f,\n    \"data-popper-escaped\": h\n  });\n}\nconst $n = {\n  name: \"hide\",\n  enabled: !0,\n  phase: \"main\",\n  requiresIfExists: [\"preventOverflow\"],\n  fn: jn\n};\nfunction Hn(e, t, r) {\n  var n = K(e), o = [$, j].indexOf(n) >= 0 ? -1 : 1, a = typeof r == \"function\" ? r(Object.assign({}, t, {\n    placement: e\n  })) : r, c = a[0], i = a[1];\n  return c = c || 0, i = (i || 0) * o, [$, q].indexOf(n) >= 0 ? {\n    x: i,\n    y: c\n  } : {\n    x: c,\n    y: i\n  };\n}\nfunction In(e) {\n  var t = e.state, r = e.options, n = e.name, o = r.offset, a = o === void 0 ? [0, 0] : o, c = tr.reduce(function(f, h) {\n    return f[h] = Hn(h, t.rects, a), f;\n  }, {}), i = c[t.placement], s = i.x, u = i.y;\n  t.modifiersData.popperOffsets != null && (t.modifiersData.popperOffsets.x += s, t.modifiersData.popperOffsets.y += u), t.modifiersData[n] = c;\n}\nconst Nn = {\n  name: \"offset\",\n  enabled: !0,\n  phase: \"main\",\n  requires: [\"popperOffsets\"],\n  fn: In\n};\nfunction qn(e) {\n  var t = e.state, r = e.name;\n  t.modifiersData[r] = cr({\n    reference: t.rects.reference,\n    element: t.rects.popper,\n    strategy: \"absolute\",\n    placement: t.placement\n  });\n}\nconst Xn = {\n  name: \"popperOffsets\",\n  enabled: !0,\n  phase: \"read\",\n  fn: qn,\n  data: {}\n};\nfunction Vn(e) {\n  return e === \"x\" ? \"y\" : \"x\";\n}\nfunction Yn(e) {\n  var t = e.state, r = e.options, n = e.name, o = r.mainAxis, a = o === void 0 ? !0 : o, c = r.altAxis, i = c === void 0 ? !1 : c, s = r.boundary, u = r.rootBoundary, f = r.altBoundary, h = r.padding, y = r.tether, g = y === void 0 ? !0 : y, w = r.tetherOffset, d = w === void 0 ? 0 : w, l = Ae(t, {\n    boundary: s,\n    rootBoundary: u,\n    padding: h,\n    altBoundary: f\n  }), p = K(t.placement), b = xe(t.placement), x = !b, m = lt(p), O = Vn(m), E = t.modifiersData.popperOffsets, R = t.rects.reference, B = t.rects.popper, T = typeof d == \"function\" ? d(Object.assign({}, t.rects, {\n    placement: t.placement\n  })) : d, A = typeof T == \"number\" ? {\n    mainAxis: T,\n    altAxis: T\n  } : Object.assign({\n    mainAxis: 0,\n    altAxis: 0\n  }, T), C = t.modifiersData.offset ? t.modifiersData.offset[t.placement] : null, L = {\n    x: 0,\n    y: 0\n  };\n  if (E) {\n    if (a) {\n      var v, k = m === \"y\" ? j : $, S = m === \"y\" ? N : q, M = m === \"y\" ? \"height\" : \"width\", z = E[m], X = z + l[k], W = z - l[S], Y = g ? -B[M] / 2 : 0, V = b === be ? R[M] : B[M], ee = b === be ? -B[M] : -R[M], ae = t.elements.arrow, te = g && ae ? ut(ae) : {\n        width: 0,\n        height: 0\n      }, re = t.modifiersData[\"arrow#persistent\"] ? t.modifiersData[\"arrow#persistent\"].padding : or(), Ee = re[k], Le = re[S], se = ke(0, R[M], te[M]), Ge = x ? R[M] / 2 - Y - se - Ee - A.mainAxis : V - se - Ee - A.mainAxis, br = x ? -R[M] / 2 + Y + se + Le + A.mainAxis : ee + se + Le + A.mainAxis, Je = t.elements.arrow && Ce(t.elements.arrow), yr = Je ? m === \"y\" ? Je.clientTop || 0 : Je.clientLeft || 0 : 0, gt = (v = C == null ? void 0 : C[m]) != null ? v : 0, wr = z + Ge - gt - yr, xr = z + br - gt, mt = ke(g ? Xe(X, wr) : X, z, g ? ue(W, xr) : W);\n      E[m] = mt, L[m] = mt - z;\n    }\n    if (i) {\n      var bt, Er = m === \"x\" ? j : $, Or = m === \"x\" ? N : q, ce = E[O], We = O === \"y\" ? \"height\" : \"width\", yt = ce + l[Er], wt = ce - l[Or], Qe = [j, $].indexOf(p) !== -1, xt = (bt = C == null ? void 0 : C[O]) != null ? bt : 0, Et = Qe ? yt : ce - R[We] - B[We] - xt + A.altAxis, Ot = Qe ? ce + R[We] + B[We] - xt - A.altAxis : wt, St = g && Qe ? gn(Et, ce, Ot) : ke(g ? Et : yt, ce, g ? Ot : wt);\n      E[O] = St, L[O] = St - ce;\n    }\n    t.modifiersData[n] = L;\n  }\n}\nconst Un = {\n  name: \"preventOverflow\",\n  enabled: !0,\n  phase: \"main\",\n  fn: Yn,\n  requiresIfExists: [\"offset\"]\n};\nfunction _n(e) {\n  return {\n    scrollLeft: e.scrollLeft,\n    scrollTop: e.scrollTop\n  };\n}\nfunction Kn(e) {\n  return e === H(e) || !I(e) ? dt(e) : _n(e);\n}\nfunction Gn(e) {\n  var t = e.getBoundingClientRect(), r = ye(t.width) / e.offsetWidth || 1, n = ye(t.height) / e.offsetHeight || 1;\n  return r !== 1 || n !== 1;\n}\nfunction Jn(e, t, r) {\n  r === void 0 && (r = !1);\n  var n = I(t), o = I(t) && Gn(t), a = ie(t), c = we(e, o, r), i = {\n    scrollLeft: 0,\n    scrollTop: 0\n  }, s = {\n    x: 0,\n    y: 0\n  };\n  return (n || !n && !r) && ((G(t) !== \"body\" || // https://github.com/popperjs/popper-core/issues/1078\n  vt(a)) && (i = Kn(t)), I(t) ? (s = we(t, !0), s.x += t.clientLeft, s.y += t.clientTop) : a && (s.x = pt(a))), {\n    x: c.left + i.scrollLeft - s.x,\n    y: c.top + i.scrollTop - s.y,\n    width: c.width,\n    height: c.height\n  };\n}\nfunction Qn(e) {\n  var t = /* @__PURE__ */ new Map(), r = /* @__PURE__ */ new Set(), n = [];\n  e.forEach(function(a) {\n    t.set(a.name, a);\n  });\n  function o(a) {\n    r.add(a.name);\n    var c = [].concat(a.requires || [], a.requiresIfExists || []);\n    c.forEach(function(i) {\n      if (!r.has(i)) {\n        var s = t.get(i);\n        s && o(s);\n      }\n    }), n.push(a);\n  }\n  return e.forEach(function(a) {\n    r.has(a.name) || o(a);\n  }), n;\n}\nfunction Zn(e) {\n  var t = Qn(e);\n  return un.reduce(function(r, n) {\n    return r.concat(t.filter(function(o) {\n      return o.phase === n;\n    }));\n  }, []);\n}\nfunction eo(e) {\n  var t;\n  return function() {\n    return t || (t = new Promise(function(r) {\n      Promise.resolve().then(function() {\n        t = void 0, r(e());\n      });\n    })), t;\n  };\n}\nfunction to(e) {\n  var t = e.reduce(function(r, n) {\n    var o = r[n.name];\n    return r[n.name] = o ? Object.assign({}, o, n, {\n      options: Object.assign({}, o.options, n.options),\n      data: Object.assign({}, o.data, n.data)\n    }) : n, r;\n  }, {});\n  return Object.keys(t).map(function(r) {\n    return t[r];\n  });\n}\nvar Ft = {\n  placement: \"bottom\",\n  modifiers: [],\n  strategy: \"absolute\"\n};\nfunction jt() {\n  for (var e = arguments.length, t = new Array(e), r = 0; r < e; r++)\n    t[r] = arguments[r];\n  return !t.some(function(n) {\n    return !(n && typeof n.getBoundingClientRect == \"function\");\n  });\n}\nfunction ro(e) {\n  e === void 0 && (e = {});\n  var t = e, r = t.defaultModifiers, n = r === void 0 ? [] : r, o = t.defaultOptions, a = o === void 0 ? Ft : o;\n  return function(i, s, u) {\n    u === void 0 && (u = a);\n    var f = {\n      placement: \"bottom\",\n      orderedModifiers: [],\n      options: Object.assign({}, Ft, a),\n      modifiersData: {},\n      elements: {\n        reference: i,\n        popper: s\n      },\n      attributes: {},\n      styles: {}\n    }, h = [], y = !1, g = {\n      state: f,\n      setOptions: function(p) {\n        var b = typeof p == \"function\" ? p(f.options) : p;\n        d(), f.options = Object.assign({}, a, f.options, b), f.scrollParents = {\n          reference: pe(i) ? Re(i) : i.contextElement ? Re(i.contextElement) : [],\n          popper: Re(s)\n        };\n        var x = Zn(to([].concat(n, f.options.modifiers)));\n        return f.orderedModifiers = x.filter(function(m) {\n          return m.enabled;\n        }), w(), g.update();\n      },\n      // Sync update – it will always be executed, even if not necessary. This\n      // is useful for low frequency updates where sync behavior simplifies the\n      // logic.\n      // For high frequency updates (e.g. `resize` and `scroll` events), always\n      // prefer the async Popper#update method\n      forceUpdate: function() {\n        if (!y) {\n          var p = f.elements, b = p.reference, x = p.popper;\n          if (jt(b, x)) {\n            f.rects = {\n              reference: Jn(b, Ce(x), f.options.strategy === \"fixed\"),\n              popper: ut(x)\n            }, f.reset = !1, f.placement = f.options.placement, f.orderedModifiers.forEach(function(A) {\n              return f.modifiersData[A.name] = Object.assign({}, A.data);\n            });\n            for (var m = 0; m < f.orderedModifiers.length; m++) {\n              if (f.reset === !0) {\n                f.reset = !1, m = -1;\n                continue;\n              }\n              var O = f.orderedModifiers[m], E = O.fn, R = O.options, B = R === void 0 ? {} : R, T = O.name;\n              typeof E == \"function\" && (f = E({\n                state: f,\n                options: B,\n                name: T,\n                instance: g\n              }) || f);\n            }\n          }\n        }\n      },\n      // Async and optimistically optimized update – it will not be executed if\n      // not necessary (debounced to run at most once-per-tick)\n      update: eo(function() {\n        return new Promise(function(l) {\n          g.forceUpdate(), l(f);\n        });\n      }),\n      destroy: function() {\n        d(), y = !0;\n      }\n    };\n    if (!jt(i, s))\n      return g;\n    g.setOptions(u).then(function(l) {\n      !y && u.onFirstUpdate && u.onFirstUpdate(l);\n    });\n    function w() {\n      f.orderedModifiers.forEach(function(l) {\n        var p = l.name, b = l.options, x = b === void 0 ? {} : b, m = l.effect;\n        if (typeof m == \"function\") {\n          var O = m({\n            state: f,\n            name: p,\n            instance: g,\n            options: x\n          }), E = function() {\n          };\n          h.push(O || E);\n        }\n      });\n    }\n    function d() {\n      h.forEach(function(l) {\n        return l();\n      }), h = [];\n    }\n    return g;\n  };\n}\nvar no = [Rn, Xn, Sn, pn, Nn, Fn, Un, wn, $n], oo = /* @__PURE__ */ ro({\n  defaultModifiers: no\n});\nconst $o = Object.freeze([\n  \"auto\",\n  \"auto-start\",\n  \"auto-end\",\n  \"top\",\n  \"top-start\",\n  \"top-end\",\n  \"bottom\",\n  \"bottom-start\",\n  \"bottom-end\",\n  \"left\",\n  \"left-start\",\n  \"left-end\",\n  \"right\",\n  \"right-start\",\n  \"right-end\"\n]);\nfunction Ho(e) {\n  const { placement: t, transfer: r, wrapper: n, isDrop: o = !1 } = e, a = e.reference ?? P(null), c = e.popper ?? P(null), i = P(\"\"), s = {\n    placement: t.value,\n    modifiers: [\n      {\n        name: \"preventOverflow\",\n        options: {\n          rootBoundary: \"window\"\n        }\n      },\n      {\n        name: \"computeStyles\",\n        options: {\n          gpuAcceleration: !1\n        }\n      }\n    ]\n  };\n  o && s.modifiers.push({\n    name: \"setTransformOrigin\",\n    enabled: !0,\n    phase: \"afterWrite\",\n    fn({ state: l }) {\n      const p = io(l.placement);\n      p && (l.elements.popper.style.transformOrigin = p);\n    }\n  }), e.offset && s.modifiers.push({\n    name: \"offset\",\n    options: {\n      offset: e.offset\n    }\n  });\n  let u = null;\n  fe(t, (l) => {\n    s.placement = l, u && u.setOptions({ placement: l });\n  }), Rr(() => {\n    n.value && c.value && (n.value.__transferElement = c.value);\n  });\n  let f = null;\n  r && (fe(r, (l) => {\n    g(l), h();\n  }), g(r.value)), _e(() => {\n    ze(y);\n  }), ve(d);\n  function h() {\n    ze(() => {\n      u && u.forceUpdate();\n    });\n  }\n  function y() {\n    d(), u && u.destroy(), w();\n    const l = fe(a, w), p = fe(c, w);\n    f = () => {\n      l(), p();\n    };\n  }\n  function g(l) {\n    i.value = typeof l == \"boolean\" ? l ? \"body\" : \"\" : l;\n  }\n  function w() {\n    a.value && c.value && (u && u.destroy(), u = oo(a.value, c.value, s), h());\n  }\n  function d() {\n    u && u.destroy(), u = null, typeof f == \"function\" && (f(), f = null);\n  }\n  return {\n    reference: a,\n    popper: c,\n    transferTo: i,\n    updatePopper: h,\n    createPopper: y,\n    destroyPopper: d\n  };\n}\nfunction io(e) {\n  if (e !== \"left\" && e !== \"right\") {\n    const [t, r] = e.split(\"-\");\n    return t === \"bottom\" || t !== \"top\" && r === \"start\" ? \"center top\" : \"center bottom\";\n  }\n}\nvar le = [], ao = function() {\n  return le.some(function(e) {\n    return e.activeTargets.length > 0;\n  });\n}, so = function() {\n  return le.some(function(e) {\n    return e.skippedTargets.length > 0;\n  });\n}, $t = \"ResizeObserver loop completed with undelivered notifications.\", co = function() {\n  var e;\n  typeof ErrorEvent == \"function\" ? e = new ErrorEvent(\"error\", {\n    message: $t\n  }) : (e = document.createEvent(\"Event\"), e.initEvent(\"error\", !1, !1), e.message = $t), window.dispatchEvent(e);\n}, Pe;\n(function(e) {\n  e.BORDER_BOX = \"border-box\", e.CONTENT_BOX = \"content-box\", e.DEVICE_PIXEL_CONTENT_BOX = \"device-pixel-content-box\";\n})(Pe || (Pe = {}));\nvar de = function(e) {\n  return Object.freeze(e);\n}, fo = function() {\n  function e(t, r) {\n    this.inlineSize = t, this.blockSize = r, de(this);\n  }\n  return e;\n}(), fr = function() {\n  function e(t, r, n, o) {\n    return this.x = t, this.y = r, this.width = n, this.height = o, this.top = this.y, this.left = this.x, this.bottom = this.top + this.height, this.right = this.left + this.width, de(this);\n  }\n  return e.prototype.toJSON = function() {\n    var t = this, r = t.x, n = t.y, o = t.top, a = t.right, c = t.bottom, i = t.left, s = t.width, u = t.height;\n    return { x: r, y: n, top: o, right: a, bottom: c, left: i, width: s, height: u };\n  }, e.fromRect = function(t) {\n    return new e(t.x, t.y, t.width, t.height);\n  }, e;\n}(), ht = function(e) {\n  return e instanceof SVGElement && \"getBBox\" in e;\n}, ur = function(e) {\n  if (ht(e)) {\n    var t = e.getBBox(), r = t.width, n = t.height;\n    return !r && !n;\n  }\n  var o = e, a = o.offsetWidth, c = o.offsetHeight;\n  return !(a || c || e.getClientRects().length);\n}, Ht = function(e) {\n  var t;\n  if (e instanceof Element)\n    return !0;\n  var r = (t = e == null ? void 0 : e.ownerDocument) === null || t === void 0 ? void 0 : t.defaultView;\n  return !!(r && e instanceof r.Element);\n}, uo = function(e) {\n  switch (e.tagName) {\n    case \"INPUT\":\n      if (e.type !== \"image\")\n        break;\n    case \"VIDEO\":\n    case \"AUDIO\":\n    case \"EMBED\":\n    case \"OBJECT\":\n    case \"CANVAS\":\n    case \"IFRAME\":\n    case \"IMG\":\n      return !0;\n  }\n  return !1;\n}, Te = typeof window < \"u\" ? window : {}, $e = /* @__PURE__ */ new WeakMap(), It = /auto|scroll/, lo = /^tb|vertical/, po = /msie|trident/i.test(Te.navigator && Te.navigator.userAgent), U = function(e) {\n  return parseFloat(e || \"0\");\n}, me = function(e, t, r) {\n  return e === void 0 && (e = 0), t === void 0 && (t = 0), r === void 0 && (r = !1), new fo((r ? t : e) || 0, (r ? e : t) || 0);\n}, Nt = de({\n  devicePixelContentBoxSize: me(),\n  borderBoxSize: me(),\n  contentBoxSize: me(),\n  contentRect: new fr(0, 0, 0, 0)\n}), lr = function(e, t) {\n  if (t === void 0 && (t = !1), $e.has(e) && !t)\n    return $e.get(e);\n  if (ur(e))\n    return $e.set(e, Nt), Nt;\n  var r = getComputedStyle(e), n = ht(e) && e.ownerSVGElement && e.getBBox(), o = !po && r.boxSizing === \"border-box\", a = lo.test(r.writingMode || \"\"), c = !n && It.test(r.overflowY || \"\"), i = !n && It.test(r.overflowX || \"\"), s = n ? 0 : U(r.paddingTop), u = n ? 0 : U(r.paddingRight), f = n ? 0 : U(r.paddingBottom), h = n ? 0 : U(r.paddingLeft), y = n ? 0 : U(r.borderTopWidth), g = n ? 0 : U(r.borderRightWidth), w = n ? 0 : U(r.borderBottomWidth), d = n ? 0 : U(r.borderLeftWidth), l = h + u, p = s + f, b = d + g, x = y + w, m = i ? e.offsetHeight - x - e.clientHeight : 0, O = c ? e.offsetWidth - b - e.clientWidth : 0, E = o ? l + b : 0, R = o ? p + x : 0, B = n ? n.width : U(r.width) - E - O, T = n ? n.height : U(r.height) - R - m, A = B + l + O + b, C = T + p + m + x, L = de({\n    devicePixelContentBoxSize: me(Math.round(B * devicePixelRatio), Math.round(T * devicePixelRatio), a),\n    borderBoxSize: me(A, C, a),\n    contentBoxSize: me(B, T, a),\n    contentRect: new fr(h, s, B, T)\n  });\n  return $e.set(e, L), L;\n}, dr = function(e, t, r) {\n  var n = lr(e, r), o = n.borderBoxSize, a = n.contentBoxSize, c = n.devicePixelContentBoxSize;\n  switch (t) {\n    case Pe.DEVICE_PIXEL_CONTENT_BOX:\n      return c;\n    case Pe.BORDER_BOX:\n      return o;\n    default:\n      return a;\n  }\n}, vo = function() {\n  function e(t) {\n    var r = lr(t);\n    this.target = t, this.contentRect = r.contentRect, this.borderBoxSize = de([r.borderBoxSize]), this.contentBoxSize = de([r.contentBoxSize]), this.devicePixelContentBoxSize = de([r.devicePixelContentBoxSize]);\n  }\n  return e;\n}(), pr = function(e) {\n  if (ur(e))\n    return 1 / 0;\n  for (var t = 0, r = e.parentNode; r; )\n    t += 1, r = r.parentNode;\n  return t;\n}, ho = function() {\n  var e = 1 / 0, t = [];\n  le.forEach(function(c) {\n    if (c.activeTargets.length !== 0) {\n      var i = [];\n      c.activeTargets.forEach(function(u) {\n        var f = new vo(u.target), h = pr(u.target);\n        i.push(f), u.lastReportedSize = dr(u.target, u.observedBox), h < e && (e = h);\n      }), t.push(function() {\n        c.callback.call(c.observer, i, c.observer);\n      }), c.activeTargets.splice(0, c.activeTargets.length);\n    }\n  });\n  for (var r = 0, n = t; r < n.length; r++) {\n    var o = n[r];\n    o();\n  }\n  return e;\n}, qt = function(e) {\n  le.forEach(function(r) {\n    r.activeTargets.splice(0, r.activeTargets.length), r.skippedTargets.splice(0, r.skippedTargets.length), r.observationTargets.forEach(function(o) {\n      o.isActive() && (pr(o.target) > e ? r.activeTargets.push(o) : r.skippedTargets.push(o));\n    });\n  });\n}, go = function() {\n  var e = 0;\n  for (qt(e); ao(); )\n    e = ho(), qt(e);\n  return so() && co(), e > 0;\n}, tt, vr = [], mo = function() {\n  return vr.splice(0).forEach(function(e) {\n    return e();\n  });\n}, bo = function(e) {\n  if (!tt) {\n    var t = 0, r = document.createTextNode(\"\"), n = { characterData: !0 };\n    new MutationObserver(function() {\n      return mo();\n    }).observe(r, n), tt = function() {\n      r.textContent = \"\".concat(t ? t-- : t++);\n    };\n  }\n  vr.push(e), tt();\n}, yo = function(e) {\n  bo(function() {\n    requestAnimationFrame(e);\n  });\n}, qe = 0, wo = function() {\n  return !!qe;\n}, xo = 250, Eo = { attributes: !0, characterData: !0, childList: !0, subtree: !0 }, Xt = [\n  \"resize\",\n  \"load\",\n  \"transitionend\",\n  \"animationend\",\n  \"animationstart\",\n  \"animationiteration\",\n  \"keyup\",\n  \"keydown\",\n  \"mouseup\",\n  \"mousedown\",\n  \"mouseover\",\n  \"mouseout\",\n  \"blur\",\n  \"focus\"\n], Vt = function(e) {\n  return e === void 0 && (e = 0), Date.now() + e;\n}, rt = !1, Oo = function() {\n  function e() {\n    var t = this;\n    this.stopped = !0, this.listener = function() {\n      return t.schedule();\n    };\n  }\n  return e.prototype.run = function(t) {\n    var r = this;\n    if (t === void 0 && (t = xo), !rt) {\n      rt = !0;\n      var n = Vt(t);\n      yo(function() {\n        var o = !1;\n        try {\n          o = go();\n        } finally {\n          if (rt = !1, t = n - Vt(), !wo())\n            return;\n          o ? r.run(1e3) : t > 0 ? r.run(t) : r.start();\n        }\n      });\n    }\n  }, e.prototype.schedule = function() {\n    this.stop(), this.run();\n  }, e.prototype.observe = function() {\n    var t = this, r = function() {\n      return t.observer && t.observer.observe(document.body, Eo);\n    };\n    document.body ? r() : Te.addEventListener(\"DOMContentLoaded\", r);\n  }, e.prototype.start = function() {\n    var t = this;\n    this.stopped && (this.stopped = !1, this.observer = new MutationObserver(this.listener), this.observe(), Xt.forEach(function(r) {\n      return Te.addEventListener(r, t.listener, !0);\n    }));\n  }, e.prototype.stop = function() {\n    var t = this;\n    this.stopped || (this.observer && this.observer.disconnect(), Xt.forEach(function(r) {\n      return Te.removeEventListener(r, t.listener, !0);\n    }), this.stopped = !0);\n  }, e;\n}(), st = new Oo(), Yt = function(e) {\n  !qe && e > 0 && st.start(), qe += e, !qe && st.stop();\n}, So = function(e) {\n  return !ht(e) && !uo(e) && getComputedStyle(e).display === \"inline\";\n}, ko = function() {\n  function e(t, r) {\n    this.target = t, this.observedBox = r || Pe.CONTENT_BOX, this.lastReportedSize = {\n      inlineSize: 0,\n      blockSize: 0\n    };\n  }\n  return e.prototype.isActive = function() {\n    var t = dr(this.target, this.observedBox, !0);\n    return So(this.target) && (this.lastReportedSize = t), this.lastReportedSize.inlineSize !== t.inlineSize || this.lastReportedSize.blockSize !== t.blockSize;\n  }, e;\n}(), Ro = function() {\n  function e(t, r) {\n    this.activeTargets = [], this.skippedTargets = [], this.observationTargets = [], this.observer = t, this.callback = r;\n  }\n  return e;\n}(), He = /* @__PURE__ */ new WeakMap(), Ut = function(e, t) {\n  for (var r = 0; r < e.length; r += 1)\n    if (e[r].target === t)\n      return r;\n  return -1;\n}, Ie = function() {\n  function e() {\n  }\n  return e.connect = function(t, r) {\n    var n = new Ro(t, r);\n    He.set(t, n);\n  }, e.observe = function(t, r, n) {\n    var o = He.get(t), a = o.observationTargets.length === 0;\n    Ut(o.observationTargets, r) < 0 && (a && le.push(o), o.observationTargets.push(new ko(r, n && n.box)), Yt(1), st.schedule());\n  }, e.unobserve = function(t, r) {\n    var n = He.get(t), o = Ut(n.observationTargets, r), a = n.observationTargets.length === 1;\n    o >= 0 && (a && le.splice(le.indexOf(n), 1), n.observationTargets.splice(o, 1), Yt(-1));\n  }, e.disconnect = function(t) {\n    var r = this, n = He.get(t);\n    n.observationTargets.slice().forEach(function(o) {\n      return r.unobserve(t, o.target);\n    }), n.activeTargets.splice(0, n.activeTargets.length);\n  }, e;\n}(), _t = function() {\n  function e(t) {\n    if (arguments.length === 0)\n      throw new TypeError(\"Failed to construct 'ResizeObserver': 1 argument required, but only 0 present.\");\n    if (typeof t != \"function\")\n      throw new TypeError(\"Failed to construct 'ResizeObserver': The callback provided as parameter 1 is not a function.\");\n    Ie.connect(this, t);\n  }\n  return e.prototype.observe = function(t, r) {\n    if (arguments.length === 0)\n      throw new TypeError(\"Failed to execute 'observe' on 'ResizeObserver': 1 argument required, but only 0 present.\");\n    if (!Ht(t))\n      throw new TypeError(\"Failed to execute 'observe' on 'ResizeObserver': parameter 1 is not of type 'Element\");\n    Ie.observe(this, t, r);\n  }, e.prototype.unobserve = function(t) {\n    if (arguments.length === 0)\n      throw new TypeError(\"Failed to execute 'unobserve' on 'ResizeObserver': 1 argument required, but only 0 present.\");\n    if (!Ht(t))\n      throw new TypeError(\"Failed to execute 'unobserve' on 'ResizeObserver': parameter 1 is not of type 'Element\");\n    Ie.unobserve(this, t);\n  }, e.prototype.disconnect = function() {\n    Ie.disconnect(this);\n  }, e.toString = function() {\n    return \"function ResizeObserver () { [polyfill code] }\";\n  }, e;\n}();\nconst Ve = /* @__PURE__ */ new WeakMap();\nfunction To(e) {\n  for (let t = 0, r = e.length; t < r; ++t) {\n    const n = e[t], o = Ve.get(n.target);\n    typeof o == \"function\" && o(n);\n  }\n}\nconst hr = new (oe && window.ResizeObserver || _t)(\n  To\n);\nfunction gr(e, t) {\n  Ve.set(e, t), hr.observe(e);\n}\nfunction mr(e) {\n  Ve.has(e) && (hr.unobserve(e), Ve.delete(e));\n}\nfunction Io() {\n  return {\n    observeResize: gr,\n    unobserveResize: mr\n  };\n}\nfunction No() {\n  const e = {};\n  return ve(() => {\n    Object.keys(e).forEach((t) => {\n      clearTimeout(e[t]);\n    });\n  }), { timer: e };\n}\nfunction qo() {\n  const e = {};\n  return ve(() => {\n    Object.keys(e).forEach((t) => {\n      clearInterval(e[t]);\n    });\n  }), { timer: e };\n}\nfunction Xo(e, t, r = 250) {\n  let n;\n  function o() {\n    e.value === \"hover\" && (clearTimeout(n), n = setTimeout(() => {\n      t.value = !0;\n    }, r));\n  }\n  function a() {\n    e.value === \"hover\" && (clearTimeout(n), n = setTimeout(() => {\n      t.value = !1;\n    }, r));\n  }\n  function c() {\n    e.value === \"click\" && (t.value = !t.value);\n  }\n  return {\n    handleTriggerEnter: o,\n    handleTriggerLeave: a,\n    handleTriggerClick: c\n  };\n}\nfunction Vo(e) {\n  const {\n    items: t,\n    itemSize: r,\n    itemFixed: n,\n    idKey: o,\n    defaultKeyAt: a,\n    bufferSize: c = P(5),\n    wrapper: i = P(null),\n    autoResize: s = !0\n  } = e, u = _(() => {\n    const v = D(t), k = v.length, S = D(o), M = /* @__PURE__ */ new Map();\n    for (let z = 0; z < k; ++z)\n      M.set(v[z][S], z);\n    return M;\n  }), f = P(0), h = /* @__PURE__ */ new Map(), y = _(() => {\n    const v = D(t), k = v.length, S = D(o), M = Br(k, D(r));\n    for (let z = 0; z < k; ++z) {\n      const X = v[z][S], W = h.get(X);\n      W && M.add(z, W);\n    }\n    return M;\n  }), g = P(0), w = P(0), d = _(() => Math.max(\n    y.value.boundIndex(w.value) - Math.max(D(c), 0),\n    0\n  )), l = _(() => {\n    if (!f.value || f.value < 0)\n      return [];\n    const v = D(t), k = Math.min(\n      y.value.boundIndex(w.value + f.value) + 1 + Math.max(D(c), 0),\n      v.length\n    );\n    return v.slice(d.value, k);\n  }), p = _(() => {\n    g.value;\n    const v = y.value.sum(), k = D(n);\n    return {\n      height: k ? `${v}px` : void 0,\n      minHeight: k ? void 0 : `${v}px`,\n      boxSizing: \"content-box\"\n    };\n  }), b = _(() => (g.value, {\n    transform: `translate3d(0, ${y.value.sum(d.value)}px, 0)`\n  }));\n  _e(() => {\n    ze(() => {\n      const v = D(i);\n      s && v && gr(v, O), nt(a) && T(a);\n    });\n  }), s && ve(() => {\n    const v = D(i);\n    v && mr(v);\n  });\n  function x() {\n    const v = D(i);\n    v && (w.value = v.scrollTop);\n  }\n  function m() {\n    Hr(x);\n  }\n  function O(v) {\n    zt(v.target) || v.contentRect.height === f.value || (f.value = v.contentRect.height);\n  }\n  function E(v, k) {\n    var ee, ae;\n    if (D(n))\n      return;\n    const S = u.value.get(v), M = y.value, z = M.get(S), X = ((ae = (ee = k.borderBoxSize) == null ? void 0 : ee[0]) == null ? void 0 : ae.blockSize) ?? k.contentRect.height;\n    if (X === z)\n      return;\n    if (zt(k.target)) {\n      z && (M.add(S, -z), g.value++);\n      return;\n    }\n    const W = X - D(r), Y = X - z;\n    if (W ? h.set(v, W) : h.delete(v), !Y)\n      return;\n    M.add(S, Y), g.value++;\n    const V = D(i);\n    if (V) {\n      const te = M.sum(S);\n      V.scrollTop > te && V.scrollBy(0, Y), w.value = V.scrollTop;\n    }\n  }\n  function R(v, k) {\n    const S = D(i);\n    S && S.scrollTo({\n      behavior: k,\n      top: v,\n      left: 0\n    });\n  }\n  function B(v, k) {\n    const S = D(i);\n    S && S.scrollBy({\n      behavior: k,\n      top: v,\n      left: 0\n    });\n  }\n  function T(v, k) {\n    const S = u.value.get(v);\n    S != null && A(S, k);\n  }\n  function A(v, k) {\n    const S = D(i);\n    S && S.scrollTo({\n      behavior: k,\n      top: y.value.sum(v),\n      left: 0\n    });\n  }\n  function C(v, k) {\n    const S = D(i);\n    if (!S)\n      return;\n    const M = y.value, z = S.scrollTop;\n    if (M.sum(v) < z) {\n      A(v, k);\n      return;\n    }\n    const W = S.offsetHeight, Y = z + W, V = M.sum(v + 1);\n    V > Y && R(V - W, k);\n  }\n  function L(v, k) {\n    const S = u.value.get(v);\n    S != null && C(S, k);\n  }\n  return {\n    wrapper: i,\n    indexMap: u,\n    heightTree: y,\n    startIndex: d,\n    scrollOffset: w,\n    visibleItems: l,\n    listStyle: p,\n    itemsStyle: b,\n    handleScroll: m,\n    handleResize: O,\n    handleItemResize: E,\n    scrollTo: R,\n    scrollBy: B,\n    scrollToKey: T,\n    scrollToIndex: A,\n    ensureIndexInView: C,\n    ensureKeyInView: L\n  };\n}\nfunction Yo(e, t, r) {\n  for (const n of t)\n    if (e[n])\n      return (o) => Tr(e, n, o);\n  return r || null;\n}\nexport {\n  he as CLICK_OUTSIDE,\n  Yo as createSlotRender,\n  zt as isHiddenElement,\n  gr as observeResize,\n  $o as placementWhileList,\n  Jt as queryOutsideHiddenElement,\n  mr as unobserveResize,\n  Bo as useClickOutside,\n  Mo as useDisplay,\n  Ao as useFullScreen,\n  Po as useHover,\n  Do as useIntersection,\n  Q as useListener,\n  Co as useManualRef,\n  Lo as useModifier,\n  Wo as useMounted,\n  Fo as useMoving,\n  jo as usePointer,\n  Ho as usePopper,\n  Io as useResize,\n  qo as useSetInterval,\n  No as useSetTimeout,\n  Xo as useTriggerHandler,\n  Vo as useVirtual\n};\n//# sourceMappingURL=index.mjs.map\n",
      "start": 1698982453767,
      "end": 1698982454155,
      "sourcemaps": null
    },
    {
      "name": "vite:css",
      "start": 1698982454155,
      "end": 1698982454155,
      "order": "normal"
    },
    {
      "name": "vite:esbuild",
      "start": 1698982454155,
      "end": 1698982454155,
      "order": "normal"
    },
    {
      "name": "vite:json",
      "start": 1698982454155,
      "end": 1698982454155,
      "order": "normal"
    },
    {
      "name": "vite:worker",
      "start": 1698982454155,
      "end": 1698982454155,
      "order": "normal"
    },
    {
      "name": "vite:vue",
      "start": 1698982454155,
      "end": 1698982454155,
      "order": "normal"
    },
    {
      "name": "vite:define",
      "start": 1698982454155,
      "end": 1698982454155,
      "order": "normal"
    },
    {
      "name": "vite:css-post",
      "start": 1698982454155,
      "end": 1698982454155,
      "order": "normal"
    },
    {
      "name": "vite:build-html",
      "start": 1698982454155,
      "end": 1698982454155,
      "order": "normal"
    },
    {
      "name": "vite:worker-import-meta-url",
      "start": 1698982454155,
      "end": 1698982454155,
      "order": "normal"
    },
    {
      "name": "vite:asset-import-meta-url",
      "start": 1698982454155,
      "end": 1698982454155,
      "order": "normal"
    },
    {
      "name": "commonjs",
      "start": 1698982454155,
      "end": 1698982454155,
      "order": "normal"
    },
    {
      "name": "vite:dynamic-import-vars",
      "start": 1698982454155,
      "end": 1698982454155,
      "order": "normal"
    },
    {
      "name": "vite:import-glob",
      "start": 1698982454155,
      "end": 1698982454155,
      "order": "normal"
    },
    {
      "name": "vite:build-import-analysis",
      "start": 1698982454155,
      "end": 1698982454155,
      "order": "normal"
    },
    {
      "name": "vite:reporter",
      "start": 1698982454155,
      "end": 1698982454155,
      "order": "normal"
    }
  ]
}
